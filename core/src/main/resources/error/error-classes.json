{
  "AMBIGUOUS_COLUMN_OR_FIELD" : {
    "message" : [
      "Column or field <name> is ambiguous and has <n> matches."
    ],
    "sqlState" : "42000"
  },
  "ARITHMETIC_OVERFLOW" : {
    "message" : [
      "<message>.<alternative> If necessary set <config> to \"false\" to bypass this error."
    ],
    "sqlState" : "22003"
  },
  "CANNOT_CAST_DATATYPE" : {
    "message" : [
      "Cannot cast <sourceType> to <targetType>."
    ],
    "sqlState" : "22005"
  },
  "CANNOT_DECODE_URL" : {
    "message" : [
      "Cannot decode url : <url>."
    ],
    "sqlState" : "42000"
  },
  "CANNOT_INFER_DATE" : {
    "message" : [
      "Cannot infer date in schema inference when LegacyTimeParserPolicy is \"LEGACY\". Legacy Date formatter does not support strict date format matching which is required to avoid inferring timestamps and other non-date entries to date."
    ],
    "sqlState" : "22007"
  },
  "CANNOT_PARSE_DECIMAL" : {
    "message" : [
      "Cannot parse decimal"
    ],
    "sqlState" : "42000"
  },
  "CANNOT_PARSE_TIMESTAMP" : {
    "message" : [
      "<message>. If necessary set <ansiConfig> to \"false\" to bypass this error."
    ],
    "sqlState" : "42000"
  },
  "CANNOT_UP_CAST_DATATYPE" : {
    "message" : [
      "Cannot up cast <expression> from <sourceType> to <targetType>.",
      "<details>"
    ]
  },
  "CAST_INVALID_INPUT" : {
    "message" : [
      "The value <expression> of the type <sourceType> cannot be cast to <targetType> because it is malformed. Correct the value as per the syntax, or change its target type. Use `try_cast` to tolerate malformed input and return NULL instead. If necessary set <ansiConfig> to \"false\" to bypass this error."
    ],
    "sqlState" : "42000"
  },
  "CAST_OVERFLOW" : {
    "message" : [
      "The value <value> of the type <sourceType> cannot be cast to <targetType> due to an overflow. Use `try_cast` to tolerate overflow and return NULL instead. If necessary set <ansiConfig> to \"false\" to bypass this error."
    ],
    "sqlState" : "22005"
  },
  "CAST_OVERFLOW_IN_TABLE_INSERT" : {
    "message" : [
      "Fail to insert a value of <sourceType> type into the <targetType> type column <columnName> due to an overflow. Use `try_cast` on the input value to tolerate overflow and return NULL instead."
    ],
    "sqlState" : "22005"
  },
  "COLUMN_NOT_IN_GROUP_BY_CLAUSE" : {
    "message" : [
      "The expression <expression> is neither present in the group by, nor is it an aggregate function. Add to group by or wrap in `first()` (or `first_value()`) if you don't care which value you get."
    ],
    "sqlState" : "42000"
  },
  "CONCURRENT_QUERY" : {
    "message" : [
      "Another instance of this query was just started by a concurrent session."
    ]
  },
  "CONVERSION_INVALID_INPUT" : {
    "message" : [
      "The value <str> (<fmt>) cannot be converted to <targetType> because it is malformed. Correct the value as per the syntax, or change its format. Use <suggestion> to tolerate malformed input and return NULL instead."
    ]
  },
  "DATATYPE_MISMATCH" : {
    "message" : [
      "Cannot resolve <sqlExpr> due to data type mismatch:"
    ],
    "subClass" : {
      "BINARY_OP_DIFF_TYPES" : {
        "message" : [
          "the left and right operands of the binary operator have incompatible types (<left> and <right>)."
        ]
      },
      "BINARY_OP_WRONG_TYPE" : {
        "message" : [
          "the binary operator requires the input type <inputType>, not <actualDataType>."
        ]
      },
      "CAST_WITHOUT_SUGGESTION" : {
        "message" : [
          "cannot cast <srcType> to <targetType>."
        ]
      },
      "CAST_WITH_CONF_SUGGESTION" : {
        "message" : [
          "cannot cast <srcType> to <targetType> with ANSI mode on.",
          "If you have to cast <srcType> to <targetType>, you can set <config> as <configVal>."
        ]
      },
      "CAST_WITH_FUN_SUGGESTION" : {
        "message" : [
          "cannot cast <srcType> to <targetType>.",
          "To convert values from <srcType> to <targetType>, you can use the functions <functionNames> instead."
        ]
      },
      "UNEXPECTED_INPUT_TYPE" : {
        "message" : [
          "parameter <paramIndex> requires <requiredType> type, however, <inputSql> is of <inputType> type."
        ]
      }
    }
  },
  "DATETIME_OVERFLOW" : {
    "message" : [
      "Datetime operation overflow: <operation>."
    ],
    "sqlState" : "22008"
  },
  "DIVIDE_BY_ZERO" : {
    "message" : [
      "Division by zero. Use `try_divide` to tolerate divisor being 0 and return NULL instead. If necessary set <config> to \"false\" to bypass this error."
    ],
    "sqlState" : "22012"
  },
  "DUPLICATE_KEY" : {
    "message" : [
      "Found duplicate keys <keyColumn>"
    ],
    "sqlState" : "23000"
  },
  "ELEMENT_AT_BY_INDEX_ZERO" : {
    "message" : [
      "The index 0 is invalid. An index shall be either < 0 or > 0 (the first element has index 1)."
    ]
  },
  "FAILED_EXECUTE_UDF" : {
    "message" : [
      "Failed to execute user defined function (<functionName>: (<signature>) => <result>)"
    ]
  },
  "FAILED_RENAME_PATH" : {
    "message" : [
      "Failed to rename <sourcePath> to <targetPath> as destination already exists"
    ],
    "sqlState" : "22023"
  },
  "FORBIDDEN_OPERATION" : {
    "message" : [
      "The operation <statement> is not allowed on the <objectType>: <objectName>"
    ]
  },
  "GRAPHITE_SINK_INVALID_PROTOCOL" : {
    "message" : [
      "Invalid Graphite protocol: <protocol>"
    ]
  },
  "GRAPHITE_SINK_PROPERTY_MISSING" : {
    "message" : [
      "Graphite sink requires '<property>' property."
    ]
  },
  "GROUPING_COLUMN_MISMATCH" : {
    "message" : [
      "Column of grouping (<grouping>) can't be found in grouping columns <groupingColumns>"
    ],
    "sqlState" : "42000"
  },
  "GROUPING_ID_COLUMN_MISMATCH" : {
    "message" : [
      "Columns of grouping_id (<groupingIdColumn>) does not match grouping columns (<groupByColumns>)"
    ],
    "sqlState" : "42000"
  },
  "GROUPING_SIZE_LIMIT_EXCEEDED" : {
    "message" : [
      "Grouping sets size cannot be greater than <maxSize>"
    ]
  },
  "GROUP_BY_POS_OUT_OF_RANGE" : {
    "message" : [
      "GROUP BY position <index> is not in select list (valid range is [1, <size>])."
    ],
    "sqlState" : "42000"
  },
  "GROUP_BY_POS_REFERS_AGG_EXPR" : {
    "message" : [
      "GROUP BY <index> refers to an expression <aggExpr> that contains an aggregate function. Aggregate functions are not allowed in GROUP BY."
    ],
    "sqlState" : "42000"
  },
  "INCOMPARABLE_PIVOT_COLUMN" : {
    "message" : [
      "Invalid pivot column <columnName>. Pivot columns must be comparable."
    ],
    "sqlState" : "42000"
  },
  "INCOMPATIBLE_DATASOURCE_REGISTER" : {
    "message" : [
      "Detected an incompatible DataSourceRegister. Please remove the incompatible library from classpath or upgrade it. Error: <message>"
    ]
  },
  "INCONSISTENT_BEHAVIOR_CROSS_VERSION" : {
    "message" : [
      "You may get a different result due to the upgrading to"
    ],
    "subClass" : {
      "DATETIME_PATTERN_RECOGNITION" : {
        "message" : [
          "Spark >= 3.0:",
          "Fail to recognize <pattern> pattern in the DateTimeFormatter. 1) You can set <config> to \"LEGACY\" to restore the behavior before Spark 3.0. 2) You can form a valid datetime pattern with the guide from https://spark.apache.org/docs/latest/sql-ref-datetime-pattern.html"
        ]
      },
      "FORMAT_DATETIME_BY_NEW_PARSER" : {
        "message" : [
          "Spark >= 3.0:",
          "Fail to format it to <resultCandidate> in the new formatter. You can set <config> to \"LEGACY\" to restore the behavior before Spark 3.0, or set to \"CORRECTED\" and treat it as an invalid datetime string."
        ]
      },
      "PARSE_DATETIME_BY_NEW_PARSER" : {
        "message" : [
          "Spark >= 3.0:",
          "Fail to parse <datetime> in the new parser. You can set <config> to \"LEGACY\" to restore the behavior before Spark 3.0, or set to \"CORRECTED\" and treat it as an invalid datetime string."
        ]
      },
      "READ_ANCIENT_DATETIME" : {
        "message" : [
          "Spark >= 3.0:",
          "reading dates before 1582-10-15 or timestamps before 1900-01-01T00:00:00Z",
          "from <format> files can be ambiguous, as the files may be written by",
          "Spark 2.x or legacy versions of Hive, which uses a legacy hybrid calendar",
          "that is different from Spark 3.0+'s Proleptic Gregorian calendar.",
          "See more details in SPARK-31404. You can set the SQL config <config> or",
          "the datasource option <option> to \"LEGACY\" to rebase the datetime values",
          "w.r.t. the calendar difference during reading. To read the datetime values",
          "as it is, set the SQL config or the datasource option to \"CORRECTED\"."
        ]
      },
      "WRITE_ANCIENT_DATETIME" : {
        "message" : [
          "Spark >= 3.0:",
          "writing dates before 1582-10-15 or timestamps before 1900-01-01T00:00:00Z",
          "into <format> files can be dangerous, as the files may be read by Spark 2.x",
          "or legacy versions of Hive later, which uses a legacy hybrid calendar that",
          "is different from Spark 3.0+'s Proleptic Gregorian calendar. See more",
          "details in SPARK-31404. You can set <config> to \"LEGACY\" to rebase the",
          "datetime values w.r.t. the calendar difference during writing, to get maximum",
          "interoperability. Or set the config to \"CORRECTED\" to write the datetime",
          "values as it is, if you are sure that the written files will only be read by",
          "Spark 3.0+ or other systems that use Proleptic Gregorian calendar."
        ]
      }
    }
  },
  "INTERNAL_ERROR" : {
    "message" : [
      "<message>"
    ]
  },
  "INTERVAL_ARITHMETIC_OVERFLOW" : {
    "message" : [
      "<message>.<alternative>"
    ],
    "sqlState" : "22003"
  },
  "INTERVAL_DIVIDED_BY_ZERO" : {
    "message" : [
      "Division by zero. Use `try_divide` to tolerate divisor being 0 and return NULL instead."
    ],
    "sqlState" : "22012"
  },
  "INVALID_ARRAY_INDEX" : {
    "message" : [
      "The index <indexValue> is out of bounds. The array has <arraySize> elements. Use the SQL function `get()` to tolerate accessing element at invalid index and return NULL instead. If necessary set <ansiConfig> to \"false\" to bypass this error."
    ]
  },
  "INVALID_ARRAY_INDEX_IN_ELEMENT_AT" : {
    "message" : [
      "The index <indexValue> is out of bounds. The array has <arraySize> elements. Use `try_element_at` to tolerate accessing element at invalid index and return NULL instead. If necessary set <ansiConfig> to \"false\" to bypass this error."
    ]
  },
  "INVALID_BUCKET_FILE" : {
    "message" : [
      "Invalid bucket file: <path>"
    ]
  },
  "INVALID_COLUMN_OR_FIELD_DATA_TYPE" : {
    "message" : [
      "Column or field <name> is of type <type> while it's required to be <expectedType>."
    ],
    "sqlState" : "42000"
  },
  "INVALID_FIELD_NAME" : {
    "message" : [
      "Field name <fieldName> is invalid: <path> is not a struct."
    ],
    "sqlState" : "42000"
  },
  "INVALID_FRACTION_OF_SECOND" : {
    "message" : [
      "The fraction of sec must be zero. Valid range is [0, 60]. If necessary set <ansiConfig> to \"false\" to bypass this error."
    ],
    "sqlState" : "22023"
  },
  "INVALID_JSON_SCHEMA_MAP_TYPE" : {
    "message" : [
      "Input schema <jsonSchema> can only contain STRING as a key type for a MAP."
    ]
  },
  "INVALID_PANDAS_UDF_PLACEMENT" : {
    "message" : [
      "The group aggregate pandas UDF <functionList> cannot be invoked together with as other, non-pandas aggregate functions."
    ]
  },
  "INVALID_PARAMETER_VALUE" : {
    "message" : [
      "The value of parameter(s) '<parameter>' in <functionName> is invalid: <expected>"
    ],
    "sqlState" : "22023"
  },
  "INVALID_PROPERTY_KEY" : {
    "message" : [
      "<key> is an invalid property key, please use quotes, e.g. SET <key>=<value>"
    ]
  },
  "INVALID_PROPERTY_VALUE" : {
    "message" : [
      "<value> is an invalid property value, please use quotes, e.g. SET <key>=<value>"
    ]
  },
  "INVALID_SQL_SYNTAX" : {
    "message" : [
      "Invalid SQL syntax: <inputString>"
    ],
    "sqlState" : "42000"
  },
  "INVALID_SUBQUERY_EXPRESSION" : {
    "message" : [
      "Invalid subquery:"
    ],
    "subClass" : {
      "SCALAR_SUBQUERY_RETURN_MORE_THAN_ONE_OUTPUT_COLUMN" : {
        "message" : [
          "Scalar subquery must return only one column, but got <number>"
        ]
      }
    }
  },
  "MISSING_STATIC_PARTITION_COLUMN" : {
    "message" : [
      "Unknown static partition column: <columnName>"
    ],
    "sqlState" : "42000"
  },
  "MULTI_UDF_INTERFACE_ERROR" : {
    "message" : [
      "Not allowed to implement multiple UDF interfaces, UDF class <className>"
    ]
  },
  "MULTI_VALUE_SUBQUERY_ERROR" : {
    "message" : [
      "More than one row returned by a subquery used as an expression."
    ]
  },
  "NON_LITERAL_PIVOT_VALUES" : {
    "message" : [
      "Literal expressions required for pivot values, found <expression>."
    ],
    "sqlState" : "42000"
  },
  "NON_PARTITION_COLUMN" : {
    "message" : [
      "PARTITION clause cannot contain the non-partition column: <columnName>."
    ],
    "sqlState" : "42000"
  },
  "NO_HANDLER_FOR_UDAF" : {
    "message" : [
      "No handler for UDAF '<functionName>'. Use sparkSession.udf.register(...) instead."
    ]
  },
  "NO_UDF_INTERFACE_ERROR" : {
    "message" : [
      "UDF class <className> doesn't implement any UDF interface"
    ]
  },
  "NULLABLE_ARRAY_OR_MAP_ELEMENT" : {
    "message" : [
      "Array or map at <columnPath> contains nullable element while it's required to be non-nullable."
    ],
    "sqlState" : "42000"
  },
  "NULLABLE_COLUMN_OR_FIELD" : {
    "message" : [
      "Column or field <name> is nullable while it's required to be non-nullable."
    ],
    "sqlState" : "42000"
  },
  "NULL_COMPARISON_RESULT" : {
    "message" : [
      "The comparison result is null. If you want to handle null as 0 (equal), you can set \"spark.sql.legacy.allowNullComparisonResultInArraySort\" to \"true\"."
    ]
  },
  "NUMERIC_VALUE_OUT_OF_RANGE" : {
    "message" : [
      "<value> cannot be represented as Decimal(<precision>, <scale>). If necessary set <config> to \"false\" to bypass this error."
    ],
    "sqlState" : "22005"
  },
  "PARSE_CHAR_MISSING_LENGTH" : {
    "message" : [
      "DataType <type> requires a length parameter, for example <type>(10). Please specify the length."
    ],
    "sqlState" : "42000"
  },
  "PARSE_EMPTY_STATEMENT" : {
    "message" : [
      "Syntax error, unexpected empty statement"
    ],
    "sqlState" : "42000"
  },
  "PARSE_SYNTAX_ERROR" : {
    "message" : [
      "Syntax error at or near <error><hint>"
    ],
    "sqlState" : "42000"
  },
  "PIVOT_VALUE_DATA_TYPE_MISMATCH" : {
    "message" : [
      "Invalid pivot value '<value>': value data type <valueType> does not match pivot column data type <pivotType>"
    ],
    "sqlState" : "42000"
  },
  "RENAME_SRC_PATH_NOT_FOUND" : {
    "message" : [
      "Failed to rename as <sourcePath> was not found"
    ],
    "sqlState" : "22023"
  },
  "RESET_PERMISSION_TO_ORIGINAL" : {
    "message" : [
      "Failed to set original permission <permission> back to the created path: <path>. Exception: <message>"
    ]
  },
  "SECOND_FUNCTION_ARGUMENT_NOT_INTEGER" : {
    "message" : [
      "The second argument of <functionName> function needs to be an integer."
    ],
    "sqlState" : "22023"
  },
  "TOO_MANY_ARRAY_ELEMENTS" : {
    "message" : [
      "Cannot initialize array with <numElements> elements of size <size>"
    ]
  },
  "UNABLE_TO_ACQUIRE_MEMORY" : {
    "message" : [
      "Unable to acquire <requestedBytes> bytes of memory, got <receivedBytes>"
    ]
  },
  "UNPIVOT_REQUIRES_VALUE_COLUMNS" : {
    "message" : [
      "At least one value column needs to be specified for UNPIVOT, all columns specified as ids"
    ],
    "sqlState" : "42000"
  },
  "UNPIVOT_VALUE_DATA_TYPE_MISMATCH" : {
    "message" : [
      "Unpivot value columns must share a least common type, some types do not: [<types>]"
    ],
    "sqlState" : "42000"
  },
  "UNRECOGNIZED_SQL_TYPE" : {
    "message" : [
      "Unrecognized SQL type <typeName>"
    ],
    "sqlState" : "42000"
  },
  "UNRESOLVED_COLUMN" : {
    "message" : [
      "A column or function parameter with name <objectName> cannot be resolved."
    ],
    "subClass" : {
      "WITHOUT_SUGGESTION" : {
        "message" : [
          ""
        ]
      },
      "WITH_SUGGESTION" : {
        "message" : [
          "Did you mean one of the following? [<proposal>]"
        ]
      }
    },
    "sqlState" : "42000"
  },
  "UNRESOLVED_FIELD" : {
    "message" : [
      "A field with name <fieldName> cannot be resolved with the struct-type column <columnPath>."
    ],
    "subClass" : {
      "WITHOUT_SUGGESTION" : {
        "message" : [
          ""
        ]
      },
      "WITH_SUGGESTION" : {
        "message" : [
          "Did you mean one of the following? [<proposal>]"
        ]
      }
    },
    "sqlState" : "42000"
  },
  "UNRESOLVED_MAP_KEY" : {
    "message" : [
      "Cannot resolve column <objectName> as a map key. If the key is a string literal, please add single quotes around it."
    ],
    "subClass" : {
      "WITHOUT_SUGGESTION" : {
        "message" : [
          ""
        ]
      },
      "WITH_SUGGESTION" : {
        "message" : [
          "Otherwise did you mean one of the following column(s)? [<proposal>]"
        ]
      }
    },
    "sqlState" : "42000"
  },
  "UNSUPPORTED_DATATYPE" : {
    "message" : [
      "Unsupported data type <typeName>"
    ],
    "sqlState" : "0A000"
  },
  "UNSUPPORTED_DESERIALIZER" : {
    "message" : [
      "The deserializer is not supported:"
    ],
    "subClass" : {
      "DATA_TYPE_MISMATCH" : {
        "message" : [
          "need a(n) <desiredType> field but got <dataType>."
        ]
      },
      "FIELD_NUMBER_MISMATCH" : {
        "message" : [
          "try to map <schema> to Tuple<ordinal>, but failed as the number of fields does not line up."
        ]
      }
    }
  },
  "UNSUPPORTED_FEATURE" : {
    "message" : [
      "The feature is not supported:"
    ],
    "subClass" : {
      "AES_MODE" : {
        "message" : [
          "AES-<mode> with the padding <padding> by the <functionName> function."
        ]
      },
      "CATALOG_OPERATION" : {
        "message" : [
          "Catalog <catalogName> does not support <operation>."
        ]
      },
      "DESC_TABLE_COLUMN_PARTITION" : {
        "message" : [
          "DESC TABLE COLUMN for a specific partition."
        ]
      },
      "DISTRIBUTE_BY" : {
        "message" : [
          "DISTRIBUTE BY clause."
        ]
      },
      "INSERT_PARTITION_SPEC_IF_NOT_EXISTS" : {
        "message" : [
          "INSERT INTO <tableName> IF NOT EXISTS in the PARTITION spec."
        ]
      },
      "JDBC_TRANSACTION" : {
        "message" : [
          "The target JDBC server does not support transactions and can only support ALTER TABLE with a single action."
        ]
      },
      "LATERAL_JOIN_OF_TYPE" : {
        "message" : [
          "<joinType> JOIN with LATERAL correlation."
        ]
      },
      "LATERAL_JOIN_USING" : {
        "message" : [
          "JOIN USING with LATERAL correlation."
        ]
      },
      "LATERAL_NATURAL_JOIN" : {
        "message" : [
          "NATURAL join with LATERAL correlation."
        ]
      },
      "LITERAL_TYPE" : {
        "message" : [
          "Literal for '<value>' of <type>."
        ]
      },
      "NATURAL_CROSS_JOIN" : {
        "message" : [
          "NATURAL CROSS JOIN."
        ]
      },
      "ORC_TYPE_CAST" : {
        "message" : [
          "Unable to convert <orcType> of Orc to data type <toType>."
        ]
      },
      "PANDAS_UDAF_IN_PIVOT" : {
        "message" : [
          "Pandas user defined aggregate function in the PIVOT clause."
        ]
      },
      "PIVOT_AFTER_GROUP_BY" : {
        "message" : [
          "PIVOT clause following a GROUP BY clause."
        ]
      },
      "PIVOT_TYPE" : {
        "message" : [
          "Pivoting by the value '<value>' of the column data type <type>."
        ]
      },
      "PYTHON_UDF_IN_ON_CLAUSE" : {
        "message" : [
          "Python UDF in the ON clause of a <joinType> JOIN."
        ]
      },
      "REPEATED_PIVOT" : {
        "message" : [
          "Repeated PIVOT operation."
        ]
      },
      "SET_NAMESPACE_PROPERTY" : {
        "message" : [
          "<property> is a reserved namespace property, <msg>."
        ]
      },
      "SET_PROPERTIES_AND_DBPROPERTIES" : {
        "message" : [
          "set PROPERTIES and DBPROPERTIES at the same time."
        ]
      },
      "SET_TABLE_PROPERTY" : {
        "message" : [
          "<property> is a reserved table property, <msg>."
        ]
      },
      "TABLE_OPERATION" : {
        "message" : [
          "Table <tableName> does not support <operation>. Please check the current catalog and namespace to make sure the qualified table name is expected, and also check the catalog implementation which is configured by \"spark.sql.catalog\"."
        ]
      },
      "TOO_MANY_TYPE_ARGUMENTS_FOR_UDF_CLASS" : {
        "message" : [
          "UDF class with <num> type arguments."
        ]
      },
      "TRANSFORM_DISTINCT_ALL" : {
        "message" : [
          "TRANSFORM with the DISTINCT/ALL clause."
        ]
      },
      "TRANSFORM_NON_HIVE" : {
        "message" : [
          "TRANSFORM with SERDE is only supported in hive mode."
        ]
      }
    },
    "sqlState" : "0A000"
  },
  "UNSUPPORTED_GENERATOR" : {
    "message" : [
      "The generator is not supported:"
    ],
    "subClass" : {
      "MULTI_GENERATOR" : {
        "message" : [
          "only one generator allowed per <clause> clause but found <num>: <generators>"
        ]
      },
      "NESTED_IN_EXPRESSIONS" : {
        "message" : [
          "nested in expressions <expression>"
        ]
      },
      "NOT_GENERATOR" : {
        "message" : [
          "<functionName> is expected to be a generator. However, its class is <classCanonicalName>, which is not a generator."
        ]
      },
      "OUTSIDE_SELECT" : {
        "message" : [
          "outside the SELECT clause, found: <plan>"
        ]
      }
    }
  },
  "UNSUPPORTED_GROUPING_EXPRESSION" : {
    "message" : [
      "grouping()/grouping_id() can only be used with GroupingSets/Cube/Rollup"
    ]
  },
  "UNSUPPORTED_SAVE_MODE" : {
    "message" : [
      "The save mode <saveMode> is not supported for:"
    ],
    "subClass" : {
      "EXISTENT_PATH" : {
        "message" : [
          "an existent path."
        ]
      },
      "NON_EXISTENT_PATH" : {
        "message" : [
          "a non-existent path."
        ]
      }
    }
  },
  "UNSUPPORTED_SUBQUERY_EXPRESSION_CATEGORY" : {
    "message" : [
      "Unsupported subquery expression:"
    ],
    "subClass" : {
      "ACCESSING_OUTER_QUERY_COLUMN_IS_NOT_ALLOWED" : {
        "message" : [
          "Accessing outer query column is not allowed in this location<treeNode>"
        ]
      },
      "AGGREGATE_FUNCTION_MIXED_OUTER_LOCAL_REFERENCES" : {
        "message" : [
          "Found an aggregate function in a correlated predicate that has both outer and local references, which is not supported: <function>"
        ]
      },
      "CORRELATED_COLUMN_IS_NOT_ALLOWED_IN_PREDICATE" : {
        "message" : [
          "Correlated column is not allowed in predicate: <treeNode>"
        ]
      },
      "CORRELATED_COLUMN_NOT_FOUND" : {
        "message" : [
          "A correlated outer name reference within a subquery expression body was not found in the enclosing query: <value>"
        ]
      },
      "LATERAL_JOIN_CONDITION_NON_DETERMINISTIC" : {
        "message" : [
          "Lateral join condition cannot be non-deterministic: <condition>"
        ]
      },
      "MUST_AGGREGATE_CORRELATED_SCALAR_SUBQUERY" : {
        "message" : [
          "Correlated scalar subqueries in the GROUP BY clause must also be in the aggregate expressions<treeNode>"
        ]
      },
      "MUST_AGGREGATE_CORRELATED_SCALAR_SUBQUERY_OUTPUT" : {
        "message" : [
          "The output of a correlated scalar subquery must be aggregated"
        ]
      },
      "NON_CORRELATED_COLUMNS_IN_GROUP_BY" : {
        "message" : [
          "A GROUP BY clause in a scalar correlated subquery cannot contain non-correlated columns: <value>"
        ]
      },
      "NON_DETERMINISTIC_LATERAL_SUBQUERIES" : {
        "message" : [
          "Non-deterministic lateral subqueries are not supported when joining with outer relations that produce more than one row<treeNode>"
        ]
      },
      "UNSUPPORTED_CORRELATED_REFERENCE" : {
        "message" : [
          "Expressions referencing the outer query are not supported outside of WHERE/HAVING clauses<treeNode>"
        ]
      },
      "UNSUPPORTED_CORRELATED_SCALAR_SUBQUERY" : {
        "message" : [
          "Correlated scalar subqueries can only be used in filters, aggregations, projections, and UPDATE/MERGE/DELETE commands<treeNode>"
        ]
      },
      "UNSUPPORTED_IN_EXISTS_SUBQUERY" : {
        "message" : [
          "IN/EXISTS predicate subqueries can only be used in filters, joins, aggregations, window functions, projections, and UPDATE/MERGE/DELETE commands<treeNode>"
        ]
      }
    }
  },
  "UNTYPED_SCALA_UDF" : {
    "message" : [
      "You're using untyped Scala UDF, which does not have the input type information. Spark may blindly pass null to the Scala closure with primitive-type argument, and the closure will see the default value of the Java type for the null argument, e.g. `udf((x: Int) => x, IntegerType)`, the result is 0 for null input. To get rid of this error, you could:",
      "1. use typed Scala UDF APIs(without return type parameter), e.g. `udf((x: Int) => x)`",
      "2. use Java UDF APIs, e.g. `udf(new UDF1[String, Integer] { override def call(s: String): Integer = s.length() }, IntegerType)`, if input types are all non primitive",
      "3. set \"spark.sql.legacy.allowUntypedScalaUDF\" to \"true\" and use this API with caution"
    ]
  },
  "WRITING_JOB_ABORTED" : {
    "message" : [
      "Writing job aborted"
    ],
    "sqlState" : "40000"
  },
  "_LEGACY_ERROR_TEMP_0001" : {
    "message" : [
      "Invalid InsertIntoContext"
    ]
  },
  "_LEGACY_ERROR_TEMP_0002" : {
    "message" : [
      "INSERT OVERWRITE DIRECTORY is not supported"
    ]
  },
  "_LEGACY_ERROR_TEMP_0003" : {
    "message" : [
      "Columns aliases are not allowed in <op>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0004" : {
    "message" : [
      "Empty source for merge: you should specify a source table/subquery in merge."
    ]
  },
  "_LEGACY_ERROR_TEMP_0005" : {
    "message" : [
      "Unrecognized matched action: <matchedAction>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0006" : {
    "message" : [
      "The number of inserted values cannot match the fields."
    ]
  },
  "_LEGACY_ERROR_TEMP_0007" : {
    "message" : [
      "Unrecognized not matched action: <notMatchedAction>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0008" : {
    "message" : [
      "There must be at least one WHEN clause in a MERGE statement."
    ]
  },
  "_LEGACY_ERROR_TEMP_0009" : {
    "message" : [
      "When there are more than one MATCHED clauses in a MERGE statement, only the last MATCHED clause can omit the condition."
    ]
  },
  "_LEGACY_ERROR_TEMP_0010" : {
    "message" : [
      "When there are more than one NOT MATCHED clauses in a MERGE statement, only the last NOT MATCHED clause can omit the condition."
    ]
  },
  "_LEGACY_ERROR_TEMP_0011" : {
    "message" : [
      "Combination of ORDER BY/SORT BY/DISTRIBUTE BY/CLUSTER BY is not supported."
    ]
  },
  "_LEGACY_ERROR_TEMP_0012" : {
    "message" : [
      "DISTRIBUTE BY is not supported."
    ]
  },
  "_LEGACY_ERROR_TEMP_0013" : {
    "message" : [
      "LATERAL cannot be used together with PIVOT in FROM clause."
    ]
  },
  "_LEGACY_ERROR_TEMP_0014" : {
    "message" : [
      "TABLESAMPLE does not accept empty inputs."
    ]
  },
  "_LEGACY_ERROR_TEMP_0015" : {
    "message" : [
      "TABLESAMPLE(<msg>) is not supported."
    ]
  },
  "_LEGACY_ERROR_TEMP_0016" : {
    "message" : [
      "<bytesStr> is not a valid byte length literal, expected syntax: DIGIT+ ('B' | 'K' | 'M' | 'G')."
    ]
  },
  "_LEGACY_ERROR_TEMP_0017" : {
    "message" : [
      "Invalid escape string. Escape string must contain only one character."
    ]
  },
  "_LEGACY_ERROR_TEMP_0018" : {
    "message" : [
      "Function trim doesn't support with type <trimOption>. Please use BOTH, LEADING or TRAILING as trim type."
    ]
  },
  "_LEGACY_ERROR_TEMP_0019" : {
    "message" : [
      "Cannot parse the <valueType> value: <value>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0020" : {
    "message" : [
      "Cannot parse the INTERVAL value: <value>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0021" : {
    "message" : [
      "Literals of type '<valueType>' are currently not supported."
    ]
  },
  "_LEGACY_ERROR_TEMP_0022" : {
    "message" : [
      "<msg>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0023" : {
    "message" : [
      "Numeric literal <rawStrippedQualifier> does not fit in range [<minValue>, <maxValue>] for type <typeName>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0024" : {
    "message" : [
      "Can only have a single from-to unit in the interval literal syntax."
    ]
  },
  "_LEGACY_ERROR_TEMP_0025" : {
    "message" : [
      "At least one time unit should be given for interval literal."
    ]
  },
  "_LEGACY_ERROR_TEMP_0026" : {
    "message" : [
      "Can only use numbers in the interval value part for multiple unit value pairs interval form, but got invalid value: <value>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0027" : {
    "message" : [
      "The value of from-to unit must be a string."
    ]
  },
  "_LEGACY_ERROR_TEMP_0028" : {
    "message" : [
      "Intervals FROM <from> TO <to> are not supported."
    ]
  },
  "_LEGACY_ERROR_TEMP_0029" : {
    "message" : [
      "Cannot mix year-month and day-time fields: <literal>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0030" : {
    "message" : [
      "DataType <dataType> is not supported."
    ]
  },
  "_LEGACY_ERROR_TEMP_0031" : {
    "message" : [
      "Invalid number of buckets: <describe>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0032" : {
    "message" : [
      "Duplicated table paths found: '<pathOne>' and '<pathTwo>'. LOCATION and the case insensitive key 'path' in OPTIONS are all used to indicate the custom table path, you can only specify one of them."
    ]
  },
  "_LEGACY_ERROR_TEMP_0033" : {
    "message" : [
      "Expected either STORED AS or STORED BY, not both."
    ]
  },
  "_LEGACY_ERROR_TEMP_0034" : {
    "message" : [
      "<operation> is not supported in Hive-style <command><msg>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0035" : {
    "message" : [
      "Operation not allowed: <message>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0036" : {
    "message" : [
      "Expected `NOSCAN` instead of `<ctx>`."
    ]
  },
  "_LEGACY_ERROR_TEMP_0037" : {
    "message" : [
      "It is not allowed to add catalog/namespace prefix <quoted> to the table name in CACHE TABLE AS SELECT."
    ]
  },
  "_LEGACY_ERROR_TEMP_0038" : {
    "message" : [
      "CTE definition can't have duplicate names: <duplicateNames>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0039" : {
    "message" : [
      "Unsupported SQL statement."
    ]
  },
  "_LEGACY_ERROR_TEMP_0040" : {
    "message" : [
      "Possibly unquoted identifier <ident> detected. Please consider quoting it with back-quotes as `<ident>`."
    ]
  },
  "_LEGACY_ERROR_TEMP_0041" : {
    "message" : [
      "Found duplicate clauses: <clauseName>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0042" : {
    "message" : [
      "Expected format is 'SET', 'SET key', or 'SET key=value'. If you want to include special characters in key, or include semicolon in value, please use quotes, e.g., SET `key`=`value`."
    ]
  },
  "_LEGACY_ERROR_TEMP_0043" : {
    "message" : [
      "Expected format is 'RESET' or 'RESET key'. If you want to include special characters in key, please use quotes, e.g., RESET `key`."
    ]
  },
  "_LEGACY_ERROR_TEMP_0044" : {
    "message" : [
      "The interval value must be in the range of [-18, +18] hours with second precision."
    ]
  },
  "_LEGACY_ERROR_TEMP_0045" : {
    "message" : [
      "Invalid time zone displacement value."
    ]
  },
  "_LEGACY_ERROR_TEMP_0046" : {
    "message" : [
      "CREATE TEMPORARY TABLE without a provider is not allowed."
    ]
  },
  "_LEGACY_ERROR_TEMP_0047" : {
    "message" : [
      "'ROW FORMAT' must be used with 'STORED AS'."
    ]
  },
  "_LEGACY_ERROR_TEMP_0048" : {
    "message" : [
      "Unsupported operation: Used defined record reader/writer classes."
    ]
  },
  "_LEGACY_ERROR_TEMP_0049" : {
    "message" : [
      "Directory path and 'path' in OPTIONS should be specified one, but not both."
    ]
  },
  "_LEGACY_ERROR_TEMP_0050" : {
    "message" : [
      "LOCAL is supported only with file: scheme."
    ]
  },
  "_LEGACY_ERROR_TEMP_0051" : {
    "message" : [
      "Empty set in <element> grouping sets is not supported."
    ]
  },
  "_LEGACY_ERROR_TEMP_0052" : {
    "message" : [
      "CREATE VIEW with both IF NOT EXISTS and REPLACE is not allowed."
    ]
  },
  "_LEGACY_ERROR_TEMP_0053" : {
    "message" : [
      "It is not allowed to define a TEMPORARY view with IF NOT EXISTS."
    ]
  },
  "_LEGACY_ERROR_TEMP_0054" : {
    "message" : [
      "It is not allowed to add database prefix `<database>` for the TEMPORARY view name."
    ]
  },
  "_LEGACY_ERROR_TEMP_0055" : {
    "message" : [
      "Unclosed bracketed comment"
    ]
  },
  "_LEGACY_ERROR_TEMP_0056" : {
    "message" : [
      "Invalid time travel spec: <reason>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0057" : {
    "message" : [
      "Support for DEFAULT column values is not implemented yet."
    ]
  },
  "_LEGACY_ERROR_TEMP_0058" : {
    "message" : [
      "Support for DEFAULT column values is not allowed."
    ]
  },
  "_LEGACY_ERROR_TEMP_0059" : {
    "message" : [
      "References to DEFAULT column values are not allowed within the PARTITION clause."
    ]
  },
  "_LEGACY_ERROR_TEMP_0060" : {
    "message" : [
      "<msg>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0061" : {
    "message" : [
      "<msg>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0062" : {
    "message" : [
      "<msg>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0063" : {
    "message" : [
      "<msg>."
    ]
  },
  "_LEGACY_ERROR_TEMP_0064" : {
    "message" : [
      "<msg>."
    ]
  }
}
