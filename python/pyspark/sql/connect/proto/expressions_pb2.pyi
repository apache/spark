#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file

Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

from collections import abc as _abc
from google.protobuf import any_pb2 as _any_pb2
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf.internal import containers as _containers
from google.protobuf.internal import enum_type_wrapper as _enum_type_wrapper
from pyspark.sql.connect.proto import common_pb2 as _common_pb2
from pyspark.sql.connect.proto import types_pb2 as _types_pb2
import builtins as _builtins
import sys
import typing as _typing

if sys.version_info >= (3, 10):
    from typing import TypeAlias as _TypeAlias
else:
    from typing_extensions import TypeAlias as _TypeAlias

if sys.version_info >= (3, 13):
    from warnings import deprecated as _deprecated
else:
    from typing_extensions import deprecated as _deprecated

DESCRIPTOR: _descriptor.FileDescriptor

@_typing.final
class Expression(_message.Message):
    """Expression used to refer to fields, functions and similar. This can be used everywhere
    expressions in SQL appear.
    """

    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class Window(_message.Message):
        """Expression for the OVER clause or WINDOW clause."""

        DESCRIPTOR: _descriptor.Descriptor

        @_typing.final
        class WindowFrame(_message.Message):
            """The window frame"""

            DESCRIPTOR: _descriptor.Descriptor

            class _FrameType:
                ValueType = _typing.NewType("ValueType", _builtins.int)
                V: _TypeAlias = ValueType  # noqa: Y015

            class _FrameTypeEnumTypeWrapper(
                _enum_type_wrapper._EnumTypeWrapper[
                    Expression.Window.WindowFrame._FrameType.ValueType
                ],
                _builtins.type,
            ):
                DESCRIPTOR: _descriptor.EnumDescriptor
                FRAME_TYPE_UNDEFINED: Expression.Window.WindowFrame._FrameType.ValueType  # 0
                FRAME_TYPE_ROW: Expression.Window.WindowFrame._FrameType.ValueType  # 1
                """RowFrame treats rows in a partition individually."""
                FRAME_TYPE_RANGE: Expression.Window.WindowFrame._FrameType.ValueType  # 2
                """RangeFrame treats rows in a partition as groups of peers.
                All rows having the same 'ORDER BY' ordering are considered as peers.
                """

            class FrameType(_FrameType, metaclass=_FrameTypeEnumTypeWrapper): ...
            FRAME_TYPE_UNDEFINED: Expression.Window.WindowFrame.FrameType.ValueType  # 0
            FRAME_TYPE_ROW: Expression.Window.WindowFrame.FrameType.ValueType  # 1
            """RowFrame treats rows in a partition individually."""
            FRAME_TYPE_RANGE: Expression.Window.WindowFrame.FrameType.ValueType  # 2
            """RangeFrame treats rows in a partition as groups of peers.
            All rows having the same 'ORDER BY' ordering are considered as peers.
            """

            @_typing.final
            class FrameBoundary(_message.Message):
                DESCRIPTOR: _descriptor.Descriptor

                CURRENT_ROW_FIELD_NUMBER: _builtins.int
                UNBOUNDED_FIELD_NUMBER: _builtins.int
                VALUE_FIELD_NUMBER: _builtins.int
                current_row: _builtins.bool
                """CURRENT ROW boundary"""
                unbounded: _builtins.bool
                """UNBOUNDED boundary.
                For lower bound, it will be converted to 'UnboundedPreceding'.
                for upper bound, it will be converted to 'UnboundedFollowing'.
                """
                @_builtins.property
                def value(self) -> Global___Expression:
                    """This is an expression for future proofing. We are expecting literals on the server side."""
                def __init__(
                    self,
                    *,
                    current_row: _builtins.bool = ...,
                    unbounded: _builtins.bool = ...,
                    value: Global___Expression | None = ...,
                ) -> None: ...
                _HasFieldArgType: _TypeAlias = _typing.Literal[
                    "boundary",
                    b"boundary",
                    "current_row",
                    b"current_row",
                    "unbounded",
                    b"unbounded",
                    "value",
                    b"value",
                ]  # noqa: Y015
                def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
                _ClearFieldArgType: _TypeAlias = _typing.Literal[
                    "boundary",
                    b"boundary",
                    "current_row",
                    b"current_row",
                    "unbounded",
                    b"unbounded",
                    "value",
                    b"value",
                ]  # noqa: Y015
                def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
                _WhichOneofReturnType_boundary: _TypeAlias = _typing.Literal[
                    "current_row", "unbounded", "value"
                ]  # noqa: Y015
                _WhichOneofArgType_boundary: _TypeAlias = _typing.Literal[
                    "boundary", b"boundary"
                ]  # noqa: Y015
                def WhichOneof(
                    self, oneof_group: _WhichOneofArgType_boundary
                ) -> _WhichOneofReturnType_boundary | None: ...

            FRAME_TYPE_FIELD_NUMBER: _builtins.int
            LOWER_FIELD_NUMBER: _builtins.int
            UPPER_FIELD_NUMBER: _builtins.int
            frame_type: Global___Expression.Window.WindowFrame.FrameType.ValueType
            """(Required) The type of the frame."""
            @_builtins.property
            def lower(self) -> Global___Expression.Window.WindowFrame.FrameBoundary:
                """(Required) The lower bound of the frame."""
            @_builtins.property
            def upper(self) -> Global___Expression.Window.WindowFrame.FrameBoundary:
                """(Required) The upper bound of the frame."""
            def __init__(
                self,
                *,
                frame_type: Global___Expression.Window.WindowFrame.FrameType.ValueType = ...,
                lower: Global___Expression.Window.WindowFrame.FrameBoundary | None = ...,
                upper: Global___Expression.Window.WindowFrame.FrameBoundary | None = ...,
            ) -> None: ...
            _HasFieldArgType: _TypeAlias = _typing.Literal[
                "lower", b"lower", "upper", b"upper"
            ]  # noqa: Y015
            def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
            _ClearFieldArgType: _TypeAlias = _typing.Literal[
                "frame_type", b"frame_type", "lower", b"lower", "upper", b"upper"
            ]  # noqa: Y015
            def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

        WINDOW_FUNCTION_FIELD_NUMBER: _builtins.int
        PARTITION_SPEC_FIELD_NUMBER: _builtins.int
        ORDER_SPEC_FIELD_NUMBER: _builtins.int
        FRAME_SPEC_FIELD_NUMBER: _builtins.int
        @_builtins.property
        def window_function(self) -> Global___Expression:
            """(Required) The window function."""
        @_builtins.property
        def partition_spec(
            self,
        ) -> _containers.RepeatedCompositeFieldContainer[Global___Expression]:
            """(Optional) The way that input rows are partitioned."""
        @_builtins.property
        def order_spec(
            self,
        ) -> _containers.RepeatedCompositeFieldContainer[Global___Expression.SortOrder]:
            """(Optional) Ordering of rows in a partition."""
        @_builtins.property
        def frame_spec(self) -> Global___Expression.Window.WindowFrame:
            """(Optional) Window frame in a partition.

            If not set, it will be treated as 'UnspecifiedFrame'.
            """
        def __init__(
            self,
            *,
            window_function: Global___Expression | None = ...,
            partition_spec: _abc.Iterable[Global___Expression] | None = ...,
            order_spec: _abc.Iterable[Global___Expression.SortOrder] | None = ...,
            frame_spec: Global___Expression.Window.WindowFrame | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "frame_spec", b"frame_spec", "window_function", b"window_function"
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "frame_spec",
            b"frame_spec",
            "order_spec",
            b"order_spec",
            "partition_spec",
            b"partition_spec",
            "window_function",
            b"window_function",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    @_typing.final
    class SortOrder(_message.Message):
        """SortOrder is used to specify the  data ordering, it is normally used in Sort and Window.
        It is an unevaluable expression and cannot be evaluated, so can not be used in Projection.
        """

        DESCRIPTOR: _descriptor.Descriptor

        class _SortDirection:
            ValueType = _typing.NewType("ValueType", _builtins.int)
            V: _TypeAlias = ValueType  # noqa: Y015

        class _SortDirectionEnumTypeWrapper(
            _enum_type_wrapper._EnumTypeWrapper[Expression.SortOrder._SortDirection.ValueType],
            _builtins.type,
        ):
            DESCRIPTOR: _descriptor.EnumDescriptor
            SORT_DIRECTION_UNSPECIFIED: Expression.SortOrder._SortDirection.ValueType  # 0
            SORT_DIRECTION_ASCENDING: Expression.SortOrder._SortDirection.ValueType  # 1
            SORT_DIRECTION_DESCENDING: Expression.SortOrder._SortDirection.ValueType  # 2

        class SortDirection(_SortDirection, metaclass=_SortDirectionEnumTypeWrapper): ...
        SORT_DIRECTION_UNSPECIFIED: Expression.SortOrder.SortDirection.ValueType  # 0
        SORT_DIRECTION_ASCENDING: Expression.SortOrder.SortDirection.ValueType  # 1
        SORT_DIRECTION_DESCENDING: Expression.SortOrder.SortDirection.ValueType  # 2

        class _NullOrdering:
            ValueType = _typing.NewType("ValueType", _builtins.int)
            V: _TypeAlias = ValueType  # noqa: Y015

        class _NullOrderingEnumTypeWrapper(
            _enum_type_wrapper._EnumTypeWrapper[Expression.SortOrder._NullOrdering.ValueType],
            _builtins.type,
        ):
            DESCRIPTOR: _descriptor.EnumDescriptor
            SORT_NULLS_UNSPECIFIED: Expression.SortOrder._NullOrdering.ValueType  # 0
            SORT_NULLS_FIRST: Expression.SortOrder._NullOrdering.ValueType  # 1
            SORT_NULLS_LAST: Expression.SortOrder._NullOrdering.ValueType  # 2

        class NullOrdering(_NullOrdering, metaclass=_NullOrderingEnumTypeWrapper): ...
        SORT_NULLS_UNSPECIFIED: Expression.SortOrder.NullOrdering.ValueType  # 0
        SORT_NULLS_FIRST: Expression.SortOrder.NullOrdering.ValueType  # 1
        SORT_NULLS_LAST: Expression.SortOrder.NullOrdering.ValueType  # 2

        CHILD_FIELD_NUMBER: _builtins.int
        DIRECTION_FIELD_NUMBER: _builtins.int
        NULL_ORDERING_FIELD_NUMBER: _builtins.int
        direction: Global___Expression.SortOrder.SortDirection.ValueType
        """(Required) The sort direction, should be ASCENDING or DESCENDING."""
        null_ordering: Global___Expression.SortOrder.NullOrdering.ValueType
        """(Required) How to deal with NULLs, should be NULLS_FIRST or NULLS_LAST."""
        @_builtins.property
        def child(self) -> Global___Expression:
            """(Required) The expression to be sorted."""
        def __init__(
            self,
            *,
            child: Global___Expression | None = ...,
            direction: Global___Expression.SortOrder.SortDirection.ValueType = ...,
            null_ordering: Global___Expression.SortOrder.NullOrdering.ValueType = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal["child", b"child"]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "child", b"child", "direction", b"direction", "null_ordering", b"null_ordering"
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    @_typing.final
    class DirectShufflePartitionID(_message.Message):
        """Expression that takes a partition ID value and passes it through directly for use in
        shuffle partitioning. This is used with RepartitionByExpression to allow users to
        directly specify target partition IDs.
        """

        DESCRIPTOR: _descriptor.Descriptor

        CHILD_FIELD_NUMBER: _builtins.int
        @_builtins.property
        def child(self) -> Global___Expression:
            """(Required) The expression that evaluates to the partition ID."""
        def __init__(
            self,
            *,
            child: Global___Expression | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal["child", b"child"]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["child", b"child"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    @_typing.final
    class Cast(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        class _EvalMode:
            ValueType = _typing.NewType("ValueType", _builtins.int)
            V: _TypeAlias = ValueType  # noqa: Y015

        class _EvalModeEnumTypeWrapper(
            _enum_type_wrapper._EnumTypeWrapper[Expression.Cast._EvalMode.ValueType], _builtins.type
        ):
            DESCRIPTOR: _descriptor.EnumDescriptor
            EVAL_MODE_UNSPECIFIED: Expression.Cast._EvalMode.ValueType  # 0
            EVAL_MODE_LEGACY: Expression.Cast._EvalMode.ValueType  # 1
            EVAL_MODE_ANSI: Expression.Cast._EvalMode.ValueType  # 2
            EVAL_MODE_TRY: Expression.Cast._EvalMode.ValueType  # 3

        class EvalMode(_EvalMode, metaclass=_EvalModeEnumTypeWrapper): ...
        EVAL_MODE_UNSPECIFIED: Expression.Cast.EvalMode.ValueType  # 0
        EVAL_MODE_LEGACY: Expression.Cast.EvalMode.ValueType  # 1
        EVAL_MODE_ANSI: Expression.Cast.EvalMode.ValueType  # 2
        EVAL_MODE_TRY: Expression.Cast.EvalMode.ValueType  # 3

        EXPR_FIELD_NUMBER: _builtins.int
        TYPE_FIELD_NUMBER: _builtins.int
        TYPE_STR_FIELD_NUMBER: _builtins.int
        EVAL_MODE_FIELD_NUMBER: _builtins.int
        type_str: _builtins.str
        """If this is set, Server will use Catalyst parser to parse this string to DataType."""
        eval_mode: Global___Expression.Cast.EvalMode.ValueType
        """(Optional) The expression evaluation mode."""
        @_builtins.property
        def expr(self) -> Global___Expression:
            """(Required) the expression to be casted."""
        @_builtins.property
        def type(self) -> _types_pb2.DataType: ...
        def __init__(
            self,
            *,
            expr: Global___Expression | None = ...,
            type: _types_pb2.DataType | None = ...,
            type_str: _builtins.str = ...,
            eval_mode: Global___Expression.Cast.EvalMode.ValueType = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "cast_to_type",
            b"cast_to_type",
            "expr",
            b"expr",
            "type",
            b"type",
            "type_str",
            b"type_str",
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "cast_to_type",
            b"cast_to_type",
            "eval_mode",
            b"eval_mode",
            "expr",
            b"expr",
            "type",
            b"type",
            "type_str",
            b"type_str",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType_cast_to_type: _TypeAlias = _typing.Literal[
            "type", "type_str"
        ]  # noqa: Y015
        _WhichOneofArgType_cast_to_type: _TypeAlias = _typing.Literal[
            "cast_to_type", b"cast_to_type"
        ]  # noqa: Y015
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType_cast_to_type
        ) -> _WhichOneofReturnType_cast_to_type | None: ...

    @_typing.final
    class Literal(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        @_typing.final
        class Decimal(_message.Message):
            DESCRIPTOR: _descriptor.Descriptor

            VALUE_FIELD_NUMBER: _builtins.int
            PRECISION_FIELD_NUMBER: _builtins.int
            SCALE_FIELD_NUMBER: _builtins.int
            value: _builtins.str
            """the string representation."""
            precision: _builtins.int
            """The maximum number of digits allowed in the value.
            the maximum precision is 38.
            """
            scale: _builtins.int
            """declared scale of decimal literal"""
            def __init__(
                self,
                *,
                value: _builtins.str = ...,
                precision: _builtins.int | None = ...,
                scale: _builtins.int | None = ...,
            ) -> None: ...
            _HasFieldArgType: _TypeAlias = _typing.Literal[
                "_precision",
                b"_precision",
                "_scale",
                b"_scale",
                "precision",
                b"precision",
                "scale",
                b"scale",
            ]  # noqa: Y015
            def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
            _ClearFieldArgType: _TypeAlias = _typing.Literal[
                "_precision",
                b"_precision",
                "_scale",
                b"_scale",
                "precision",
                b"precision",
                "scale",
                b"scale",
                "value",
                b"value",
            ]  # noqa: Y015
            def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
            _WhichOneofReturnType__precision: _TypeAlias = _typing.Literal[
                "precision"
            ]  # noqa: Y015
            _WhichOneofArgType__precision: _TypeAlias = _typing.Literal[
                "_precision", b"_precision"
            ]  # noqa: Y015
            _WhichOneofReturnType__scale: _TypeAlias = _typing.Literal["scale"]  # noqa: Y015
            _WhichOneofArgType__scale: _TypeAlias = _typing.Literal[
                "_scale", b"_scale"
            ]  # noqa: Y015
            @_typing.overload
            def WhichOneof(
                self, oneof_group: _WhichOneofArgType__precision
            ) -> _WhichOneofReturnType__precision | None: ...
            @_typing.overload
            def WhichOneof(
                self, oneof_group: _WhichOneofArgType__scale
            ) -> _WhichOneofReturnType__scale | None: ...

        @_typing.final
        class CalendarInterval(_message.Message):
            DESCRIPTOR: _descriptor.Descriptor

            MONTHS_FIELD_NUMBER: _builtins.int
            DAYS_FIELD_NUMBER: _builtins.int
            MICROSECONDS_FIELD_NUMBER: _builtins.int
            months: _builtins.int
            days: _builtins.int
            microseconds: _builtins.int
            def __init__(
                self,
                *,
                months: _builtins.int = ...,
                days: _builtins.int = ...,
                microseconds: _builtins.int = ...,
            ) -> None: ...
            _ClearFieldArgType: _TypeAlias = _typing.Literal[
                "days", b"days", "microseconds", b"microseconds", "months", b"months"
            ]  # noqa: Y015
            def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

        @_typing.final
        class Array(_message.Message):
            DESCRIPTOR: _descriptor.Descriptor

            ELEMENT_TYPE_FIELD_NUMBER: _builtins.int
            ELEMENTS_FIELD_NUMBER: _builtins.int
            @_builtins.property
            @_deprecated("""This field has been marked as deprecated using proto field options.""")
            def element_type(self) -> _types_pb2.DataType:
                """(Deprecated) The element type of the array.

                This field is deprecated since Spark 4.1+. Use data_type field instead.
                """
            @_builtins.property
            def elements(
                self,
            ) -> _containers.RepeatedCompositeFieldContainer[Global___Expression.Literal]:
                """The literal values that make up the array elements."""
            def __init__(
                self,
                *,
                element_type: _types_pb2.DataType | None = ...,
                elements: _abc.Iterable[Global___Expression.Literal] | None = ...,
            ) -> None: ...
            _HasFieldArgType: _TypeAlias = _typing.Literal[
                "element_type", b"element_type"
            ]  # noqa: Y015
            def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
            _ClearFieldArgType: _TypeAlias = _typing.Literal[
                "element_type", b"element_type", "elements", b"elements"
            ]  # noqa: Y015
            def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

        @_typing.final
        class Map(_message.Message):
            DESCRIPTOR: _descriptor.Descriptor

            KEY_TYPE_FIELD_NUMBER: _builtins.int
            VALUE_TYPE_FIELD_NUMBER: _builtins.int
            KEYS_FIELD_NUMBER: _builtins.int
            VALUES_FIELD_NUMBER: _builtins.int
            @_builtins.property
            @_deprecated("""This field has been marked as deprecated using proto field options.""")
            def key_type(self) -> _types_pb2.DataType:
                """(Deprecated) The key type of the map.

                This field is deprecated since Spark 4.1+. Use data_type field instead.
                """
            @_builtins.property
            @_deprecated("""This field has been marked as deprecated using proto field options.""")
            def value_type(self) -> _types_pb2.DataType:
                """(Deprecated) The value type of the map.

                This field is deprecated since Spark 4.1+ and should only be set
                if the data_type field is not set. Use data_type field instead.
                """
            @_builtins.property
            def keys(
                self,
            ) -> _containers.RepeatedCompositeFieldContainer[Global___Expression.Literal]:
                """The literal keys that make up the map."""
            @_builtins.property
            def values(
                self,
            ) -> _containers.RepeatedCompositeFieldContainer[Global___Expression.Literal]:
                """The literal values that make up the map."""
            def __init__(
                self,
                *,
                key_type: _types_pb2.DataType | None = ...,
                value_type: _types_pb2.DataType | None = ...,
                keys: _abc.Iterable[Global___Expression.Literal] | None = ...,
                values: _abc.Iterable[Global___Expression.Literal] | None = ...,
            ) -> None: ...
            _HasFieldArgType: _TypeAlias = _typing.Literal[
                "key_type", b"key_type", "value_type", b"value_type"
            ]  # noqa: Y015
            def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
            _ClearFieldArgType: _TypeAlias = _typing.Literal[
                "key_type",
                b"key_type",
                "keys",
                b"keys",
                "value_type",
                b"value_type",
                "values",
                b"values",
            ]  # noqa: Y015
            def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

        @_typing.final
        class Struct(_message.Message):
            DESCRIPTOR: _descriptor.Descriptor

            STRUCT_TYPE_FIELD_NUMBER: _builtins.int
            ELEMENTS_FIELD_NUMBER: _builtins.int
            @_builtins.property
            @_deprecated("""This field has been marked as deprecated using proto field options.""")
            def struct_type(self) -> _types_pb2.DataType:
                """(Deprecated) The type of the struct.

                This field is deprecated since Spark 4.1+ because using DataType as the type of a struct
                is ambiguous. Use data_type field instead.
                """
            @_builtins.property
            def elements(
                self,
            ) -> _containers.RepeatedCompositeFieldContainer[Global___Expression.Literal]:
                """The literal values that make up the struct elements."""
            def __init__(
                self,
                *,
                struct_type: _types_pb2.DataType | None = ...,
                elements: _abc.Iterable[Global___Expression.Literal] | None = ...,
            ) -> None: ...
            _HasFieldArgType: _TypeAlias = _typing.Literal[
                "struct_type", b"struct_type"
            ]  # noqa: Y015
            def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
            _ClearFieldArgType: _TypeAlias = _typing.Literal[
                "elements", b"elements", "struct_type", b"struct_type"
            ]  # noqa: Y015
            def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

        @_typing.final
        class SpecializedArray(_message.Message):
            DESCRIPTOR: _descriptor.Descriptor

            BOOLS_FIELD_NUMBER: _builtins.int
            INTS_FIELD_NUMBER: _builtins.int
            LONGS_FIELD_NUMBER: _builtins.int
            FLOATS_FIELD_NUMBER: _builtins.int
            DOUBLES_FIELD_NUMBER: _builtins.int
            STRINGS_FIELD_NUMBER: _builtins.int
            @_builtins.property
            def bools(self) -> _common_pb2.Bools: ...
            @_builtins.property
            def ints(self) -> _common_pb2.Ints: ...
            @_builtins.property
            def longs(self) -> _common_pb2.Longs: ...
            @_builtins.property
            def floats(self) -> _common_pb2.Floats: ...
            @_builtins.property
            def doubles(self) -> _common_pb2.Doubles: ...
            @_builtins.property
            def strings(self) -> _common_pb2.Strings: ...
            def __init__(
                self,
                *,
                bools: _common_pb2.Bools | None = ...,
                ints: _common_pb2.Ints | None = ...,
                longs: _common_pb2.Longs | None = ...,
                floats: _common_pb2.Floats | None = ...,
                doubles: _common_pb2.Doubles | None = ...,
                strings: _common_pb2.Strings | None = ...,
            ) -> None: ...
            _HasFieldArgType: _TypeAlias = _typing.Literal[
                "bools",
                b"bools",
                "doubles",
                b"doubles",
                "floats",
                b"floats",
                "ints",
                b"ints",
                "longs",
                b"longs",
                "strings",
                b"strings",
                "value_type",
                b"value_type",
            ]  # noqa: Y015
            def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
            _ClearFieldArgType: _TypeAlias = _typing.Literal[
                "bools",
                b"bools",
                "doubles",
                b"doubles",
                "floats",
                b"floats",
                "ints",
                b"ints",
                "longs",
                b"longs",
                "strings",
                b"strings",
                "value_type",
                b"value_type",
            ]  # noqa: Y015
            def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
            _WhichOneofReturnType_value_type: _TypeAlias = _typing.Literal[
                "bools", "ints", "longs", "floats", "doubles", "strings"
            ]  # noqa: Y015
            _WhichOneofArgType_value_type: _TypeAlias = _typing.Literal[
                "value_type", b"value_type"
            ]  # noqa: Y015
            def WhichOneof(
                self, oneof_group: _WhichOneofArgType_value_type
            ) -> _WhichOneofReturnType_value_type | None: ...

        @_typing.final
        class Time(_message.Message):
            DESCRIPTOR: _descriptor.Descriptor

            NANO_FIELD_NUMBER: _builtins.int
            PRECISION_FIELD_NUMBER: _builtins.int
            nano: _builtins.int
            precision: _builtins.int
            """The precision of this time, if omitted, uses the default value of MICROS_PRECISION."""
            def __init__(
                self,
                *,
                nano: _builtins.int = ...,
                precision: _builtins.int | None = ...,
            ) -> None: ...
            _HasFieldArgType: _TypeAlias = _typing.Literal[
                "_precision", b"_precision", "precision", b"precision"
            ]  # noqa: Y015
            def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
            _ClearFieldArgType: _TypeAlias = _typing.Literal[
                "_precision", b"_precision", "nano", b"nano", "precision", b"precision"
            ]  # noqa: Y015
            def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
            _WhichOneofReturnType__precision: _TypeAlias = _typing.Literal[
                "precision"
            ]  # noqa: Y015
            _WhichOneofArgType__precision: _TypeAlias = _typing.Literal[
                "_precision", b"_precision"
            ]  # noqa: Y015
            def WhichOneof(
                self, oneof_group: _WhichOneofArgType__precision
            ) -> _WhichOneofReturnType__precision | None: ...

        NULL_FIELD_NUMBER: _builtins.int
        BINARY_FIELD_NUMBER: _builtins.int
        BOOLEAN_FIELD_NUMBER: _builtins.int
        BYTE_FIELD_NUMBER: _builtins.int
        SHORT_FIELD_NUMBER: _builtins.int
        INTEGER_FIELD_NUMBER: _builtins.int
        LONG_FIELD_NUMBER: _builtins.int
        FLOAT_FIELD_NUMBER: _builtins.int
        DOUBLE_FIELD_NUMBER: _builtins.int
        DECIMAL_FIELD_NUMBER: _builtins.int
        STRING_FIELD_NUMBER: _builtins.int
        DATE_FIELD_NUMBER: _builtins.int
        TIMESTAMP_FIELD_NUMBER: _builtins.int
        TIMESTAMP_NTZ_FIELD_NUMBER: _builtins.int
        CALENDAR_INTERVAL_FIELD_NUMBER: _builtins.int
        YEAR_MONTH_INTERVAL_FIELD_NUMBER: _builtins.int
        DAY_TIME_INTERVAL_FIELD_NUMBER: _builtins.int
        ARRAY_FIELD_NUMBER: _builtins.int
        MAP_FIELD_NUMBER: _builtins.int
        STRUCT_FIELD_NUMBER: _builtins.int
        SPECIALIZED_ARRAY_FIELD_NUMBER: _builtins.int
        TIME_FIELD_NUMBER: _builtins.int
        DATA_TYPE_FIELD_NUMBER: _builtins.int
        binary: _builtins.bytes
        boolean: _builtins.bool
        byte: _builtins.int
        short: _builtins.int
        integer: _builtins.int
        long: _builtins.int
        float: _builtins.float
        double: _builtins.float
        string: _builtins.str
        date: _builtins.int
        """Date in units of days since the UNIX epoch."""
        timestamp: _builtins.int
        """Timestamp in units of microseconds since the UNIX epoch."""
        timestamp_ntz: _builtins.int
        """Timestamp in units of microseconds since the UNIX epoch (without timezone information)."""
        year_month_interval: _builtins.int
        day_time_interval: _builtins.int
        @_builtins.property
        def null(self) -> _types_pb2.DataType: ...
        @_builtins.property
        def decimal(self) -> Global___Expression.Literal.Decimal: ...
        @_builtins.property
        def calendar_interval(self) -> Global___Expression.Literal.CalendarInterval: ...
        @_builtins.property
        def array(self) -> Global___Expression.Literal.Array: ...
        @_builtins.property
        def map(self) -> Global___Expression.Literal.Map: ...
        @_builtins.property
        def struct(self) -> Global___Expression.Literal.Struct: ...
        @_builtins.property
        def specialized_array(self) -> Global___Expression.Literal.SpecializedArray: ...
        @_builtins.property
        def time(self) -> Global___Expression.Literal.Time: ...
        @_builtins.property
        def data_type(self) -> _types_pb2.DataType:
            """Data type information for the literal.
            This field is required only in the root literal message for null values or
            for data types (e.g., array, map, or struct) with non-trivial information.
            If the data_type field is not set at the root level, the data type will be
            inferred or retrieved from the deprecated data type fields using best efforts.
            """
        def __init__(
            self,
            *,
            null: _types_pb2.DataType | None = ...,
            binary: _builtins.bytes = ...,
            boolean: _builtins.bool = ...,
            byte: _builtins.int = ...,
            short: _builtins.int = ...,
            integer: _builtins.int = ...,
            long: _builtins.int = ...,
            float: _builtins.float = ...,
            double: _builtins.float = ...,
            decimal: Global___Expression.Literal.Decimal | None = ...,
            string: _builtins.str = ...,
            date: _builtins.int = ...,
            timestamp: _builtins.int = ...,
            timestamp_ntz: _builtins.int = ...,
            calendar_interval: Global___Expression.Literal.CalendarInterval | None = ...,
            year_month_interval: _builtins.int = ...,
            day_time_interval: _builtins.int = ...,
            array: Global___Expression.Literal.Array | None = ...,
            map: Global___Expression.Literal.Map | None = ...,
            struct: Global___Expression.Literal.Struct | None = ...,
            specialized_array: Global___Expression.Literal.SpecializedArray | None = ...,
            time: Global___Expression.Literal.Time | None = ...,
            data_type: _types_pb2.DataType | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "array",
            b"array",
            "binary",
            b"binary",
            "boolean",
            b"boolean",
            "byte",
            b"byte",
            "calendar_interval",
            b"calendar_interval",
            "data_type",
            b"data_type",
            "date",
            b"date",
            "day_time_interval",
            b"day_time_interval",
            "decimal",
            b"decimal",
            "double",
            b"double",
            "float",
            b"float",
            "integer",
            b"integer",
            "literal_type",
            b"literal_type",
            "long",
            b"long",
            "map",
            b"map",
            "null",
            b"null",
            "short",
            b"short",
            "specialized_array",
            b"specialized_array",
            "string",
            b"string",
            "struct",
            b"struct",
            "time",
            b"time",
            "timestamp",
            b"timestamp",
            "timestamp_ntz",
            b"timestamp_ntz",
            "year_month_interval",
            b"year_month_interval",
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "array",
            b"array",
            "binary",
            b"binary",
            "boolean",
            b"boolean",
            "byte",
            b"byte",
            "calendar_interval",
            b"calendar_interval",
            "data_type",
            b"data_type",
            "date",
            b"date",
            "day_time_interval",
            b"day_time_interval",
            "decimal",
            b"decimal",
            "double",
            b"double",
            "float",
            b"float",
            "integer",
            b"integer",
            "literal_type",
            b"literal_type",
            "long",
            b"long",
            "map",
            b"map",
            "null",
            b"null",
            "short",
            b"short",
            "specialized_array",
            b"specialized_array",
            "string",
            b"string",
            "struct",
            b"struct",
            "time",
            b"time",
            "timestamp",
            b"timestamp",
            "timestamp_ntz",
            b"timestamp_ntz",
            "year_month_interval",
            b"year_month_interval",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType_literal_type: _TypeAlias = _typing.Literal[
            "null",
            "binary",
            "boolean",
            "byte",
            "short",
            "integer",
            "long",
            "float",
            "double",
            "decimal",
            "string",
            "date",
            "timestamp",
            "timestamp_ntz",
            "calendar_interval",
            "year_month_interval",
            "day_time_interval",
            "array",
            "map",
            "struct",
            "specialized_array",
            "time",
        ]  # noqa: Y015
        _WhichOneofArgType_literal_type: _TypeAlias = _typing.Literal[
            "literal_type", b"literal_type"
        ]  # noqa: Y015
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType_literal_type
        ) -> _WhichOneofReturnType_literal_type | None: ...

    @_typing.final
    class UnresolvedAttribute(_message.Message):
        """An unresolved attribute that is not explicitly bound to a specific column, but the column
        is resolved during analysis by name.
        """

        DESCRIPTOR: _descriptor.Descriptor

        UNPARSED_IDENTIFIER_FIELD_NUMBER: _builtins.int
        PLAN_ID_FIELD_NUMBER: _builtins.int
        IS_METADATA_COLUMN_FIELD_NUMBER: _builtins.int
        unparsed_identifier: _builtins.str
        """(Required) An identifier that will be parsed by Catalyst parser. This should follow the
        Spark SQL identifier syntax.
        """
        plan_id: _builtins.int
        """(Optional) The id of corresponding connect plan."""
        is_metadata_column: _builtins.bool
        """(Optional) The requested column is a metadata column."""
        def __init__(
            self,
            *,
            unparsed_identifier: _builtins.str = ...,
            plan_id: _builtins.int | None = ...,
            is_metadata_column: _builtins.bool | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_is_metadata_column",
            b"_is_metadata_column",
            "_plan_id",
            b"_plan_id",
            "is_metadata_column",
            b"is_metadata_column",
            "plan_id",
            b"plan_id",
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_is_metadata_column",
            b"_is_metadata_column",
            "_plan_id",
            b"_plan_id",
            "is_metadata_column",
            b"is_metadata_column",
            "plan_id",
            b"plan_id",
            "unparsed_identifier",
            b"unparsed_identifier",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__is_metadata_column: _TypeAlias = _typing.Literal[
            "is_metadata_column"
        ]  # noqa: Y015
        _WhichOneofArgType__is_metadata_column: _TypeAlias = _typing.Literal[
            "_is_metadata_column", b"_is_metadata_column"
        ]  # noqa: Y015
        _WhichOneofReturnType__plan_id: _TypeAlias = _typing.Literal["plan_id"]  # noqa: Y015
        _WhichOneofArgType__plan_id: _TypeAlias = _typing.Literal[
            "_plan_id", b"_plan_id"
        ]  # noqa: Y015
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__is_metadata_column
        ) -> _WhichOneofReturnType__is_metadata_column | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__plan_id
        ) -> _WhichOneofReturnType__plan_id | None: ...

    @_typing.final
    class UnresolvedFunction(_message.Message):
        """An unresolved function is not explicitly bound to one explicit function, but the function
        is resolved during analysis following Sparks name resolution rules.
        """

        DESCRIPTOR: _descriptor.Descriptor

        FUNCTION_NAME_FIELD_NUMBER: _builtins.int
        ARGUMENTS_FIELD_NUMBER: _builtins.int
        IS_DISTINCT_FIELD_NUMBER: _builtins.int
        IS_USER_DEFINED_FUNCTION_FIELD_NUMBER: _builtins.int
        IS_INTERNAL_FIELD_NUMBER: _builtins.int
        function_name: _builtins.str
        """(Required) name (or unparsed name for user defined function) for the unresolved function."""
        is_distinct: _builtins.bool
        """(Required) Indicate if this function should be applied on distinct values."""
        is_user_defined_function: _builtins.bool
        """(Required) Indicate if this is a user defined function.

        When it is not a user defined function, Connect will use the function name directly.
        When it is a user defined function, Connect will parse the function name first.
        """
        is_internal: _builtins.bool
        """(Optional) Indicate if this function is defined in the internal function registry.
        If not set, the server will try to look up the function in the internal function registry
        and decide appropriately.
        """
        @_builtins.property
        def arguments(self) -> _containers.RepeatedCompositeFieldContainer[Global___Expression]:
            """(Optional) Function arguments. Empty arguments are allowed."""
        def __init__(
            self,
            *,
            function_name: _builtins.str = ...,
            arguments: _abc.Iterable[Global___Expression] | None = ...,
            is_distinct: _builtins.bool = ...,
            is_user_defined_function: _builtins.bool = ...,
            is_internal: _builtins.bool | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_is_internal", b"_is_internal", "is_internal", b"is_internal"
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_is_internal",
            b"_is_internal",
            "arguments",
            b"arguments",
            "function_name",
            b"function_name",
            "is_distinct",
            b"is_distinct",
            "is_internal",
            b"is_internal",
            "is_user_defined_function",
            b"is_user_defined_function",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__is_internal: _TypeAlias = _typing.Literal[
            "is_internal"
        ]  # noqa: Y015
        _WhichOneofArgType__is_internal: _TypeAlias = _typing.Literal[
            "_is_internal", b"_is_internal"
        ]  # noqa: Y015
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__is_internal
        ) -> _WhichOneofReturnType__is_internal | None: ...

    @_typing.final
    class ExpressionString(_message.Message):
        """Expression as string."""

        DESCRIPTOR: _descriptor.Descriptor

        EXPRESSION_FIELD_NUMBER: _builtins.int
        expression: _builtins.str
        """(Required) A SQL expression that will be parsed by Catalyst parser."""
        def __init__(
            self,
            *,
            expression: _builtins.str = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["expression", b"expression"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    @_typing.final
    class UnresolvedStar(_message.Message):
        """UnresolvedStar is used to expand all the fields of a relation or struct."""

        DESCRIPTOR: _descriptor.Descriptor

        UNPARSED_TARGET_FIELD_NUMBER: _builtins.int
        PLAN_ID_FIELD_NUMBER: _builtins.int
        unparsed_target: _builtins.str
        """(Optional) The target of the expansion.

        If set, it should end with '.*' and will be parsed by 'parseAttributeName'
        in the server side.
        """
        plan_id: _builtins.int
        """(Optional) The id of corresponding connect plan."""
        def __init__(
            self,
            *,
            unparsed_target: _builtins.str | None = ...,
            plan_id: _builtins.int | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_plan_id",
            b"_plan_id",
            "_unparsed_target",
            b"_unparsed_target",
            "plan_id",
            b"plan_id",
            "unparsed_target",
            b"unparsed_target",
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_plan_id",
            b"_plan_id",
            "_unparsed_target",
            b"_unparsed_target",
            "plan_id",
            b"plan_id",
            "unparsed_target",
            b"unparsed_target",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__plan_id: _TypeAlias = _typing.Literal["plan_id"]  # noqa: Y015
        _WhichOneofArgType__plan_id: _TypeAlias = _typing.Literal[
            "_plan_id", b"_plan_id"
        ]  # noqa: Y015
        _WhichOneofReturnType__unparsed_target: _TypeAlias = _typing.Literal[
            "unparsed_target"
        ]  # noqa: Y015
        _WhichOneofArgType__unparsed_target: _TypeAlias = _typing.Literal[
            "_unparsed_target", b"_unparsed_target"
        ]  # noqa: Y015
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__plan_id
        ) -> _WhichOneofReturnType__plan_id | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__unparsed_target
        ) -> _WhichOneofReturnType__unparsed_target | None: ...

    @_typing.final
    class UnresolvedRegex(_message.Message):
        """Represents all of the input attributes to a given relational operator, for example in
        "SELECT `(id)?+.+` FROM ...".
        """

        DESCRIPTOR: _descriptor.Descriptor

        COL_NAME_FIELD_NUMBER: _builtins.int
        PLAN_ID_FIELD_NUMBER: _builtins.int
        col_name: _builtins.str
        """(Required) The column name used to extract column with regex."""
        plan_id: _builtins.int
        """(Optional) The id of corresponding connect plan."""
        def __init__(
            self,
            *,
            col_name: _builtins.str = ...,
            plan_id: _builtins.int | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_plan_id", b"_plan_id", "plan_id", b"plan_id"
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_plan_id", b"_plan_id", "col_name", b"col_name", "plan_id", b"plan_id"
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__plan_id: _TypeAlias = _typing.Literal["plan_id"]  # noqa: Y015
        _WhichOneofArgType__plan_id: _TypeAlias = _typing.Literal[
            "_plan_id", b"_plan_id"
        ]  # noqa: Y015
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__plan_id
        ) -> _WhichOneofReturnType__plan_id | None: ...

    @_typing.final
    class UnresolvedExtractValue(_message.Message):
        """Extracts a value or values from an Expression"""

        DESCRIPTOR: _descriptor.Descriptor

        CHILD_FIELD_NUMBER: _builtins.int
        EXTRACTION_FIELD_NUMBER: _builtins.int
        @_builtins.property
        def child(self) -> Global___Expression:
            """(Required) The expression to extract value from, can be
            Map, Array, Struct or array of Structs.
            """
        @_builtins.property
        def extraction(self) -> Global___Expression:
            """(Required) The expression to describe the extraction, can be
            key of Map, index of Array, field name of Struct.
            """
        def __init__(
            self,
            *,
            child: Global___Expression | None = ...,
            extraction: Global___Expression | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "child", b"child", "extraction", b"extraction"
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "child", b"child", "extraction", b"extraction"
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    @_typing.final
    class UpdateFields(_message.Message):
        """Add, replace or drop a field of `StructType` expression by name."""

        DESCRIPTOR: _descriptor.Descriptor

        STRUCT_EXPRESSION_FIELD_NUMBER: _builtins.int
        FIELD_NAME_FIELD_NUMBER: _builtins.int
        VALUE_EXPRESSION_FIELD_NUMBER: _builtins.int
        field_name: _builtins.str
        """(Required) The field name."""
        @_builtins.property
        def struct_expression(self) -> Global___Expression:
            """(Required) The struct expression."""
        @_builtins.property
        def value_expression(self) -> Global___Expression:
            """(Optional) The expression to add or replace.

            When not set, it means this field will be dropped.
            """
        def __init__(
            self,
            *,
            struct_expression: Global___Expression | None = ...,
            field_name: _builtins.str = ...,
            value_expression: Global___Expression | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "struct_expression", b"struct_expression", "value_expression", b"value_expression"
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "field_name",
            b"field_name",
            "struct_expression",
            b"struct_expression",
            "value_expression",
            b"value_expression",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    @_typing.final
    class Alias(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        EXPR_FIELD_NUMBER: _builtins.int
        NAME_FIELD_NUMBER: _builtins.int
        METADATA_FIELD_NUMBER: _builtins.int
        metadata: _builtins.str
        """(Optional) Alias metadata expressed as a JSON map."""
        @_builtins.property
        def expr(self) -> Global___Expression:
            """(Required) The expression that alias will be added on."""
        @_builtins.property
        def name(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]:
            """(Required) a list of name parts for the alias.

            Scalar columns only has one name that presents.
            """
        def __init__(
            self,
            *,
            expr: Global___Expression | None = ...,
            name: _abc.Iterable[_builtins.str] | None = ...,
            metadata: _builtins.str | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_metadata", b"_metadata", "expr", b"expr", "metadata", b"metadata"
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_metadata", b"_metadata", "expr", b"expr", "metadata", b"metadata", "name", b"name"
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__metadata: _TypeAlias = _typing.Literal["metadata"]  # noqa: Y015
        _WhichOneofArgType__metadata: _TypeAlias = _typing.Literal[
            "_metadata", b"_metadata"
        ]  # noqa: Y015
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__metadata
        ) -> _WhichOneofReturnType__metadata | None: ...

    @_typing.final
    class LambdaFunction(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        FUNCTION_FIELD_NUMBER: _builtins.int
        ARGUMENTS_FIELD_NUMBER: _builtins.int
        @_builtins.property
        def function(self) -> Global___Expression:
            """(Required) The lambda function.

            The function body should use 'UnresolvedAttribute' as arguments, the sever side will
            replace 'UnresolvedAttribute' with 'UnresolvedNamedLambdaVariable'.
            """
        @_builtins.property
        def arguments(
            self,
        ) -> _containers.RepeatedCompositeFieldContainer[
            Global___Expression.UnresolvedNamedLambdaVariable
        ]:
            """(Required) Function variables. Must contains 1 ~ 3 variables."""
        def __init__(
            self,
            *,
            function: Global___Expression | None = ...,
            arguments: _abc.Iterable[Global___Expression.UnresolvedNamedLambdaVariable]
            | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal["function", b"function"]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "arguments", b"arguments", "function", b"function"
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    @_typing.final
    class UnresolvedNamedLambdaVariable(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        NAME_PARTS_FIELD_NUMBER: _builtins.int
        @_builtins.property
        def name_parts(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]:
            """(Required) a list of name parts for the variable. Must not be empty."""
        def __init__(
            self,
            *,
            name_parts: _abc.Iterable[_builtins.str] | None = ...,
        ) -> None: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["name_parts", b"name_parts"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    COMMON_FIELD_NUMBER: _builtins.int
    LITERAL_FIELD_NUMBER: _builtins.int
    UNRESOLVED_ATTRIBUTE_FIELD_NUMBER: _builtins.int
    UNRESOLVED_FUNCTION_FIELD_NUMBER: _builtins.int
    EXPRESSION_STRING_FIELD_NUMBER: _builtins.int
    UNRESOLVED_STAR_FIELD_NUMBER: _builtins.int
    ALIAS_FIELD_NUMBER: _builtins.int
    CAST_FIELD_NUMBER: _builtins.int
    UNRESOLVED_REGEX_FIELD_NUMBER: _builtins.int
    SORT_ORDER_FIELD_NUMBER: _builtins.int
    LAMBDA_FUNCTION_FIELD_NUMBER: _builtins.int
    WINDOW_FIELD_NUMBER: _builtins.int
    UNRESOLVED_EXTRACT_VALUE_FIELD_NUMBER: _builtins.int
    UPDATE_FIELDS_FIELD_NUMBER: _builtins.int
    UNRESOLVED_NAMED_LAMBDA_VARIABLE_FIELD_NUMBER: _builtins.int
    COMMON_INLINE_USER_DEFINED_FUNCTION_FIELD_NUMBER: _builtins.int
    CALL_FUNCTION_FIELD_NUMBER: _builtins.int
    NAMED_ARGUMENT_EXPRESSION_FIELD_NUMBER: _builtins.int
    MERGE_ACTION_FIELD_NUMBER: _builtins.int
    TYPED_AGGREGATE_EXPRESSION_FIELD_NUMBER: _builtins.int
    SUBQUERY_EXPRESSION_FIELD_NUMBER: _builtins.int
    DIRECT_SHUFFLE_PARTITION_ID_FIELD_NUMBER: _builtins.int
    EXTENSION_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def common(self) -> Global___ExpressionCommon: ...
    @_builtins.property
    def literal(self) -> Global___Expression.Literal: ...
    @_builtins.property
    def unresolved_attribute(self) -> Global___Expression.UnresolvedAttribute: ...
    @_builtins.property
    def unresolved_function(self) -> Global___Expression.UnresolvedFunction: ...
    @_builtins.property
    def expression_string(self) -> Global___Expression.ExpressionString: ...
    @_builtins.property
    def unresolved_star(self) -> Global___Expression.UnresolvedStar: ...
    @_builtins.property
    def alias(self) -> Global___Expression.Alias: ...
    @_builtins.property
    def cast(self) -> Global___Expression.Cast: ...
    @_builtins.property
    def unresolved_regex(self) -> Global___Expression.UnresolvedRegex: ...
    @_builtins.property
    def sort_order(self) -> Global___Expression.SortOrder: ...
    @_builtins.property
    def lambda_function(self) -> Global___Expression.LambdaFunction: ...
    @_builtins.property
    def window(self) -> Global___Expression.Window: ...
    @_builtins.property
    def unresolved_extract_value(self) -> Global___Expression.UnresolvedExtractValue: ...
    @_builtins.property
    def update_fields(self) -> Global___Expression.UpdateFields: ...
    @_builtins.property
    def unresolved_named_lambda_variable(
        self,
    ) -> Global___Expression.UnresolvedNamedLambdaVariable: ...
    @_builtins.property
    def common_inline_user_defined_function(self) -> Global___CommonInlineUserDefinedFunction: ...
    @_builtins.property
    def call_function(self) -> Global___CallFunction: ...
    @_builtins.property
    def named_argument_expression(self) -> Global___NamedArgumentExpression: ...
    @_builtins.property
    def merge_action(self) -> Global___MergeAction: ...
    @_builtins.property
    def typed_aggregate_expression(self) -> Global___TypedAggregateExpression: ...
    @_builtins.property
    def subquery_expression(self) -> Global___SubqueryExpression: ...
    @_builtins.property
    def direct_shuffle_partition_id(self) -> Global___Expression.DirectShufflePartitionID: ...
    @_builtins.property
    def extension(self) -> _any_pb2.Any:
        """This field is used to mark extensions to the protocol. When plugins generate arbitrary
        relations they can add them here. During the planning the correct resolution is done.
        """
    def __init__(
        self,
        *,
        common: Global___ExpressionCommon | None = ...,
        literal: Global___Expression.Literal | None = ...,
        unresolved_attribute: Global___Expression.UnresolvedAttribute | None = ...,
        unresolved_function: Global___Expression.UnresolvedFunction | None = ...,
        expression_string: Global___Expression.ExpressionString | None = ...,
        unresolved_star: Global___Expression.UnresolvedStar | None = ...,
        alias: Global___Expression.Alias | None = ...,
        cast: Global___Expression.Cast | None = ...,
        unresolved_regex: Global___Expression.UnresolvedRegex | None = ...,
        sort_order: Global___Expression.SortOrder | None = ...,
        lambda_function: Global___Expression.LambdaFunction | None = ...,
        window: Global___Expression.Window | None = ...,
        unresolved_extract_value: Global___Expression.UnresolvedExtractValue | None = ...,
        update_fields: Global___Expression.UpdateFields | None = ...,
        unresolved_named_lambda_variable: Global___Expression.UnresolvedNamedLambdaVariable
        | None = ...,
        common_inline_user_defined_function: Global___CommonInlineUserDefinedFunction | None = ...,
        call_function: Global___CallFunction | None = ...,
        named_argument_expression: Global___NamedArgumentExpression | None = ...,
        merge_action: Global___MergeAction | None = ...,
        typed_aggregate_expression: Global___TypedAggregateExpression | None = ...,
        subquery_expression: Global___SubqueryExpression | None = ...,
        direct_shuffle_partition_id: Global___Expression.DirectShufflePartitionID | None = ...,
        extension: _any_pb2.Any | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal[
        "alias",
        b"alias",
        "call_function",
        b"call_function",
        "cast",
        b"cast",
        "common",
        b"common",
        "common_inline_user_defined_function",
        b"common_inline_user_defined_function",
        "direct_shuffle_partition_id",
        b"direct_shuffle_partition_id",
        "expr_type",
        b"expr_type",
        "expression_string",
        b"expression_string",
        "extension",
        b"extension",
        "lambda_function",
        b"lambda_function",
        "literal",
        b"literal",
        "merge_action",
        b"merge_action",
        "named_argument_expression",
        b"named_argument_expression",
        "sort_order",
        b"sort_order",
        "subquery_expression",
        b"subquery_expression",
        "typed_aggregate_expression",
        b"typed_aggregate_expression",
        "unresolved_attribute",
        b"unresolved_attribute",
        "unresolved_extract_value",
        b"unresolved_extract_value",
        "unresolved_function",
        b"unresolved_function",
        "unresolved_named_lambda_variable",
        b"unresolved_named_lambda_variable",
        "unresolved_regex",
        b"unresolved_regex",
        "unresolved_star",
        b"unresolved_star",
        "update_fields",
        b"update_fields",
        "window",
        b"window",
    ]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal[
        "alias",
        b"alias",
        "call_function",
        b"call_function",
        "cast",
        b"cast",
        "common",
        b"common",
        "common_inline_user_defined_function",
        b"common_inline_user_defined_function",
        "direct_shuffle_partition_id",
        b"direct_shuffle_partition_id",
        "expr_type",
        b"expr_type",
        "expression_string",
        b"expression_string",
        "extension",
        b"extension",
        "lambda_function",
        b"lambda_function",
        "literal",
        b"literal",
        "merge_action",
        b"merge_action",
        "named_argument_expression",
        b"named_argument_expression",
        "sort_order",
        b"sort_order",
        "subquery_expression",
        b"subquery_expression",
        "typed_aggregate_expression",
        b"typed_aggregate_expression",
        "unresolved_attribute",
        b"unresolved_attribute",
        "unresolved_extract_value",
        b"unresolved_extract_value",
        "unresolved_function",
        b"unresolved_function",
        "unresolved_named_lambda_variable",
        b"unresolved_named_lambda_variable",
        "unresolved_regex",
        b"unresolved_regex",
        "unresolved_star",
        b"unresolved_star",
        "update_fields",
        b"update_fields",
        "window",
        b"window",
    ]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_expr_type: _TypeAlias = _typing.Literal[
        "literal",
        "unresolved_attribute",
        "unresolved_function",
        "expression_string",
        "unresolved_star",
        "alias",
        "cast",
        "unresolved_regex",
        "sort_order",
        "lambda_function",
        "window",
        "unresolved_extract_value",
        "update_fields",
        "unresolved_named_lambda_variable",
        "common_inline_user_defined_function",
        "call_function",
        "named_argument_expression",
        "merge_action",
        "typed_aggregate_expression",
        "subquery_expression",
        "direct_shuffle_partition_id",
        "extension",
    ]  # noqa: Y015
    _WhichOneofArgType_expr_type: _TypeAlias = _typing.Literal[
        "expr_type", b"expr_type"
    ]  # noqa: Y015
    def WhichOneof(
        self, oneof_group: _WhichOneofArgType_expr_type
    ) -> _WhichOneofReturnType_expr_type | None: ...

Global___Expression: _TypeAlias = Expression  # noqa: Y015

@_typing.final
class ExpressionCommon(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    ORIGIN_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def origin(self) -> _common_pb2.Origin:
        """(Required) Keep the information of the origin for this expression such as stacktrace."""
    def __init__(
        self,
        *,
        origin: _common_pb2.Origin | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["origin", b"origin"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["origin", b"origin"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ExpressionCommon: _TypeAlias = ExpressionCommon  # noqa: Y015

@_typing.final
class CommonInlineUserDefinedFunction(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    FUNCTION_NAME_FIELD_NUMBER: _builtins.int
    DETERMINISTIC_FIELD_NUMBER: _builtins.int
    ARGUMENTS_FIELD_NUMBER: _builtins.int
    PYTHON_UDF_FIELD_NUMBER: _builtins.int
    SCALAR_SCALA_UDF_FIELD_NUMBER: _builtins.int
    JAVA_UDF_FIELD_NUMBER: _builtins.int
    IS_DISTINCT_FIELD_NUMBER: _builtins.int
    function_name: _builtins.str
    """(Required) Name of the user-defined function."""
    deterministic: _builtins.bool
    """(Optional) Indicate if the user-defined function is deterministic."""
    is_distinct: _builtins.bool
    """(Required) Indicate if this function should be applied on distinct values."""
    @_builtins.property
    def arguments(self) -> _containers.RepeatedCompositeFieldContainer[Global___Expression]:
        """(Optional) Function arguments. Empty arguments are allowed."""
    @_builtins.property
    def python_udf(self) -> Global___PythonUDF: ...
    @_builtins.property
    def scalar_scala_udf(self) -> Global___ScalarScalaUDF: ...
    @_builtins.property
    def java_udf(self) -> Global___JavaUDF: ...
    def __init__(
        self,
        *,
        function_name: _builtins.str = ...,
        deterministic: _builtins.bool = ...,
        arguments: _abc.Iterable[Global___Expression] | None = ...,
        python_udf: Global___PythonUDF | None = ...,
        scalar_scala_udf: Global___ScalarScalaUDF | None = ...,
        java_udf: Global___JavaUDF | None = ...,
        is_distinct: _builtins.bool = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal[
        "function",
        b"function",
        "java_udf",
        b"java_udf",
        "python_udf",
        b"python_udf",
        "scalar_scala_udf",
        b"scalar_scala_udf",
    ]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal[
        "arguments",
        b"arguments",
        "deterministic",
        b"deterministic",
        "function",
        b"function",
        "function_name",
        b"function_name",
        "is_distinct",
        b"is_distinct",
        "java_udf",
        b"java_udf",
        "python_udf",
        b"python_udf",
        "scalar_scala_udf",
        b"scalar_scala_udf",
    ]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_function: _TypeAlias = _typing.Literal[
        "python_udf", "scalar_scala_udf", "java_udf"
    ]  # noqa: Y015
    _WhichOneofArgType_function: _TypeAlias = _typing.Literal["function", b"function"]  # noqa: Y015
    def WhichOneof(
        self, oneof_group: _WhichOneofArgType_function
    ) -> _WhichOneofReturnType_function | None: ...

Global___CommonInlineUserDefinedFunction: _TypeAlias = CommonInlineUserDefinedFunction  # noqa: Y015

@_typing.final
class PythonUDF(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    OUTPUT_TYPE_FIELD_NUMBER: _builtins.int
    EVAL_TYPE_FIELD_NUMBER: _builtins.int
    COMMAND_FIELD_NUMBER: _builtins.int
    PYTHON_VER_FIELD_NUMBER: _builtins.int
    ADDITIONAL_INCLUDES_FIELD_NUMBER: _builtins.int
    eval_type: _builtins.int
    """(Required) EvalType of the Python UDF"""
    command: _builtins.bytes
    """(Required) The encoded commands of the Python UDF"""
    python_ver: _builtins.str
    """(Required) Python version being used in the client."""
    @_builtins.property
    def output_type(self) -> _types_pb2.DataType:
        """(Required) Output type of the Python UDF"""
    @_builtins.property
    def additional_includes(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]:
        """(Optional) Additional includes for the Python UDF."""
    def __init__(
        self,
        *,
        output_type: _types_pb2.DataType | None = ...,
        eval_type: _builtins.int = ...,
        command: _builtins.bytes = ...,
        python_ver: _builtins.str = ...,
        additional_includes: _abc.Iterable[_builtins.str] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["output_type", b"output_type"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal[
        "additional_includes",
        b"additional_includes",
        "command",
        b"command",
        "eval_type",
        b"eval_type",
        "output_type",
        b"output_type",
        "python_ver",
        b"python_ver",
    ]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___PythonUDF: _TypeAlias = PythonUDF  # noqa: Y015

@_typing.final
class ScalarScalaUDF(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    PAYLOAD_FIELD_NUMBER: _builtins.int
    INPUTTYPES_FIELD_NUMBER: _builtins.int
    OUTPUTTYPE_FIELD_NUMBER: _builtins.int
    NULLABLE_FIELD_NUMBER: _builtins.int
    AGGREGATE_FIELD_NUMBER: _builtins.int
    payload: _builtins.bytes
    """(Required) Serialized JVM object containing UDF definition, input encoders and output encoder"""
    nullable: _builtins.bool
    """(Required) True if the UDF can return null value"""
    aggregate: _builtins.bool
    """(Required) Indicate if the UDF is an aggregate function"""
    @_builtins.property
    def inputTypes(self) -> _containers.RepeatedCompositeFieldContainer[_types_pb2.DataType]:
        """(Optional) Input type(s) of the UDF"""
    @_builtins.property
    def outputType(self) -> _types_pb2.DataType:
        """(Required) Output type of the UDF"""
    def __init__(
        self,
        *,
        payload: _builtins.bytes = ...,
        inputTypes: _abc.Iterable[_types_pb2.DataType] | None = ...,
        outputType: _types_pb2.DataType | None = ...,
        nullable: _builtins.bool = ...,
        aggregate: _builtins.bool = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["outputType", b"outputType"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal[
        "aggregate",
        b"aggregate",
        "inputTypes",
        b"inputTypes",
        "nullable",
        b"nullable",
        "outputType",
        b"outputType",
        "payload",
        b"payload",
    ]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ScalarScalaUDF: _TypeAlias = ScalarScalaUDF  # noqa: Y015

@_typing.final
class JavaUDF(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    CLASS_NAME_FIELD_NUMBER: _builtins.int
    OUTPUT_TYPE_FIELD_NUMBER: _builtins.int
    AGGREGATE_FIELD_NUMBER: _builtins.int
    class_name: _builtins.str
    """(Required) Fully qualified name of Java class"""
    aggregate: _builtins.bool
    """(Required) Indicate if the Java user-defined function is an aggregate function"""
    @_builtins.property
    def output_type(self) -> _types_pb2.DataType:
        """(Optional) Output type of the Java UDF"""
    def __init__(
        self,
        *,
        class_name: _builtins.str = ...,
        output_type: _types_pb2.DataType | None = ...,
        aggregate: _builtins.bool = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal[
        "_output_type", b"_output_type", "output_type", b"output_type"
    ]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal[
        "_output_type",
        b"_output_type",
        "aggregate",
        b"aggregate",
        "class_name",
        b"class_name",
        "output_type",
        b"output_type",
    ]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__output_type: _TypeAlias = _typing.Literal["output_type"]  # noqa: Y015
    _WhichOneofArgType__output_type: _TypeAlias = _typing.Literal[
        "_output_type", b"_output_type"
    ]  # noqa: Y015
    def WhichOneof(
        self, oneof_group: _WhichOneofArgType__output_type
    ) -> _WhichOneofReturnType__output_type | None: ...

Global___JavaUDF: _TypeAlias = JavaUDF  # noqa: Y015

@_typing.final
class TypedAggregateExpression(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    SCALAR_SCALA_UDF_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def scalar_scala_udf(self) -> Global___ScalarScalaUDF:
        """(Required) The aggregate function object packed into bytes."""
    def __init__(
        self,
        *,
        scalar_scala_udf: Global___ScalarScalaUDF | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal[
        "scalar_scala_udf", b"scalar_scala_udf"
    ]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal[
        "scalar_scala_udf", b"scalar_scala_udf"
    ]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___TypedAggregateExpression: _TypeAlias = TypedAggregateExpression  # noqa: Y015

@_typing.final
class CallFunction(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    FUNCTION_NAME_FIELD_NUMBER: _builtins.int
    ARGUMENTS_FIELD_NUMBER: _builtins.int
    function_name: _builtins.str
    """(Required) Unparsed name of the SQL function."""
    @_builtins.property
    def arguments(self) -> _containers.RepeatedCompositeFieldContainer[Global___Expression]:
        """(Optional) Function arguments. Empty arguments are allowed."""
    def __init__(
        self,
        *,
        function_name: _builtins.str = ...,
        arguments: _abc.Iterable[Global___Expression] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal[
        "arguments", b"arguments", "function_name", b"function_name"
    ]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___CallFunction: _TypeAlias = CallFunction  # noqa: Y015

@_typing.final
class NamedArgumentExpression(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    KEY_FIELD_NUMBER: _builtins.int
    VALUE_FIELD_NUMBER: _builtins.int
    key: _builtins.str
    """(Required) The key of the named argument."""
    @_builtins.property
    def value(self) -> Global___Expression:
        """(Required) The value expression of the named argument."""
    def __init__(
        self,
        *,
        key: _builtins.str = ...,
        value: Global___Expression | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___NamedArgumentExpression: _TypeAlias = NamedArgumentExpression  # noqa: Y015

@_typing.final
class MergeAction(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    class _ActionType:
        ValueType = _typing.NewType("ValueType", _builtins.int)
        V: _TypeAlias = ValueType  # noqa: Y015

    class _ActionTypeEnumTypeWrapper(
        _enum_type_wrapper._EnumTypeWrapper[MergeAction._ActionType.ValueType], _builtins.type
    ):
        DESCRIPTOR: _descriptor.EnumDescriptor
        ACTION_TYPE_INVALID: MergeAction._ActionType.ValueType  # 0
        ACTION_TYPE_DELETE: MergeAction._ActionType.ValueType  # 1
        ACTION_TYPE_INSERT: MergeAction._ActionType.ValueType  # 2
        ACTION_TYPE_INSERT_STAR: MergeAction._ActionType.ValueType  # 3
        ACTION_TYPE_UPDATE: MergeAction._ActionType.ValueType  # 4
        ACTION_TYPE_UPDATE_STAR: MergeAction._ActionType.ValueType  # 5

    class ActionType(_ActionType, metaclass=_ActionTypeEnumTypeWrapper): ...
    ACTION_TYPE_INVALID: MergeAction.ActionType.ValueType  # 0
    ACTION_TYPE_DELETE: MergeAction.ActionType.ValueType  # 1
    ACTION_TYPE_INSERT: MergeAction.ActionType.ValueType  # 2
    ACTION_TYPE_INSERT_STAR: MergeAction.ActionType.ValueType  # 3
    ACTION_TYPE_UPDATE: MergeAction.ActionType.ValueType  # 4
    ACTION_TYPE_UPDATE_STAR: MergeAction.ActionType.ValueType  # 5

    @_typing.final
    class Assignment(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        @_builtins.property
        def key(self) -> Global___Expression:
            """(Required) The key of the assignment."""
        @_builtins.property
        def value(self) -> Global___Expression:
            """(Required) The value of the assignment."""
        def __init__(
            self,
            *,
            key: Global___Expression | None = ...,
            value: Global___Expression | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "key", b"key", "value", b"value"
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "key", b"key", "value", b"value"
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    ACTION_TYPE_FIELD_NUMBER: _builtins.int
    CONDITION_FIELD_NUMBER: _builtins.int
    ASSIGNMENTS_FIELD_NUMBER: _builtins.int
    action_type: Global___MergeAction.ActionType.ValueType
    """(Required) The action type of the merge action."""
    @_builtins.property
    def condition(self) -> Global___Expression:
        """(Optional) The condition expression of the merge action."""
    @_builtins.property
    def assignments(
        self,
    ) -> _containers.RepeatedCompositeFieldContainer[Global___MergeAction.Assignment]:
        """(Optional) The assignments of the merge action. Required for ActionTypes INSERT and UPDATE."""
    def __init__(
        self,
        *,
        action_type: Global___MergeAction.ActionType.ValueType = ...,
        condition: Global___Expression | None = ...,
        assignments: _abc.Iterable[Global___MergeAction.Assignment] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal[
        "_condition", b"_condition", "condition", b"condition"
    ]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal[
        "_condition",
        b"_condition",
        "action_type",
        b"action_type",
        "assignments",
        b"assignments",
        "condition",
        b"condition",
    ]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__condition: _TypeAlias = _typing.Literal["condition"]  # noqa: Y015
    _WhichOneofArgType__condition: _TypeAlias = _typing.Literal[
        "_condition", b"_condition"
    ]  # noqa: Y015
    def WhichOneof(
        self, oneof_group: _WhichOneofArgType__condition
    ) -> _WhichOneofReturnType__condition | None: ...

Global___MergeAction: _TypeAlias = MergeAction  # noqa: Y015

@_typing.final
class SubqueryExpression(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    class _SubqueryType:
        ValueType = _typing.NewType("ValueType", _builtins.int)
        V: _TypeAlias = ValueType  # noqa: Y015

    class _SubqueryTypeEnumTypeWrapper(
        _enum_type_wrapper._EnumTypeWrapper[SubqueryExpression._SubqueryType.ValueType],
        _builtins.type,
    ):
        DESCRIPTOR: _descriptor.EnumDescriptor
        SUBQUERY_TYPE_UNKNOWN: SubqueryExpression._SubqueryType.ValueType  # 0
        SUBQUERY_TYPE_SCALAR: SubqueryExpression._SubqueryType.ValueType  # 1
        SUBQUERY_TYPE_EXISTS: SubqueryExpression._SubqueryType.ValueType  # 2
        SUBQUERY_TYPE_TABLE_ARG: SubqueryExpression._SubqueryType.ValueType  # 3
        SUBQUERY_TYPE_IN: SubqueryExpression._SubqueryType.ValueType  # 4

    class SubqueryType(_SubqueryType, metaclass=_SubqueryTypeEnumTypeWrapper): ...
    SUBQUERY_TYPE_UNKNOWN: SubqueryExpression.SubqueryType.ValueType  # 0
    SUBQUERY_TYPE_SCALAR: SubqueryExpression.SubqueryType.ValueType  # 1
    SUBQUERY_TYPE_EXISTS: SubqueryExpression.SubqueryType.ValueType  # 2
    SUBQUERY_TYPE_TABLE_ARG: SubqueryExpression.SubqueryType.ValueType  # 3
    SUBQUERY_TYPE_IN: SubqueryExpression.SubqueryType.ValueType  # 4

    @_typing.final
    class TableArgOptions(_message.Message):
        """Nested message for table argument options."""

        DESCRIPTOR: _descriptor.Descriptor

        PARTITION_SPEC_FIELD_NUMBER: _builtins.int
        ORDER_SPEC_FIELD_NUMBER: _builtins.int
        WITH_SINGLE_PARTITION_FIELD_NUMBER: _builtins.int
        with_single_partition: _builtins.bool
        """(Optional) Whether this is a single partition."""
        @_builtins.property
        def partition_spec(
            self,
        ) -> _containers.RepeatedCompositeFieldContainer[Global___Expression]:
            """(Optional) The way that input rows are partitioned."""
        @_builtins.property
        def order_spec(
            self,
        ) -> _containers.RepeatedCompositeFieldContainer[Global___Expression.SortOrder]:
            """(Optional) Ordering of rows in a partition."""
        def __init__(
            self,
            *,
            partition_spec: _abc.Iterable[Global___Expression] | None = ...,
            order_spec: _abc.Iterable[Global___Expression.SortOrder] | None = ...,
            with_single_partition: _builtins.bool | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_with_single_partition",
            b"_with_single_partition",
            "with_single_partition",
            b"with_single_partition",
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_with_single_partition",
            b"_with_single_partition",
            "order_spec",
            b"order_spec",
            "partition_spec",
            b"partition_spec",
            "with_single_partition",
            b"with_single_partition",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__with_single_partition: _TypeAlias = _typing.Literal[
            "with_single_partition"
        ]  # noqa: Y015
        _WhichOneofArgType__with_single_partition: _TypeAlias = _typing.Literal[
            "_with_single_partition", b"_with_single_partition"
        ]  # noqa: Y015
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__with_single_partition
        ) -> _WhichOneofReturnType__with_single_partition | None: ...

    PLAN_ID_FIELD_NUMBER: _builtins.int
    SUBQUERY_TYPE_FIELD_NUMBER: _builtins.int
    TABLE_ARG_OPTIONS_FIELD_NUMBER: _builtins.int
    IN_SUBQUERY_VALUES_FIELD_NUMBER: _builtins.int
    plan_id: _builtins.int
    """(Required) The ID of the corresponding connect plan."""
    subquery_type: Global___SubqueryExpression.SubqueryType.ValueType
    """(Required) The type of the subquery."""
    @_builtins.property
    def table_arg_options(self) -> Global___SubqueryExpression.TableArgOptions:
        """(Optional) Options specific to table arguments."""
    @_builtins.property
    def in_subquery_values(
        self,
    ) -> _containers.RepeatedCompositeFieldContainer[Global___Expression]:
        """(Optional) IN subquery values."""
    def __init__(
        self,
        *,
        plan_id: _builtins.int = ...,
        subquery_type: Global___SubqueryExpression.SubqueryType.ValueType = ...,
        table_arg_options: Global___SubqueryExpression.TableArgOptions | None = ...,
        in_subquery_values: _abc.Iterable[Global___Expression] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal[
        "_table_arg_options", b"_table_arg_options", "table_arg_options", b"table_arg_options"
    ]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal[
        "_table_arg_options",
        b"_table_arg_options",
        "in_subquery_values",
        b"in_subquery_values",
        "plan_id",
        b"plan_id",
        "subquery_type",
        b"subquery_type",
        "table_arg_options",
        b"table_arg_options",
    ]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__table_arg_options: _TypeAlias = _typing.Literal[
        "table_arg_options"
    ]  # noqa: Y015
    _WhichOneofArgType__table_arg_options: _TypeAlias = _typing.Literal[
        "_table_arg_options", b"_table_arg_options"
    ]  # noqa: Y015
    def WhichOneof(
        self, oneof_group: _WhichOneofArgType__table_arg_options
    ) -> _WhichOneofReturnType__table_arg_options | None: ...

Global___SubqueryExpression: _TypeAlias = SubqueryExpression  # noqa: Y015
