#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file

Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

from collections import abc as _abc
from google.protobuf import any_pb2 as _any_pb2
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import timestamp_pb2 as _timestamp_pb2
from google.protobuf.internal import containers as _containers
from google.protobuf.internal import enum_type_wrapper as _enum_type_wrapper
from pyspark.sql.connect.proto import common_pb2 as _common_pb2
from pyspark.sql.connect.proto import relations_pb2 as _relations_pb2
from pyspark.sql.connect.proto import types_pb2 as _types_pb2
import builtins as _builtins
import sys
import typing as _typing

if sys.version_info >= (3, 10):
    from typing import TypeAlias as _TypeAlias
else:
    from typing_extensions import TypeAlias as _TypeAlias

DESCRIPTOR: _descriptor.FileDescriptor

class _OutputType:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _OutputTypeEnumTypeWrapper(
    _enum_type_wrapper._EnumTypeWrapper[_OutputType.ValueType], _builtins.type
):
    DESCRIPTOR: _descriptor.EnumDescriptor
    OUTPUT_TYPE_UNSPECIFIED: _OutputType.ValueType  # 0
    """Safe default value. Should not be used."""
    MATERIALIZED_VIEW: _OutputType.ValueType  # 1
    """A materialized view which is published to the catalog"""
    TABLE: _OutputType.ValueType  # 2
    """A table which is published to the catalog"""
    TEMPORARY_VIEW: _OutputType.ValueType  # 3
    """A view which is not published to the catalog"""
    SINK: _OutputType.ValueType  # 4
    """A sink which is not published to the catalog"""

class OutputType(_OutputType, metaclass=_OutputTypeEnumTypeWrapper):
    """The type of output."""

OUTPUT_TYPE_UNSPECIFIED: OutputType.ValueType  # 0
"""Safe default value. Should not be used."""
MATERIALIZED_VIEW: OutputType.ValueType  # 1
"""A materialized view which is published to the catalog"""
TABLE: OutputType.ValueType  # 2
"""A table which is published to the catalog"""
TEMPORARY_VIEW: OutputType.ValueType  # 3
"""A view which is not published to the catalog"""
SINK: OutputType.ValueType  # 4
"""A sink which is not published to the catalog"""
Global___OutputType: _TypeAlias = OutputType  # noqa: Y015

@_typing.final
class PipelineCommand(_message.Message):
    """Dispatch object for pipelines commands. See each individual command for documentation."""

    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class CreateDataflowGraph(_message.Message):
        """Request to create a new dataflow graph."""

        DESCRIPTOR: _descriptor.Descriptor

        @_typing.final
        class SqlConfEntry(_message.Message):
            DESCRIPTOR: _descriptor.Descriptor

            KEY_FIELD_NUMBER: _builtins.int
            VALUE_FIELD_NUMBER: _builtins.int
            key: _builtins.str
            value: _builtins.str
            def __init__(
                self,
                *,
                key: _builtins.str = ...,
                value: _builtins.str = ...,
            ) -> None: ...
            _ClearFieldArgType: _TypeAlias = _typing.Literal[
                "key", b"key", "value", b"value"
            ]  # noqa: Y015
            def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

        DEFAULT_CATALOG_FIELD_NUMBER: _builtins.int
        DEFAULT_DATABASE_FIELD_NUMBER: _builtins.int
        SQL_CONF_FIELD_NUMBER: _builtins.int
        default_catalog: _builtins.str
        """The default catalog."""
        default_database: _builtins.str
        """The default database."""
        @_builtins.property
        def sql_conf(self) -> _containers.ScalarMap[_builtins.str, _builtins.str]:
            """SQL configurations for all flows in this graph."""
        def __init__(
            self,
            *,
            default_catalog: _builtins.str | None = ...,
            default_database: _builtins.str | None = ...,
            sql_conf: _abc.Mapping[_builtins.str, _builtins.str] | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_default_catalog",
            b"_default_catalog",
            "_default_database",
            b"_default_database",
            "default_catalog",
            b"default_catalog",
            "default_database",
            b"default_database",
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_default_catalog",
            b"_default_catalog",
            "_default_database",
            b"_default_database",
            "default_catalog",
            b"default_catalog",
            "default_database",
            b"default_database",
            "sql_conf",
            b"sql_conf",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__default_catalog: _TypeAlias = _typing.Literal[
            "default_catalog"
        ]  # noqa: Y015
        _WhichOneofArgType__default_catalog: _TypeAlias = _typing.Literal[
            "_default_catalog", b"_default_catalog"
        ]  # noqa: Y015
        _WhichOneofReturnType__default_database: _TypeAlias = _typing.Literal[
            "default_database"
        ]  # noqa: Y015
        _WhichOneofArgType__default_database: _TypeAlias = _typing.Literal[
            "_default_database", b"_default_database"
        ]  # noqa: Y015
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__default_catalog
        ) -> _WhichOneofReturnType__default_catalog | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__default_database
        ) -> _WhichOneofReturnType__default_database | None: ...

    @_typing.final
    class DropDataflowGraph(_message.Message):
        """Drops the graph and stops any running attached flows."""

        DESCRIPTOR: _descriptor.Descriptor

        DATAFLOW_GRAPH_ID_FIELD_NUMBER: _builtins.int
        dataflow_graph_id: _builtins.str
        """The graph to drop."""
        def __init__(
            self,
            *,
            dataflow_graph_id: _builtins.str | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id", b"_dataflow_graph_id", "dataflow_graph_id", b"dataflow_graph_id"
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id", b"_dataflow_graph_id", "dataflow_graph_id", b"dataflow_graph_id"
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "dataflow_graph_id"
        ]  # noqa: Y015
        _WhichOneofArgType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id", b"_dataflow_graph_id"
        ]  # noqa: Y015
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__dataflow_graph_id
        ) -> _WhichOneofReturnType__dataflow_graph_id | None: ...

    @_typing.final
    class DefineOutput(_message.Message):
        """Request to define an output: a table, a materialized view, a temporary view or a sink."""

        DESCRIPTOR: _descriptor.Descriptor

        @_typing.final
        class TableDetails(_message.Message):
            """Metadata that's only applicable to tables and materialized views."""

            DESCRIPTOR: _descriptor.Descriptor

            @_typing.final
            class TablePropertiesEntry(_message.Message):
                DESCRIPTOR: _descriptor.Descriptor

                KEY_FIELD_NUMBER: _builtins.int
                VALUE_FIELD_NUMBER: _builtins.int
                key: _builtins.str
                value: _builtins.str
                def __init__(
                    self,
                    *,
                    key: _builtins.str = ...,
                    value: _builtins.str = ...,
                ) -> None: ...
                _ClearFieldArgType: _TypeAlias = _typing.Literal[
                    "key", b"key", "value", b"value"
                ]  # noqa: Y015
                def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

            TABLE_PROPERTIES_FIELD_NUMBER: _builtins.int
            PARTITION_COLS_FIELD_NUMBER: _builtins.int
            FORMAT_FIELD_NUMBER: _builtins.int
            SCHEMA_DATA_TYPE_FIELD_NUMBER: _builtins.int
            SCHEMA_STRING_FIELD_NUMBER: _builtins.int
            CLUSTERING_COLUMNS_FIELD_NUMBER: _builtins.int
            format: _builtins.str
            """The output table format for the table."""
            schema_string: _builtins.str
            @_builtins.property
            def table_properties(self) -> _containers.ScalarMap[_builtins.str, _builtins.str]:
                """Optional table properties."""
            @_builtins.property
            def partition_cols(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]:
                """Optional partition columns for the table."""
            @_builtins.property
            def schema_data_type(self) -> _types_pb2.DataType: ...
            @_builtins.property
            def clustering_columns(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]:
                """Optional cluster columns for the table."""
            def __init__(
                self,
                *,
                table_properties: _abc.Mapping[_builtins.str, _builtins.str] | None = ...,
                partition_cols: _abc.Iterable[_builtins.str] | None = ...,
                format: _builtins.str | None = ...,
                schema_data_type: _types_pb2.DataType | None = ...,
                schema_string: _builtins.str = ...,
                clustering_columns: _abc.Iterable[_builtins.str] | None = ...,
            ) -> None: ...
            _HasFieldArgType: _TypeAlias = _typing.Literal[
                "_format",
                b"_format",
                "format",
                b"format",
                "schema",
                b"schema",
                "schema_data_type",
                b"schema_data_type",
                "schema_string",
                b"schema_string",
            ]  # noqa: Y015
            def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
            _ClearFieldArgType: _TypeAlias = _typing.Literal[
                "_format",
                b"_format",
                "clustering_columns",
                b"clustering_columns",
                "format",
                b"format",
                "partition_cols",
                b"partition_cols",
                "schema",
                b"schema",
                "schema_data_type",
                b"schema_data_type",
                "schema_string",
                b"schema_string",
                "table_properties",
                b"table_properties",
            ]  # noqa: Y015
            def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
            _WhichOneofReturnType__format: _TypeAlias = _typing.Literal["format"]  # noqa: Y015
            _WhichOneofArgType__format: _TypeAlias = _typing.Literal[
                "_format", b"_format"
            ]  # noqa: Y015
            _WhichOneofReturnType_schema: _TypeAlias = _typing.Literal[
                "schema_data_type", "schema_string"
            ]  # noqa: Y015
            _WhichOneofArgType_schema: _TypeAlias = _typing.Literal[
                "schema", b"schema"
            ]  # noqa: Y015
            @_typing.overload
            def WhichOneof(
                self, oneof_group: _WhichOneofArgType__format
            ) -> _WhichOneofReturnType__format | None: ...
            @_typing.overload
            def WhichOneof(
                self, oneof_group: _WhichOneofArgType_schema
            ) -> _WhichOneofReturnType_schema | None: ...

        @_typing.final
        class SinkDetails(_message.Message):
            """Metadata that's only applicable to sinks."""

            DESCRIPTOR: _descriptor.Descriptor

            @_typing.final
            class OptionsEntry(_message.Message):
                DESCRIPTOR: _descriptor.Descriptor

                KEY_FIELD_NUMBER: _builtins.int
                VALUE_FIELD_NUMBER: _builtins.int
                key: _builtins.str
                value: _builtins.str
                def __init__(
                    self,
                    *,
                    key: _builtins.str = ...,
                    value: _builtins.str = ...,
                ) -> None: ...
                _ClearFieldArgType: _TypeAlias = _typing.Literal[
                    "key", b"key", "value", b"value"
                ]  # noqa: Y015
                def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

            OPTIONS_FIELD_NUMBER: _builtins.int
            FORMAT_FIELD_NUMBER: _builtins.int
            format: _builtins.str
            """Streaming write format"""
            @_builtins.property
            def options(self) -> _containers.ScalarMap[_builtins.str, _builtins.str]:
                """Streaming write options"""
            def __init__(
                self,
                *,
                options: _abc.Mapping[_builtins.str, _builtins.str] | None = ...,
                format: _builtins.str | None = ...,
            ) -> None: ...
            _HasFieldArgType: _TypeAlias = _typing.Literal[
                "_format", b"_format", "format", b"format"
            ]  # noqa: Y015
            def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
            _ClearFieldArgType: _TypeAlias = _typing.Literal[
                "_format", b"_format", "format", b"format", "options", b"options"
            ]  # noqa: Y015
            def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
            _WhichOneofReturnType__format: _TypeAlias = _typing.Literal["format"]  # noqa: Y015
            _WhichOneofArgType__format: _TypeAlias = _typing.Literal[
                "_format", b"_format"
            ]  # noqa: Y015
            def WhichOneof(
                self, oneof_group: _WhichOneofArgType__format
            ) -> _WhichOneofReturnType__format | None: ...

        DATAFLOW_GRAPH_ID_FIELD_NUMBER: _builtins.int
        OUTPUT_NAME_FIELD_NUMBER: _builtins.int
        OUTPUT_TYPE_FIELD_NUMBER: _builtins.int
        COMMENT_FIELD_NUMBER: _builtins.int
        SOURCE_CODE_LOCATION_FIELD_NUMBER: _builtins.int
        TABLE_DETAILS_FIELD_NUMBER: _builtins.int
        SINK_DETAILS_FIELD_NUMBER: _builtins.int
        EXTENSION_FIELD_NUMBER: _builtins.int
        dataflow_graph_id: _builtins.str
        """The graph to attach this output to."""
        output_name: _builtins.str
        """Name of the output. Can be partially or fully qualified."""
        output_type: Global___OutputType.ValueType
        """The type of the output."""
        comment: _builtins.str
        """Optional comment for the output."""
        @_builtins.property
        def source_code_location(self) -> Global___SourceCodeLocation:
            """The location in source code that this output was defined."""
        @_builtins.property
        def table_details(self) -> Global___PipelineCommand.DefineOutput.TableDetails: ...
        @_builtins.property
        def sink_details(self) -> Global___PipelineCommand.DefineOutput.SinkDetails: ...
        @_builtins.property
        def extension(self) -> _any_pb2.Any: ...
        def __init__(
            self,
            *,
            dataflow_graph_id: _builtins.str | None = ...,
            output_name: _builtins.str | None = ...,
            output_type: Global___OutputType.ValueType | None = ...,
            comment: _builtins.str | None = ...,
            source_code_location: Global___SourceCodeLocation | None = ...,
            table_details: Global___PipelineCommand.DefineOutput.TableDetails | None = ...,
            sink_details: Global___PipelineCommand.DefineOutput.SinkDetails | None = ...,
            extension: _any_pb2.Any | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_comment",
            b"_comment",
            "_dataflow_graph_id",
            b"_dataflow_graph_id",
            "_output_name",
            b"_output_name",
            "_output_type",
            b"_output_type",
            "_source_code_location",
            b"_source_code_location",
            "comment",
            b"comment",
            "dataflow_graph_id",
            b"dataflow_graph_id",
            "details",
            b"details",
            "extension",
            b"extension",
            "output_name",
            b"output_name",
            "output_type",
            b"output_type",
            "sink_details",
            b"sink_details",
            "source_code_location",
            b"source_code_location",
            "table_details",
            b"table_details",
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_comment",
            b"_comment",
            "_dataflow_graph_id",
            b"_dataflow_graph_id",
            "_output_name",
            b"_output_name",
            "_output_type",
            b"_output_type",
            "_source_code_location",
            b"_source_code_location",
            "comment",
            b"comment",
            "dataflow_graph_id",
            b"dataflow_graph_id",
            "details",
            b"details",
            "extension",
            b"extension",
            "output_name",
            b"output_name",
            "output_type",
            b"output_type",
            "sink_details",
            b"sink_details",
            "source_code_location",
            b"source_code_location",
            "table_details",
            b"table_details",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__comment: _TypeAlias = _typing.Literal["comment"]  # noqa: Y015
        _WhichOneofArgType__comment: _TypeAlias = _typing.Literal[
            "_comment", b"_comment"
        ]  # noqa: Y015
        _WhichOneofReturnType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "dataflow_graph_id"
        ]  # noqa: Y015
        _WhichOneofArgType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id", b"_dataflow_graph_id"
        ]  # noqa: Y015
        _WhichOneofReturnType__output_name: _TypeAlias = _typing.Literal[
            "output_name"
        ]  # noqa: Y015
        _WhichOneofArgType__output_name: _TypeAlias = _typing.Literal[
            "_output_name", b"_output_name"
        ]  # noqa: Y015
        _WhichOneofReturnType__output_type: _TypeAlias = _typing.Literal[
            "output_type"
        ]  # noqa: Y015
        _WhichOneofArgType__output_type: _TypeAlias = _typing.Literal[
            "_output_type", b"_output_type"
        ]  # noqa: Y015
        _WhichOneofReturnType__source_code_location: _TypeAlias = _typing.Literal[
            "source_code_location"
        ]  # noqa: Y015
        _WhichOneofArgType__source_code_location: _TypeAlias = _typing.Literal[
            "_source_code_location", b"_source_code_location"
        ]  # noqa: Y015
        _WhichOneofReturnType_details: _TypeAlias = _typing.Literal[
            "table_details", "sink_details", "extension"
        ]  # noqa: Y015
        _WhichOneofArgType_details: _TypeAlias = _typing.Literal[
            "details", b"details"
        ]  # noqa: Y015
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__comment
        ) -> _WhichOneofReturnType__comment | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__dataflow_graph_id
        ) -> _WhichOneofReturnType__dataflow_graph_id | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__output_name
        ) -> _WhichOneofReturnType__output_name | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__output_type
        ) -> _WhichOneofReturnType__output_type | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__source_code_location
        ) -> _WhichOneofReturnType__source_code_location | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType_details
        ) -> _WhichOneofReturnType_details | None: ...

    @_typing.final
    class DefineFlow(_message.Message):
        """Request to define a flow targeting a dataset."""

        DESCRIPTOR: _descriptor.Descriptor

        @_typing.final
        class SqlConfEntry(_message.Message):
            DESCRIPTOR: _descriptor.Descriptor

            KEY_FIELD_NUMBER: _builtins.int
            VALUE_FIELD_NUMBER: _builtins.int
            key: _builtins.str
            value: _builtins.str
            def __init__(
                self,
                *,
                key: _builtins.str = ...,
                value: _builtins.str = ...,
            ) -> None: ...
            _ClearFieldArgType: _TypeAlias = _typing.Literal[
                "key", b"key", "value", b"value"
            ]  # noqa: Y015
            def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

        @_typing.final
        class WriteRelationFlowDetails(_message.Message):
            """A flow that is that takes the contents of a relation and writes it to the target dataset."""

            DESCRIPTOR: _descriptor.Descriptor

            RELATION_FIELD_NUMBER: _builtins.int
            @_builtins.property
            def relation(self) -> _relations_pb2.Relation:
                """An unresolved relation that defines the dataset's flow. Empty if the query function
                that defines the flow cannot be analyzed at the time of flow definition.
                """
            def __init__(
                self,
                *,
                relation: _relations_pb2.Relation | None = ...,
            ) -> None: ...
            _HasFieldArgType: _TypeAlias = _typing.Literal[
                "_relation", b"_relation", "relation", b"relation"
            ]  # noqa: Y015
            def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
            _ClearFieldArgType: _TypeAlias = _typing.Literal[
                "_relation", b"_relation", "relation", b"relation"
            ]  # noqa: Y015
            def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
            _WhichOneofReturnType__relation: _TypeAlias = _typing.Literal["relation"]  # noqa: Y015
            _WhichOneofArgType__relation: _TypeAlias = _typing.Literal[
                "_relation", b"_relation"
            ]  # noqa: Y015
            def WhichOneof(
                self, oneof_group: _WhichOneofArgType__relation
            ) -> _WhichOneofReturnType__relation | None: ...

        @_typing.final
        class Response(_message.Message):
            DESCRIPTOR: _descriptor.Descriptor

            FLOW_NAME_FIELD_NUMBER: _builtins.int
            flow_name: _builtins.str
            """Fully qualified flow name that uniquely identify a flow in the Dataflow graph."""
            def __init__(
                self,
                *,
                flow_name: _builtins.str | None = ...,
            ) -> None: ...
            _HasFieldArgType: _TypeAlias = _typing.Literal[
                "_flow_name", b"_flow_name", "flow_name", b"flow_name"
            ]  # noqa: Y015
            def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
            _ClearFieldArgType: _TypeAlias = _typing.Literal[
                "_flow_name", b"_flow_name", "flow_name", b"flow_name"
            ]  # noqa: Y015
            def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
            _WhichOneofReturnType__flow_name: _TypeAlias = _typing.Literal[
                "flow_name"
            ]  # noqa: Y015
            _WhichOneofArgType__flow_name: _TypeAlias = _typing.Literal[
                "_flow_name", b"_flow_name"
            ]  # noqa: Y015
            def WhichOneof(
                self, oneof_group: _WhichOneofArgType__flow_name
            ) -> _WhichOneofReturnType__flow_name | None: ...

        DATAFLOW_GRAPH_ID_FIELD_NUMBER: _builtins.int
        FLOW_NAME_FIELD_NUMBER: _builtins.int
        TARGET_DATASET_NAME_FIELD_NUMBER: _builtins.int
        SQL_CONF_FIELD_NUMBER: _builtins.int
        CLIENT_ID_FIELD_NUMBER: _builtins.int
        SOURCE_CODE_LOCATION_FIELD_NUMBER: _builtins.int
        RELATION_FLOW_DETAILS_FIELD_NUMBER: _builtins.int
        EXTENSION_FIELD_NUMBER: _builtins.int
        ONCE_FIELD_NUMBER: _builtins.int
        dataflow_graph_id: _builtins.str
        """The graph to attach this flow to."""
        flow_name: _builtins.str
        """Name of the flow. For standalone flows, this must be a single-part name."""
        target_dataset_name: _builtins.str
        """Name of the dataset this flow writes to. Can be partially or fully qualified."""
        client_id: _builtins.str
        """Identifier for the client making the request. The server uses this to determine what flow
        evaluation request stream to dispatch evaluation requests to for this flow.
        """
        once: _builtins.bool
        """If true, define the flow as a one-time flow, such as for backfill.
        Set to true changes the flow in two ways:
          - The flow is run one time by default. If the pipeline is ran with a full refresh,
            the flow will run again.
          - The flow function must be a batch DataFrame, not a streaming DataFrame.
        """
        @_builtins.property
        def sql_conf(self) -> _containers.ScalarMap[_builtins.str, _builtins.str]:
            """SQL configurations set when running this flow."""
        @_builtins.property
        def source_code_location(self) -> Global___SourceCodeLocation:
            """The location in source code that this flow was defined."""
        @_builtins.property
        def relation_flow_details(
            self,
        ) -> Global___PipelineCommand.DefineFlow.WriteRelationFlowDetails: ...
        @_builtins.property
        def extension(self) -> _any_pb2.Any: ...
        def __init__(
            self,
            *,
            dataflow_graph_id: _builtins.str | None = ...,
            flow_name: _builtins.str | None = ...,
            target_dataset_name: _builtins.str | None = ...,
            sql_conf: _abc.Mapping[_builtins.str, _builtins.str] | None = ...,
            client_id: _builtins.str | None = ...,
            source_code_location: Global___SourceCodeLocation | None = ...,
            relation_flow_details: Global___PipelineCommand.DefineFlow.WriteRelationFlowDetails
            | None = ...,
            extension: _any_pb2.Any | None = ...,
            once: _builtins.bool | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_client_id",
            b"_client_id",
            "_dataflow_graph_id",
            b"_dataflow_graph_id",
            "_flow_name",
            b"_flow_name",
            "_once",
            b"_once",
            "_source_code_location",
            b"_source_code_location",
            "_target_dataset_name",
            b"_target_dataset_name",
            "client_id",
            b"client_id",
            "dataflow_graph_id",
            b"dataflow_graph_id",
            "details",
            b"details",
            "extension",
            b"extension",
            "flow_name",
            b"flow_name",
            "once",
            b"once",
            "relation_flow_details",
            b"relation_flow_details",
            "source_code_location",
            b"source_code_location",
            "target_dataset_name",
            b"target_dataset_name",
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_client_id",
            b"_client_id",
            "_dataflow_graph_id",
            b"_dataflow_graph_id",
            "_flow_name",
            b"_flow_name",
            "_once",
            b"_once",
            "_source_code_location",
            b"_source_code_location",
            "_target_dataset_name",
            b"_target_dataset_name",
            "client_id",
            b"client_id",
            "dataflow_graph_id",
            b"dataflow_graph_id",
            "details",
            b"details",
            "extension",
            b"extension",
            "flow_name",
            b"flow_name",
            "once",
            b"once",
            "relation_flow_details",
            b"relation_flow_details",
            "source_code_location",
            b"source_code_location",
            "sql_conf",
            b"sql_conf",
            "target_dataset_name",
            b"target_dataset_name",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__client_id: _TypeAlias = _typing.Literal["client_id"]  # noqa: Y015
        _WhichOneofArgType__client_id: _TypeAlias = _typing.Literal[
            "_client_id", b"_client_id"
        ]  # noqa: Y015
        _WhichOneofReturnType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "dataflow_graph_id"
        ]  # noqa: Y015
        _WhichOneofArgType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id", b"_dataflow_graph_id"
        ]  # noqa: Y015
        _WhichOneofReturnType__flow_name: _TypeAlias = _typing.Literal["flow_name"]  # noqa: Y015
        _WhichOneofArgType__flow_name: _TypeAlias = _typing.Literal[
            "_flow_name", b"_flow_name"
        ]  # noqa: Y015
        _WhichOneofReturnType__once: _TypeAlias = _typing.Literal["once"]  # noqa: Y015
        _WhichOneofArgType__once: _TypeAlias = _typing.Literal["_once", b"_once"]  # noqa: Y015
        _WhichOneofReturnType__source_code_location: _TypeAlias = _typing.Literal[
            "source_code_location"
        ]  # noqa: Y015
        _WhichOneofArgType__source_code_location: _TypeAlias = _typing.Literal[
            "_source_code_location", b"_source_code_location"
        ]  # noqa: Y015
        _WhichOneofReturnType__target_dataset_name: _TypeAlias = _typing.Literal[
            "target_dataset_name"
        ]  # noqa: Y015
        _WhichOneofArgType__target_dataset_name: _TypeAlias = _typing.Literal[
            "_target_dataset_name", b"_target_dataset_name"
        ]  # noqa: Y015
        _WhichOneofReturnType_details: _TypeAlias = _typing.Literal[
            "relation_flow_details", "extension"
        ]  # noqa: Y015
        _WhichOneofArgType_details: _TypeAlias = _typing.Literal[
            "details", b"details"
        ]  # noqa: Y015
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__client_id
        ) -> _WhichOneofReturnType__client_id | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__dataflow_graph_id
        ) -> _WhichOneofReturnType__dataflow_graph_id | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__flow_name
        ) -> _WhichOneofReturnType__flow_name | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__once
        ) -> _WhichOneofReturnType__once | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__source_code_location
        ) -> _WhichOneofReturnType__source_code_location | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__target_dataset_name
        ) -> _WhichOneofReturnType__target_dataset_name | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType_details
        ) -> _WhichOneofReturnType_details | None: ...

    @_typing.final
    class StartRun(_message.Message):
        """Resolves all datasets and flows and start a pipeline update. Should be called after all
        graph elements are registered.
        """

        DESCRIPTOR: _descriptor.Descriptor

        DATAFLOW_GRAPH_ID_FIELD_NUMBER: _builtins.int
        FULL_REFRESH_SELECTION_FIELD_NUMBER: _builtins.int
        FULL_REFRESH_ALL_FIELD_NUMBER: _builtins.int
        REFRESH_SELECTION_FIELD_NUMBER: _builtins.int
        DRY_FIELD_NUMBER: _builtins.int
        STORAGE_FIELD_NUMBER: _builtins.int
        dataflow_graph_id: _builtins.str
        """The graph to start."""
        full_refresh_all: _builtins.bool
        """Perform a full graph reset and recompute."""
        dry: _builtins.bool
        """If true, the run will not actually execute any flows, but will only validate the graph and
        check for any errors. This is useful for testing and validation purposes.
        """
        storage: _builtins.str
        """storage location for pipeline checkpoints and metadata."""
        @_builtins.property
        def full_refresh_selection(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]:
            """List of dataset to reset and recompute."""
        @_builtins.property
        def refresh_selection(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]:
            """List of dataset to update."""
        def __init__(
            self,
            *,
            dataflow_graph_id: _builtins.str | None = ...,
            full_refresh_selection: _abc.Iterable[_builtins.str] | None = ...,
            full_refresh_all: _builtins.bool | None = ...,
            refresh_selection: _abc.Iterable[_builtins.str] | None = ...,
            dry: _builtins.bool | None = ...,
            storage: _builtins.str | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id",
            b"_dataflow_graph_id",
            "_dry",
            b"_dry",
            "_full_refresh_all",
            b"_full_refresh_all",
            "_storage",
            b"_storage",
            "dataflow_graph_id",
            b"dataflow_graph_id",
            "dry",
            b"dry",
            "full_refresh_all",
            b"full_refresh_all",
            "storage",
            b"storage",
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id",
            b"_dataflow_graph_id",
            "_dry",
            b"_dry",
            "_full_refresh_all",
            b"_full_refresh_all",
            "_storage",
            b"_storage",
            "dataflow_graph_id",
            b"dataflow_graph_id",
            "dry",
            b"dry",
            "full_refresh_all",
            b"full_refresh_all",
            "full_refresh_selection",
            b"full_refresh_selection",
            "refresh_selection",
            b"refresh_selection",
            "storage",
            b"storage",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "dataflow_graph_id"
        ]  # noqa: Y015
        _WhichOneofArgType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id", b"_dataflow_graph_id"
        ]  # noqa: Y015
        _WhichOneofReturnType__dry: _TypeAlias = _typing.Literal["dry"]  # noqa: Y015
        _WhichOneofArgType__dry: _TypeAlias = _typing.Literal["_dry", b"_dry"]  # noqa: Y015
        _WhichOneofReturnType__full_refresh_all: _TypeAlias = _typing.Literal[
            "full_refresh_all"
        ]  # noqa: Y015
        _WhichOneofArgType__full_refresh_all: _TypeAlias = _typing.Literal[
            "_full_refresh_all", b"_full_refresh_all"
        ]  # noqa: Y015
        _WhichOneofReturnType__storage: _TypeAlias = _typing.Literal["storage"]  # noqa: Y015
        _WhichOneofArgType__storage: _TypeAlias = _typing.Literal[
            "_storage", b"_storage"
        ]  # noqa: Y015
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__dataflow_graph_id
        ) -> _WhichOneofReturnType__dataflow_graph_id | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__dry
        ) -> _WhichOneofReturnType__dry | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__full_refresh_all
        ) -> _WhichOneofReturnType__full_refresh_all | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__storage
        ) -> _WhichOneofReturnType__storage | None: ...

    @_typing.final
    class DefineSqlGraphElements(_message.Message):
        """Parses the SQL file and registers all datasets and flows."""

        DESCRIPTOR: _descriptor.Descriptor

        DATAFLOW_GRAPH_ID_FIELD_NUMBER: _builtins.int
        SQL_FILE_PATH_FIELD_NUMBER: _builtins.int
        SQL_TEXT_FIELD_NUMBER: _builtins.int
        dataflow_graph_id: _builtins.str
        """The graph to attach this dataset to."""
        sql_file_path: _builtins.str
        """The full path to the SQL file. Can be relative or absolute."""
        sql_text: _builtins.str
        """The contents of the SQL file."""
        def __init__(
            self,
            *,
            dataflow_graph_id: _builtins.str | None = ...,
            sql_file_path: _builtins.str | None = ...,
            sql_text: _builtins.str | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id",
            b"_dataflow_graph_id",
            "_sql_file_path",
            b"_sql_file_path",
            "_sql_text",
            b"_sql_text",
            "dataflow_graph_id",
            b"dataflow_graph_id",
            "sql_file_path",
            b"sql_file_path",
            "sql_text",
            b"sql_text",
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id",
            b"_dataflow_graph_id",
            "_sql_file_path",
            b"_sql_file_path",
            "_sql_text",
            b"_sql_text",
            "dataflow_graph_id",
            b"dataflow_graph_id",
            "sql_file_path",
            b"sql_file_path",
            "sql_text",
            b"sql_text",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "dataflow_graph_id"
        ]  # noqa: Y015
        _WhichOneofArgType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id", b"_dataflow_graph_id"
        ]  # noqa: Y015
        _WhichOneofReturnType__sql_file_path: _TypeAlias = _typing.Literal[
            "sql_file_path"
        ]  # noqa: Y015
        _WhichOneofArgType__sql_file_path: _TypeAlias = _typing.Literal[
            "_sql_file_path", b"_sql_file_path"
        ]  # noqa: Y015
        _WhichOneofReturnType__sql_text: _TypeAlias = _typing.Literal["sql_text"]  # noqa: Y015
        _WhichOneofArgType__sql_text: _TypeAlias = _typing.Literal[
            "_sql_text", b"_sql_text"
        ]  # noqa: Y015
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__dataflow_graph_id
        ) -> _WhichOneofReturnType__dataflow_graph_id | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__sql_file_path
        ) -> _WhichOneofReturnType__sql_file_path | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__sql_text
        ) -> _WhichOneofReturnType__sql_text | None: ...

    @_typing.final
    class GetQueryFunctionExecutionSignalStream(_message.Message):
        """Request to get the stream of query function execution signals for a graph. Responses should
        be a stream of PipelineQueryFunctionExecutionSignal messages.
        """

        DESCRIPTOR: _descriptor.Descriptor

        DATAFLOW_GRAPH_ID_FIELD_NUMBER: _builtins.int
        CLIENT_ID_FIELD_NUMBER: _builtins.int
        dataflow_graph_id: _builtins.str
        """The graph to get the query function execution signal stream for."""
        client_id: _builtins.str
        """Identifier for the client that is requesting the stream."""
        def __init__(
            self,
            *,
            dataflow_graph_id: _builtins.str | None = ...,
            client_id: _builtins.str | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_client_id",
            b"_client_id",
            "_dataflow_graph_id",
            b"_dataflow_graph_id",
            "client_id",
            b"client_id",
            "dataflow_graph_id",
            b"dataflow_graph_id",
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_client_id",
            b"_client_id",
            "_dataflow_graph_id",
            b"_dataflow_graph_id",
            "client_id",
            b"client_id",
            "dataflow_graph_id",
            b"dataflow_graph_id",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__client_id: _TypeAlias = _typing.Literal["client_id"]  # noqa: Y015
        _WhichOneofArgType__client_id: _TypeAlias = _typing.Literal[
            "_client_id", b"_client_id"
        ]  # noqa: Y015
        _WhichOneofReturnType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "dataflow_graph_id"
        ]  # noqa: Y015
        _WhichOneofArgType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id", b"_dataflow_graph_id"
        ]  # noqa: Y015
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__client_id
        ) -> _WhichOneofReturnType__client_id | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__dataflow_graph_id
        ) -> _WhichOneofReturnType__dataflow_graph_id | None: ...

    @_typing.final
    class DefineFlowQueryFunctionResult(_message.Message):
        """Request from the client to update the flow function evaluation result
        for a previously un-analyzed flow.
        """

        DESCRIPTOR: _descriptor.Descriptor

        FLOW_NAME_FIELD_NUMBER: _builtins.int
        DATAFLOW_GRAPH_ID_FIELD_NUMBER: _builtins.int
        RELATION_FIELD_NUMBER: _builtins.int
        flow_name: _builtins.str
        """The fully qualified name of the flow being updated."""
        dataflow_graph_id: _builtins.str
        """The ID of the graph this flow belongs to."""
        @_builtins.property
        def relation(self) -> _relations_pb2.Relation:
            """An unresolved relation that defines the dataset's flow."""
        def __init__(
            self,
            *,
            flow_name: _builtins.str | None = ...,
            dataflow_graph_id: _builtins.str | None = ...,
            relation: _relations_pb2.Relation | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id",
            b"_dataflow_graph_id",
            "_flow_name",
            b"_flow_name",
            "_relation",
            b"_relation",
            "dataflow_graph_id",
            b"dataflow_graph_id",
            "flow_name",
            b"flow_name",
            "relation",
            b"relation",
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id",
            b"_dataflow_graph_id",
            "_flow_name",
            b"_flow_name",
            "_relation",
            b"_relation",
            "dataflow_graph_id",
            b"dataflow_graph_id",
            "flow_name",
            b"flow_name",
            "relation",
            b"relation",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "dataflow_graph_id"
        ]  # noqa: Y015
        _WhichOneofArgType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id", b"_dataflow_graph_id"
        ]  # noqa: Y015
        _WhichOneofReturnType__flow_name: _TypeAlias = _typing.Literal["flow_name"]  # noqa: Y015
        _WhichOneofArgType__flow_name: _TypeAlias = _typing.Literal[
            "_flow_name", b"_flow_name"
        ]  # noqa: Y015
        _WhichOneofReturnType__relation: _TypeAlias = _typing.Literal["relation"]  # noqa: Y015
        _WhichOneofArgType__relation: _TypeAlias = _typing.Literal[
            "_relation", b"_relation"
        ]  # noqa: Y015
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__dataflow_graph_id
        ) -> _WhichOneofReturnType__dataflow_graph_id | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__flow_name
        ) -> _WhichOneofReturnType__flow_name | None: ...
        @_typing.overload
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__relation
        ) -> _WhichOneofReturnType__relation | None: ...

    CREATE_DATAFLOW_GRAPH_FIELD_NUMBER: _builtins.int
    DEFINE_OUTPUT_FIELD_NUMBER: _builtins.int
    DEFINE_FLOW_FIELD_NUMBER: _builtins.int
    DROP_DATAFLOW_GRAPH_FIELD_NUMBER: _builtins.int
    START_RUN_FIELD_NUMBER: _builtins.int
    DEFINE_SQL_GRAPH_ELEMENTS_FIELD_NUMBER: _builtins.int
    GET_QUERY_FUNCTION_EXECUTION_SIGNAL_STREAM_FIELD_NUMBER: _builtins.int
    DEFINE_FLOW_QUERY_FUNCTION_RESULT_FIELD_NUMBER: _builtins.int
    EXTENSION_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def create_dataflow_graph(self) -> Global___PipelineCommand.CreateDataflowGraph: ...
    @_builtins.property
    def define_output(self) -> Global___PipelineCommand.DefineOutput: ...
    @_builtins.property
    def define_flow(self) -> Global___PipelineCommand.DefineFlow: ...
    @_builtins.property
    def drop_dataflow_graph(self) -> Global___PipelineCommand.DropDataflowGraph: ...
    @_builtins.property
    def start_run(self) -> Global___PipelineCommand.StartRun: ...
    @_builtins.property
    def define_sql_graph_elements(self) -> Global___PipelineCommand.DefineSqlGraphElements: ...
    @_builtins.property
    def get_query_function_execution_signal_stream(
        self,
    ) -> Global___PipelineCommand.GetQueryFunctionExecutionSignalStream: ...
    @_builtins.property
    def define_flow_query_function_result(
        self,
    ) -> Global___PipelineCommand.DefineFlowQueryFunctionResult: ...
    @_builtins.property
    def extension(self) -> _any_pb2.Any:
        """Reserved field for protocol extensions.
        Used to support forward-compatibility by carrying additional command types
        that are not yet defined in this version of the proto. During planning, the
        engine will resolve and dispatch the concrete command contained in this field.
        """
    def __init__(
        self,
        *,
        create_dataflow_graph: Global___PipelineCommand.CreateDataflowGraph | None = ...,
        define_output: Global___PipelineCommand.DefineOutput | None = ...,
        define_flow: Global___PipelineCommand.DefineFlow | None = ...,
        drop_dataflow_graph: Global___PipelineCommand.DropDataflowGraph | None = ...,
        start_run: Global___PipelineCommand.StartRun | None = ...,
        define_sql_graph_elements: Global___PipelineCommand.DefineSqlGraphElements | None = ...,
        get_query_function_execution_signal_stream: Global___PipelineCommand.GetQueryFunctionExecutionSignalStream
        | None = ...,
        define_flow_query_function_result: Global___PipelineCommand.DefineFlowQueryFunctionResult
        | None = ...,
        extension: _any_pb2.Any | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal[
        "command_type",
        b"command_type",
        "create_dataflow_graph",
        b"create_dataflow_graph",
        "define_flow",
        b"define_flow",
        "define_flow_query_function_result",
        b"define_flow_query_function_result",
        "define_output",
        b"define_output",
        "define_sql_graph_elements",
        b"define_sql_graph_elements",
        "drop_dataflow_graph",
        b"drop_dataflow_graph",
        "extension",
        b"extension",
        "get_query_function_execution_signal_stream",
        b"get_query_function_execution_signal_stream",
        "start_run",
        b"start_run",
    ]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal[
        "command_type",
        b"command_type",
        "create_dataflow_graph",
        b"create_dataflow_graph",
        "define_flow",
        b"define_flow",
        "define_flow_query_function_result",
        b"define_flow_query_function_result",
        "define_output",
        b"define_output",
        "define_sql_graph_elements",
        b"define_sql_graph_elements",
        "drop_dataflow_graph",
        b"drop_dataflow_graph",
        "extension",
        b"extension",
        "get_query_function_execution_signal_stream",
        b"get_query_function_execution_signal_stream",
        "start_run",
        b"start_run",
    ]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_command_type: _TypeAlias = _typing.Literal[
        "create_dataflow_graph",
        "define_output",
        "define_flow",
        "drop_dataflow_graph",
        "start_run",
        "define_sql_graph_elements",
        "get_query_function_execution_signal_stream",
        "define_flow_query_function_result",
        "extension",
    ]  # noqa: Y015
    _WhichOneofArgType_command_type: _TypeAlias = _typing.Literal[
        "command_type", b"command_type"
    ]  # noqa: Y015
    def WhichOneof(
        self, oneof_group: _WhichOneofArgType_command_type
    ) -> _WhichOneofReturnType_command_type | None: ...

Global___PipelineCommand: _TypeAlias = PipelineCommand  # noqa: Y015

@_typing.final
class PipelineCommandResult(_message.Message):
    """Dispatch object for pipelines command results."""

    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class CreateDataflowGraphResult(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        DATAFLOW_GRAPH_ID_FIELD_NUMBER: _builtins.int
        dataflow_graph_id: _builtins.str
        """The ID of the created graph."""
        def __init__(
            self,
            *,
            dataflow_graph_id: _builtins.str | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id", b"_dataflow_graph_id", "dataflow_graph_id", b"dataflow_graph_id"
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id", b"_dataflow_graph_id", "dataflow_graph_id", b"dataflow_graph_id"
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "dataflow_graph_id"
        ]  # noqa: Y015
        _WhichOneofArgType__dataflow_graph_id: _TypeAlias = _typing.Literal[
            "_dataflow_graph_id", b"_dataflow_graph_id"
        ]  # noqa: Y015
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__dataflow_graph_id
        ) -> _WhichOneofReturnType__dataflow_graph_id | None: ...

    @_typing.final
    class DefineOutputResult(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        RESOLVED_IDENTIFIER_FIELD_NUMBER: _builtins.int
        @_builtins.property
        def resolved_identifier(self) -> _common_pb2.ResolvedIdentifier:
            """Resolved identifier of the output"""
        def __init__(
            self,
            *,
            resolved_identifier: _common_pb2.ResolvedIdentifier | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_resolved_identifier",
            b"_resolved_identifier",
            "resolved_identifier",
            b"resolved_identifier",
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_resolved_identifier",
            b"_resolved_identifier",
            "resolved_identifier",
            b"resolved_identifier",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__resolved_identifier: _TypeAlias = _typing.Literal[
            "resolved_identifier"
        ]  # noqa: Y015
        _WhichOneofArgType__resolved_identifier: _TypeAlias = _typing.Literal[
            "_resolved_identifier", b"_resolved_identifier"
        ]  # noqa: Y015
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__resolved_identifier
        ) -> _WhichOneofReturnType__resolved_identifier | None: ...

    @_typing.final
    class DefineFlowResult(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        RESOLVED_IDENTIFIER_FIELD_NUMBER: _builtins.int
        @_builtins.property
        def resolved_identifier(self) -> _common_pb2.ResolvedIdentifier:
            """Resolved identifier of the flow"""
        def __init__(
            self,
            *,
            resolved_identifier: _common_pb2.ResolvedIdentifier | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal[
            "_resolved_identifier",
            b"_resolved_identifier",
            "resolved_identifier",
            b"resolved_identifier",
        ]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal[
            "_resolved_identifier",
            b"_resolved_identifier",
            "resolved_identifier",
            b"resolved_identifier",
        ]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
        _WhichOneofReturnType__resolved_identifier: _TypeAlias = _typing.Literal[
            "resolved_identifier"
        ]  # noqa: Y015
        _WhichOneofArgType__resolved_identifier: _TypeAlias = _typing.Literal[
            "_resolved_identifier", b"_resolved_identifier"
        ]  # noqa: Y015
        def WhichOneof(
            self, oneof_group: _WhichOneofArgType__resolved_identifier
        ) -> _WhichOneofReturnType__resolved_identifier | None: ...

    CREATE_DATAFLOW_GRAPH_RESULT_FIELD_NUMBER: _builtins.int
    DEFINE_OUTPUT_RESULT_FIELD_NUMBER: _builtins.int
    DEFINE_FLOW_RESULT_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def create_dataflow_graph_result(
        self,
    ) -> Global___PipelineCommandResult.CreateDataflowGraphResult: ...
    @_builtins.property
    def define_output_result(self) -> Global___PipelineCommandResult.DefineOutputResult: ...
    @_builtins.property
    def define_flow_result(self) -> Global___PipelineCommandResult.DefineFlowResult: ...
    def __init__(
        self,
        *,
        create_dataflow_graph_result: Global___PipelineCommandResult.CreateDataflowGraphResult
        | None = ...,
        define_output_result: Global___PipelineCommandResult.DefineOutputResult | None = ...,
        define_flow_result: Global___PipelineCommandResult.DefineFlowResult | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal[
        "create_dataflow_graph_result",
        b"create_dataflow_graph_result",
        "define_flow_result",
        b"define_flow_result",
        "define_output_result",
        b"define_output_result",
        "result_type",
        b"result_type",
    ]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal[
        "create_dataflow_graph_result",
        b"create_dataflow_graph_result",
        "define_flow_result",
        b"define_flow_result",
        "define_output_result",
        b"define_output_result",
        "result_type",
        b"result_type",
    ]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_result_type: _TypeAlias = _typing.Literal[
        "create_dataflow_graph_result", "define_output_result", "define_flow_result"
    ]  # noqa: Y015
    _WhichOneofArgType_result_type: _TypeAlias = _typing.Literal[
        "result_type", b"result_type"
    ]  # noqa: Y015
    def WhichOneof(
        self, oneof_group: _WhichOneofArgType_result_type
    ) -> _WhichOneofReturnType_result_type | None: ...

Global___PipelineCommandResult: _TypeAlias = PipelineCommandResult  # noqa: Y015

@_typing.final
class PipelineEventResult(_message.Message):
    """A response containing an event emitted during the run of a pipeline."""

    DESCRIPTOR: _descriptor.Descriptor

    EVENT_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def event(self) -> Global___PipelineEvent: ...
    def __init__(
        self,
        *,
        event: Global___PipelineEvent | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["event", b"event"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["event", b"event"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___PipelineEventResult: _TypeAlias = PipelineEventResult  # noqa: Y015

@_typing.final
class PipelineEvent(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    TIMESTAMP_FIELD_NUMBER: _builtins.int
    MESSAGE_FIELD_NUMBER: _builtins.int
    message: _builtins.str
    """The message that should be displayed to users."""
    @_builtins.property
    def timestamp(self) -> _timestamp_pb2.Timestamp:
        """The timestamp corresponding to when the event occurred."""
    def __init__(
        self,
        *,
        timestamp: _timestamp_pb2.Timestamp | None = ...,
        message: _builtins.str | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal[
        "_message", b"_message", "message", b"message", "timestamp", b"timestamp"
    ]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal[
        "_message", b"_message", "message", b"message", "timestamp", b"timestamp"
    ]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__message: _TypeAlias = _typing.Literal["message"]  # noqa: Y015
    _WhichOneofArgType__message: _TypeAlias = _typing.Literal["_message", b"_message"]  # noqa: Y015
    def WhichOneof(
        self, oneof_group: _WhichOneofArgType__message
    ) -> _WhichOneofReturnType__message | None: ...

Global___PipelineEvent: _TypeAlias = PipelineEvent  # noqa: Y015

@_typing.final
class SourceCodeLocation(_message.Message):
    """Source code location information associated with a particular dataset or flow."""

    DESCRIPTOR: _descriptor.Descriptor

    FILE_NAME_FIELD_NUMBER: _builtins.int
    LINE_NUMBER_FIELD_NUMBER: _builtins.int
    DEFINITION_PATH_FIELD_NUMBER: _builtins.int
    EXTENSION_FIELD_NUMBER: _builtins.int
    file_name: _builtins.str
    """The file that this pipeline source code was defined in."""
    line_number: _builtins.int
    """The specific line number that this pipeline source code is located at, if applicable."""
    definition_path: _builtins.str
    """The path of the top-level pipeline file determined at runtime during pipeline initialization."""
    @_builtins.property
    def extension(self) -> _containers.RepeatedCompositeFieldContainer[_any_pb2.Any]:
        """Reserved field for protocol extensions.
        Used to support forward-compatibility by carrying additional fields
        that are not yet defined in this version of the proto. During planning, the
        engine will resolve and dispatch the concrete command contained in this field.
        """
    def __init__(
        self,
        *,
        file_name: _builtins.str | None = ...,
        line_number: _builtins.int | None = ...,
        definition_path: _builtins.str | None = ...,
        extension: _abc.Iterable[_any_pb2.Any] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal[
        "_definition_path",
        b"_definition_path",
        "_file_name",
        b"_file_name",
        "_line_number",
        b"_line_number",
        "definition_path",
        b"definition_path",
        "file_name",
        b"file_name",
        "line_number",
        b"line_number",
    ]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal[
        "_definition_path",
        b"_definition_path",
        "_file_name",
        b"_file_name",
        "_line_number",
        b"_line_number",
        "definition_path",
        b"definition_path",
        "extension",
        b"extension",
        "file_name",
        b"file_name",
        "line_number",
        b"line_number",
    ]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__definition_path: _TypeAlias = _typing.Literal[
        "definition_path"
    ]  # noqa: Y015
    _WhichOneofArgType__definition_path: _TypeAlias = _typing.Literal[
        "_definition_path", b"_definition_path"
    ]  # noqa: Y015
    _WhichOneofReturnType__file_name: _TypeAlias = _typing.Literal["file_name"]  # noqa: Y015
    _WhichOneofArgType__file_name: _TypeAlias = _typing.Literal[
        "_file_name", b"_file_name"
    ]  # noqa: Y015
    _WhichOneofReturnType__line_number: _TypeAlias = _typing.Literal["line_number"]  # noqa: Y015
    _WhichOneofArgType__line_number: _TypeAlias = _typing.Literal[
        "_line_number", b"_line_number"
    ]  # noqa: Y015
    @_typing.overload
    def WhichOneof(
        self, oneof_group: _WhichOneofArgType__definition_path
    ) -> _WhichOneofReturnType__definition_path | None: ...
    @_typing.overload
    def WhichOneof(
        self, oneof_group: _WhichOneofArgType__file_name
    ) -> _WhichOneofReturnType__file_name | None: ...
    @_typing.overload
    def WhichOneof(
        self, oneof_group: _WhichOneofArgType__line_number
    ) -> _WhichOneofReturnType__line_number | None: ...

Global___SourceCodeLocation: _TypeAlias = SourceCodeLocation  # noqa: Y015

@_typing.final
class PipelineQueryFunctionExecutionSignal(_message.Message):
    """A signal from the server to the client to execute the query function for one or more flows, and
    to register their results with the server.
    """

    DESCRIPTOR: _descriptor.Descriptor

    FLOW_NAMES_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def flow_names(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]: ...
    def __init__(
        self,
        *,
        flow_names: _abc.Iterable[_builtins.str] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["flow_names", b"flow_names"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___PipelineQueryFunctionExecutionSignal: _TypeAlias = (
    PipelineQueryFunctionExecutionSignal  # noqa: Y015
)

@_typing.final
class PipelineAnalysisContext(_message.Message):
    """Metadata providing context about the pipeline during Spark Connect query analysis."""

    DESCRIPTOR: _descriptor.Descriptor

    DATAFLOW_GRAPH_ID_FIELD_NUMBER: _builtins.int
    DEFINITION_PATH_FIELD_NUMBER: _builtins.int
    FLOW_NAME_FIELD_NUMBER: _builtins.int
    EXTENSION_FIELD_NUMBER: _builtins.int
    dataflow_graph_id: _builtins.str
    """Unique identifier of the dataflow graph associated with this pipeline."""
    definition_path: _builtins.str
    """The path of the top-level pipeline file determined at runtime during pipeline initialization."""
    flow_name: _builtins.str
    """The name of the Flow involved in this analysis"""
    @_builtins.property
    def extension(self) -> _containers.RepeatedCompositeFieldContainer[_any_pb2.Any]:
        """Reserved field for protocol extensions."""
    def __init__(
        self,
        *,
        dataflow_graph_id: _builtins.str | None = ...,
        definition_path: _builtins.str | None = ...,
        flow_name: _builtins.str | None = ...,
        extension: _abc.Iterable[_any_pb2.Any] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal[
        "_dataflow_graph_id",
        b"_dataflow_graph_id",
        "_definition_path",
        b"_definition_path",
        "_flow_name",
        b"_flow_name",
        "dataflow_graph_id",
        b"dataflow_graph_id",
        "definition_path",
        b"definition_path",
        "flow_name",
        b"flow_name",
    ]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal[
        "_dataflow_graph_id",
        b"_dataflow_graph_id",
        "_definition_path",
        b"_definition_path",
        "_flow_name",
        b"_flow_name",
        "dataflow_graph_id",
        b"dataflow_graph_id",
        "definition_path",
        b"definition_path",
        "extension",
        b"extension",
        "flow_name",
        b"flow_name",
    ]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType__dataflow_graph_id: _TypeAlias = _typing.Literal[
        "dataflow_graph_id"
    ]  # noqa: Y015
    _WhichOneofArgType__dataflow_graph_id: _TypeAlias = _typing.Literal[
        "_dataflow_graph_id", b"_dataflow_graph_id"
    ]  # noqa: Y015
    _WhichOneofReturnType__definition_path: _TypeAlias = _typing.Literal[
        "definition_path"
    ]  # noqa: Y015
    _WhichOneofArgType__definition_path: _TypeAlias = _typing.Literal[
        "_definition_path", b"_definition_path"
    ]  # noqa: Y015
    _WhichOneofReturnType__flow_name: _TypeAlias = _typing.Literal["flow_name"]  # noqa: Y015
    _WhichOneofArgType__flow_name: _TypeAlias = _typing.Literal[
        "_flow_name", b"_flow_name"
    ]  # noqa: Y015
    @_typing.overload
    def WhichOneof(
        self, oneof_group: _WhichOneofArgType__dataflow_graph_id
    ) -> _WhichOneofReturnType__dataflow_graph_id | None: ...
    @_typing.overload
    def WhichOneof(
        self, oneof_group: _WhichOneofArgType__definition_path
    ) -> _WhichOneofReturnType__definition_path | None: ...
    @_typing.overload
    def WhichOneof(
        self, oneof_group: _WhichOneofArgType__flow_name
    ) -> _WhichOneofReturnType__flow_name | None: ...

Global___PipelineAnalysisContext: _TypeAlias = PipelineAnalysisContext  # noqa: Y015
