#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file

Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import pyspark.sql.connect.proto.expressions_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class Relation(google.protobuf.message.Message):
    """The main [[Relation]] type. Fundamentally, a relation is a typed container
    that has exactly one explicit relation type set.

    When adding new relation types, they have to be registered here.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COMMON_FIELD_NUMBER: builtins.int
    READ_FIELD_NUMBER: builtins.int
    PROJECT_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    JOIN_FIELD_NUMBER: builtins.int
    UNION_FIELD_NUMBER: builtins.int
    SORT_FIELD_NUMBER: builtins.int
    FETCH_FIELD_NUMBER: builtins.int
    AGGREGATE_FIELD_NUMBER: builtins.int
    SQL_FIELD_NUMBER: builtins.int
    UNKNOWN_FIELD_NUMBER: builtins.int
    @property
    def common(self) -> global___RelationCommon: ...
    @property
    def read(self) -> global___Read: ...
    @property
    def project(self) -> global___Project: ...
    @property
    def filter(self) -> global___Filter: ...
    @property
    def join(self) -> global___Join: ...
    @property
    def union(self) -> global___Union: ...
    @property
    def sort(self) -> global___Sort: ...
    @property
    def fetch(self) -> global___Fetch: ...
    @property
    def aggregate(self) -> global___Aggregate: ...
    @property
    def sql(self) -> global___SQL: ...
    @property
    def unknown(self) -> global___Unknown: ...
    def __init__(
        self,
        *,
        common: global___RelationCommon | None = ...,
        read: global___Read | None = ...,
        project: global___Project | None = ...,
        filter: global___Filter | None = ...,
        join: global___Join | None = ...,
        union: global___Union | None = ...,
        sort: global___Sort | None = ...,
        fetch: global___Fetch | None = ...,
        aggregate: global___Aggregate | None = ...,
        sql: global___SQL | None = ...,
        unknown: global___Unknown | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "aggregate",
            b"aggregate",
            "common",
            b"common",
            "fetch",
            b"fetch",
            "filter",
            b"filter",
            "join",
            b"join",
            "project",
            b"project",
            "read",
            b"read",
            "rel_type",
            b"rel_type",
            "sort",
            b"sort",
            "sql",
            b"sql",
            "union",
            b"union",
            "unknown",
            b"unknown",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "aggregate",
            b"aggregate",
            "common",
            b"common",
            "fetch",
            b"fetch",
            "filter",
            b"filter",
            "join",
            b"join",
            "project",
            b"project",
            "read",
            b"read",
            "rel_type",
            b"rel_type",
            "sort",
            b"sort",
            "sql",
            b"sql",
            "union",
            b"union",
            "unknown",
            b"unknown",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing_extensions.Literal["rel_type", b"rel_type"]
    ) -> typing_extensions.Literal[
        "read", "project", "filter", "join", "union", "sort", "fetch", "aggregate", "sql", "unknown"
    ] | None: ...

global___Relation = Relation

class Unknown(google.protobuf.message.Message):
    """Used for testing purposes only."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___Unknown = Unknown

class RelationCommon(google.protobuf.message.Message):
    """Common metadata of all relations."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SOURCE_INFO_FIELD_NUMBER: builtins.int
    ALIAS_FIELD_NUMBER: builtins.int
    source_info: builtins.str
    alias: builtins.str
    def __init__(
        self,
        *,
        source_info: builtins.str = ...,
        alias: builtins.str = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["alias", b"alias", "source_info", b"source_info"],
    ) -> None: ...

global___RelationCommon = RelationCommon

class SQL(google.protobuf.message.Message):
    """Relation that uses a SQL query to generate the output."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    QUERY_FIELD_NUMBER: builtins.int
    query: builtins.str
    def __init__(
        self,
        *,
        query: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["query", b"query"]) -> None: ...

global___SQL = SQL

class Read(google.protobuf.message.Message):
    """Relation that reads from a file / table or other data source. Does not have additional
    inputs.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class NamedTable(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        PARTS_FIELD_NUMBER: builtins.int
        @property
        def parts(
            self,
        ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]: ...
        def __init__(
            self,
            *,
            parts: collections.abc.Iterable[builtins.str] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["parts", b"parts"]) -> None: ...

    NAMED_TABLE_FIELD_NUMBER: builtins.int
    @property
    def named_table(self) -> global___Read.NamedTable: ...
    def __init__(
        self,
        *,
        named_table: global___Read.NamedTable | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "named_table", b"named_table", "read_type", b"read_type"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "named_table", b"named_table", "read_type", b"read_type"
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing_extensions.Literal["read_type", b"read_type"]
    ) -> typing_extensions.Literal["named_table"] | None: ...

global___Read = Read

class Project(google.protobuf.message.Message):
    """Projection of a bag of expressions for a given input relation.

    The input relation must be specified.
    The projected expression can be an arbitrary expression.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INPUT_FIELD_NUMBER: builtins.int
    EXPRESSIONS_FIELD_NUMBER: builtins.int
    @property
    def input(self) -> global___Relation: ...
    @property
    def expressions(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        pyspark.sql.connect.proto.expressions_pb2.Expression
    ]: ...
    def __init__(
        self,
        *,
        input: global___Relation | None = ...,
        expressions: collections.abc.Iterable[pyspark.sql.connect.proto.expressions_pb2.Expression]
        | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing_extensions.Literal["input", b"input"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["expressions", b"expressions", "input", b"input"],
    ) -> None: ...

global___Project = Project

class Filter(google.protobuf.message.Message):
    """Relation that applies a boolean expression `condition` on each row of `input` to produce
    the output result.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INPUT_FIELD_NUMBER: builtins.int
    CONDITION_FIELD_NUMBER: builtins.int
    @property
    def input(self) -> global___Relation: ...
    @property
    def condition(self) -> pyspark.sql.connect.proto.expressions_pb2.Expression: ...
    def __init__(
        self,
        *,
        input: global___Relation | None = ...,
        condition: pyspark.sql.connect.proto.expressions_pb2.Expression | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing_extensions.Literal["condition", b"condition", "input", b"input"]
    ) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing_extensions.Literal["condition", b"condition", "input", b"input"]
    ) -> None: ...

global___Filter = Filter

class Join(google.protobuf.message.Message):
    """Relation of type [[Join]].

    `left` and `right` must be present.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _JoinType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _JoinTypeEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Join._JoinType.ValueType],
        builtins.type,
    ):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        JOIN_TYPE_UNSPECIFIED: Join._JoinType.ValueType  # 0
        JOIN_TYPE_INNER: Join._JoinType.ValueType  # 1
        JOIN_TYPE_OUTER: Join._JoinType.ValueType  # 2
        JOIN_TYPE_LEFT_OUTER: Join._JoinType.ValueType  # 3
        JOIN_TYPE_RIGHT_OUTER: Join._JoinType.ValueType  # 4
        JOIN_TYPE_ANTI: Join._JoinType.ValueType  # 5

    class JoinType(_JoinType, metaclass=_JoinTypeEnumTypeWrapper): ...
    JOIN_TYPE_UNSPECIFIED: Join.JoinType.ValueType  # 0
    JOIN_TYPE_INNER: Join.JoinType.ValueType  # 1
    JOIN_TYPE_OUTER: Join.JoinType.ValueType  # 2
    JOIN_TYPE_LEFT_OUTER: Join.JoinType.ValueType  # 3
    JOIN_TYPE_RIGHT_OUTER: Join.JoinType.ValueType  # 4
    JOIN_TYPE_ANTI: Join.JoinType.ValueType  # 5

    LEFT_FIELD_NUMBER: builtins.int
    RIGHT_FIELD_NUMBER: builtins.int
    ON_FIELD_NUMBER: builtins.int
    HOW_FIELD_NUMBER: builtins.int
    @property
    def left(self) -> global___Relation: ...
    @property
    def right(self) -> global___Relation: ...
    @property
    def on(self) -> pyspark.sql.connect.proto.expressions_pb2.Expression: ...
    how: global___Join.JoinType.ValueType
    def __init__(
        self,
        *,
        left: global___Relation | None = ...,
        right: global___Relation | None = ...,
        on: pyspark.sql.connect.proto.expressions_pb2.Expression | None = ...,
        how: global___Join.JoinType.ValueType = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing_extensions.Literal["left", b"left", "on", b"on", "right", b"right"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "how", b"how", "left", b"left", "on", b"on", "right", b"right"
        ],
    ) -> None: ...

global___Join = Join

class Union(google.protobuf.message.Message):
    """Relation of type [[Union]], at least one input must be set."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _UnionType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _UnionTypeEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Union._UnionType.ValueType],
        builtins.type,
    ):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNION_TYPE_UNSPECIFIED: Union._UnionType.ValueType  # 0
        UNION_TYPE_DISTINCT: Union._UnionType.ValueType  # 1
        UNION_TYPE_ALL: Union._UnionType.ValueType  # 2

    class UnionType(_UnionType, metaclass=_UnionTypeEnumTypeWrapper): ...
    UNION_TYPE_UNSPECIFIED: Union.UnionType.ValueType  # 0
    UNION_TYPE_DISTINCT: Union.UnionType.ValueType  # 1
    UNION_TYPE_ALL: Union.UnionType.ValueType  # 2

    INPUTS_FIELD_NUMBER: builtins.int
    UNION_TYPE_FIELD_NUMBER: builtins.int
    @property
    def inputs(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Relation]: ...
    union_type: global___Union.UnionType.ValueType
    def __init__(
        self,
        *,
        inputs: collections.abc.Iterable[global___Relation] | None = ...,
        union_type: global___Union.UnionType.ValueType = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["inputs", b"inputs", "union_type", b"union_type"],
    ) -> None: ...

global___Union = Union

class Fetch(google.protobuf.message.Message):
    """Relation of type [[Fetch]] that is used to read `limit` / `offset` rows from the input relation."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INPUT_FIELD_NUMBER: builtins.int
    LIMIT_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    @property
    def input(self) -> global___Relation: ...
    limit: builtins.int
    offset: builtins.int
    def __init__(
        self,
        *,
        input: global___Relation | None = ...,
        limit: builtins.int = ...,
        offset: builtins.int = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing_extensions.Literal["input", b"input"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "input", b"input", "limit", b"limit", "offset", b"offset"
        ],
    ) -> None: ...

global___Fetch = Fetch

class Aggregate(google.protobuf.message.Message):
    """Relation of type [[Aggregate]]."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class GroupingSet(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        AGGREGATE_EXPRESSIONS_FIELD_NUMBER: builtins.int
        @property
        def aggregate_expressions(
            self,
        ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
            pyspark.sql.connect.proto.expressions_pb2.Expression
        ]: ...
        def __init__(
            self,
            *,
            aggregate_expressions: collections.abc.Iterable[
                pyspark.sql.connect.proto.expressions_pb2.Expression
            ]
            | None = ...,
        ) -> None: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal[
                "aggregate_expressions", b"aggregate_expressions"
            ],
        ) -> None: ...

    class Measure(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        FUNCTION_FIELD_NUMBER: builtins.int
        FILTER_FIELD_NUMBER: builtins.int
        @property
        def function(self) -> global___Aggregate.AggregateFunction: ...
        @property
        def filter(self) -> pyspark.sql.connect.proto.expressions_pb2.Expression:
            """Conditional filter for SUM(x FILTER WHERE x < 10)"""
        def __init__(
            self,
            *,
            function: global___Aggregate.AggregateFunction | None = ...,
            filter: pyspark.sql.connect.proto.expressions_pb2.Expression | None = ...,
        ) -> None: ...
        def HasField(
            self,
            field_name: typing_extensions.Literal["filter", b"filter", "function", b"function"],
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal["filter", b"filter", "function", b"function"],
        ) -> None: ...

    class AggregateFunction(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        NAME_FIELD_NUMBER: builtins.int
        ARGUMENTS_FIELD_NUMBER: builtins.int
        name: builtins.str
        @property
        def arguments(
            self,
        ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
            pyspark.sql.connect.proto.expressions_pb2.Expression
        ]: ...
        def __init__(
            self,
            *,
            name: builtins.str = ...,
            arguments: collections.abc.Iterable[
                pyspark.sql.connect.proto.expressions_pb2.Expression
            ]
            | None = ...,
        ) -> None: ...
        def ClearField(
            self, field_name: typing_extensions.Literal["arguments", b"arguments", "name", b"name"]
        ) -> None: ...

    INPUT_FIELD_NUMBER: builtins.int
    GROUPING_SETS_FIELD_NUMBER: builtins.int
    MEASURES_FIELD_NUMBER: builtins.int
    @property
    def input(self) -> global___Relation: ...
    @property
    def grouping_sets(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___Aggregate.GroupingSet
    ]:
        """Grouping sets are used in rollups"""
    @property
    def measures(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___Aggregate.Measure
    ]:
        """Measures"""
    def __init__(
        self,
        *,
        input: global___Relation | None = ...,
        grouping_sets: collections.abc.Iterable[global___Aggregate.GroupingSet] | None = ...,
        measures: collections.abc.Iterable[global___Aggregate.Measure] | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing_extensions.Literal["input", b"input"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "grouping_sets", b"grouping_sets", "input", b"input", "measures", b"measures"
        ],
    ) -> None: ...

global___Aggregate = Aggregate

class Sort(google.protobuf.message.Message):
    """Relation of type [[Sort]]."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _SortDirection:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _SortDirectionEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Sort._SortDirection.ValueType],
        builtins.type,
    ):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SORT_DIRECTION_UNSPECIFIED: Sort._SortDirection.ValueType  # 0
        SORT_DIRECTION_ASCENDING: Sort._SortDirection.ValueType  # 1
        SORT_DIRECTION_DESCENDING: Sort._SortDirection.ValueType  # 2

    class SortDirection(_SortDirection, metaclass=_SortDirectionEnumTypeWrapper): ...
    SORT_DIRECTION_UNSPECIFIED: Sort.SortDirection.ValueType  # 0
    SORT_DIRECTION_ASCENDING: Sort.SortDirection.ValueType  # 1
    SORT_DIRECTION_DESCENDING: Sort.SortDirection.ValueType  # 2

    class _SortNulls:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _SortNullsEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Sort._SortNulls.ValueType],
        builtins.type,
    ):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SORT_NULLS_UNSPECIFIED: Sort._SortNulls.ValueType  # 0
        SORT_NULLS_FIRST: Sort._SortNulls.ValueType  # 1
        SORT_NULLS_LAST: Sort._SortNulls.ValueType  # 2

    class SortNulls(_SortNulls, metaclass=_SortNullsEnumTypeWrapper): ...
    SORT_NULLS_UNSPECIFIED: Sort.SortNulls.ValueType  # 0
    SORT_NULLS_FIRST: Sort.SortNulls.ValueType  # 1
    SORT_NULLS_LAST: Sort.SortNulls.ValueType  # 2

    class SortField(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        EXPRESSION_FIELD_NUMBER: builtins.int
        DIRECTION_FIELD_NUMBER: builtins.int
        NULLS_FIELD_NUMBER: builtins.int
        @property
        def expression(self) -> pyspark.sql.connect.proto.expressions_pb2.Expression: ...
        direction: global___Sort.SortDirection.ValueType
        nulls: global___Sort.SortNulls.ValueType
        def __init__(
            self,
            *,
            expression: pyspark.sql.connect.proto.expressions_pb2.Expression | None = ...,
            direction: global___Sort.SortDirection.ValueType = ...,
            nulls: global___Sort.SortNulls.ValueType = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing_extensions.Literal["expression", b"expression"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal[
                "direction", b"direction", "expression", b"expression", "nulls", b"nulls"
            ],
        ) -> None: ...

    INPUT_FIELD_NUMBER: builtins.int
    SORT_FIELDS_FIELD_NUMBER: builtins.int
    @property
    def input(self) -> global___Relation: ...
    @property
    def sort_fields(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___Sort.SortField
    ]: ...
    def __init__(
        self,
        *,
        input: global___Relation | None = ...,
        sort_fields: collections.abc.Iterable[global___Sort.SortField] | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing_extensions.Literal["input", b"input"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["input", b"input", "sort_fields", b"sort_fields"],
    ) -> None: ...

global___Sort = Sort
