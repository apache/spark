/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.spark.sql.catalyst.analysis.resolver

import java.util.{HashMap, LinkedHashMap}

import scala.collection.mutable
import scala.jdk.CollectionConverters._


import org.apache.spark.sql.catalyst.analysis.UnresolvedAttribute
import org.apache.spark.sql.catalyst.expressions.{
  Alias,
  Attribute,
  Expression,
  ExprId,
  InSubquery,
  IntegerLiteral,
  Literal,
  NamedExpression,
  SortOrder,
  SubqueryExpression
}
import org.apache.spark.sql.catalyst.plans.logical.{
  Aggregate,
  Filter,
  LogicalPlan,
  Project,
  Sort,
  Window
}
import org.apache.spark.sql.errors.QueryCompilationErrors

/**
 * Resolves a [[Sort]] by resolving its child and order expressions.
 */
class SortResolver(operatorResolver: Resolver, expressionResolver: ExpressionResolver)
    extends TreeNodeResolver[Sort, LogicalPlan]
    with RewritesAliasesInTopLcaProject
    with ResolvesNameByHiddenOutput {
  private val scopes: NameScopeStack = operatorResolver.getNameScopes
  private val cteRegistry = operatorResolver.getCteRegistry
  private val operatorResolutionContextStack = operatorResolver.getOperatorResolutionContextStack
  private val autoGeneratedAliasProvider = expressionResolver.getAutoGeneratedAliasProvider
  private val ordinalResolver = expressionResolver.getOrdinalResolver

  /**
   * Resolve [[Sort]] operator.
   *
   *  1. Resolve [[Sort.child]] and set
   *     [[OperatorResolutionContextStack.ordinalReplacementExpressions]] for [[SortOrder]]
   *     resolution.
   *  2. Resolve order expressions using [[ExpressionResolver.resolveExpressionTreeInOperator]].
   *  3. In case order expressions contain only one element, `UnresolvedAttribute(ALL)`, which
   *     can't be resolved from current (nor from hidden output) - this is done using
   *     [[ResolveAsAllKeyword]], skip previous step and resolve it as an `ALL` keyword (by copying
   *     child's output and transforming it into attributes).
   *  4. In case there are attributes referenced in the order expressions are resolved using
   *     the hidden output (or in case we order by [[AggregateExpression]]s which are not present
   *     in [[Aggregate.aggregateExpressions]]) update the output of child operator and add a
   *     [[Project]] as a parent of [[Sort]] with original [[Project]]'s output (this is done by
   *     [[ResolvesNameByHiddenOutput]]). Query:
   *     {{{
   *     SELECT col1 FROM VALUES(1, 2) WHERE col2 > 2 ORDER BY col2;
   *     }}}
   *     Has the following unresolved plan:
   *
   *     'Sort ['col2 ASC NULLS FIRST], true
   *       +- 'Project ['col1]
   *         +- 'Filter ('col2 > 2)
   *           +- LocalRelation [col1#92225, col2#92226]
   *
   *     Because `col2` from the [[Sort]] node is resolved using the hidden output, add it to the
   *     [[Project.projectList]] and add a [[Project]] with original project list as a top node:
   *
   *     Project [col1]
   *       +- Sort [col2 ASC NULLS FIRST], true
   *         +- Project [col1, col2]
   *           +- Filter (col2 > 2)
   *             +- LocalRelation [col1, col2]
   *
   *     Another example with ordering by [[AggregateExpression]]:
   *     {{{
   *     SELECT col1 FROM VALUES (1, 2) GROUP BY col1, col2 + 1 ORDER BY SUM(col1), col2 + 1;
   *     }}}
   *     Has the following unresolved plan:
   *
   *     'Sort ['SUM('col1) ASC NULLS FIRST, ('col2 + 1) ASC NULLS FIRST], true
   *       +- 'Aggregate ['col1, ('col2 + 1)], ['col1]
   *         +- LocalRelation [col1, col2]
   *
   *     Because neither `SUM(col1)` nor `col2 + 1` from the [[Sort]] node are present in the
   *     [[Aggregate.aggregateExpressions]], add them to it and add a [[Project]] with original
   *     project list as a top node (`SUM(col2)` is extracted in the
   *     [[AggregateExpressionResolver]] whereas `col2 + 1` is extracted using
   *     `extractReferencedGroupingAndAggregateExpressions` helper method):
   *
   *     Project [col1]
   *       +- Sort [sum(col1)#... ASC NULLS FIRST, (col2 + 1)#... ASC NULLS FIRST], true
   *         +- Aggregate [col1, (col2 + 1)],
   *                      [col1, sum(col1) AS sum(col1)#..., (col2 + 1) AS (col2 + 1)#...]
   *           +- LocalRelation [col1, col2]
   *
   *    Here's an analogous query having [[WindowExpression]]s:
   *    {{{
   *    SELECT
   *      SUM(col1) OVER () FROM VALUES (1, 2)
   *    GROUP BY col1, col2 + 1
   *    ORDER BY SUM(col1), col2 + 1;
   *    }}}
   *
   *    Just like in the previous query, `col2 + 1` and `SUM(col1)` are extracted using helper
   *    methods since they do not appear in the [[Aggregate.aggregateExpressions]]:
   *
   *    Project [sum(col1) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)#13L]
   *      +- Sort [sum(col1)# ASC NULLS FIRST, (col2 + 1)# ASC NULLS FIRST], true
   *        +- Window [sum(col1) windowspec... AS sum(col1) OVER ..., (col2 + 1)#, sum(col1)#]
   *          +- Aggregate [col1, (col2 + 1)],
   *                       [col1, (col2 + 1) AS (col2 + 1)#..., sum(col1) AS sum(col1)#...]
   *            +- LocalRelation [col1, col2]
   *
   * Also, [[Sort]] behavior with recursive CTEs isn't strictly defined, so there is a flag to
   * disable recursive CTE self references in its scope.
   */
  override def resolve(unresolvedSort: Sort): LogicalPlan = {

    val resolvedChild = operatorResolver.resolve(unresolvedSort.child)

    failIfIllegalRecursiveSelfReference()

    GroupingAnalyticsResolver.restrictGroupingAnalyticsBelowSortAndFilter(
      operatorResolutionContextStack.current
    )

    operatorResolutionContextStack.current.ordinalReplacementExpressions = Some(
      OrdinalReplacementSortOrderExpressions(
        expressions = scopes.current.output.toIndexedSeq,
        unresolvedSort = unresolvedSort
      )
    )

    if (canOrderByAll(unresolvedSort.order)) {
      val sortOrder = unresolvedSort.order.head
      val resolvedOrder =
        scopes.current.output.map(a => sortOrder.copy(child = a.toAttribute))
      unresolvedSort.copy(child = resolvedChild, order = resolvedOrder)
    } else {
      val partiallyResolvedSort = unresolvedSort.copy(child = resolvedChild)

      val (partiallyResolvedOrderExpressions, missingAttributes) =
        resolveOrderExpressions(partiallyResolvedSort)

      val (resolvedOrderExpressions, missingExpressions) = resolvedChild match {
        case _ @(_: Aggregate | _: Filter | _: Project | _: Window)
            if scopes.current.baseAggregate.isDefined =>
          extractReferencedGroupingAndAggregateExpressions(
            scopes.current.baseAggregate.get,
            partiallyResolvedOrderExpressions
          )
        case other =>
          (partiallyResolvedOrderExpressions, missingAttributes)
      }

      val (resolvedOrderExpressionsWithAliasesReplaced, filteredMissingExpressions) =
        tryReplaceSortOrderWithAlias(resolvedOrderExpressions, missingExpressions)

      val resolvedChildWithMissingAttributes =
        insertMissingExpressions(resolvedChild, filteredMissingExpressions)

      val isChildChangedByMissingExpressions = !resolvedChildWithMissingAttributes.eq(resolvedChild)

      val (finalChild, finalOrderExpressions) = resolvedChildWithMissingAttributes match {
        case project: Project if scopes.current.baseAggregate.isDefined =>
          rewriteNamedExpressionsInTopLcaProject[SortOrder](
            projectToRewrite = project,
            baseAggregate = scopes.current.baseAggregate.get,
            expressionsToRewrite = resolvedOrderExpressionsWithAliasesReplaced,
            rewriteCandidates = missingExpressions,
            autoGeneratedAliasProvider = autoGeneratedAliasProvider
          )
        case other => (other, resolvedOrderExpressionsWithAliasesReplaced)
      }

      val resolvedSort = unresolvedSort.copy(
        child = finalChild,
        order = finalOrderExpressions
      )

      if (isChildChangedByMissingExpressions) {
        retainOriginalOutput(
          operator = resolvedSort,
          missingExpressions = missingExpressions,
          scopes = scopes,
          operatorResolutionContextStack = operatorResolutionContextStack
        )
      } else {
        resolvedSort
      }
    }
  }

  /**
   * Behavior of recursive CTEs with [[Sort]] nodes isn't strictly defined, as its unclear whether
   * the whole result set is supposed to be sorted, or only the last iteration. Here it's
   * implemented as the latter, but since this behavior isn't standard, it's controlled by a flag.
   */
  private def failIfIllegalRecursiveSelfReference(): Unit = {
    ()
  }

  /**
   * Resolve order expressions of an unresolved [[Sort]], returns attributes resolved using hidden
   * output and extracted [[AggregateExpression]]s. In case of [[UnresolvedAttribute]] resolution,
   * respect the following order.
   *
   *  1. Attribute can be resolved using the current scope:
   *     {{{
   *     -- This one will resolve `col1` from the current scope (its value will be 1)
   *     SELECT col1 FROM VALUES(1, 2) WHERE (SELECT col1 FROM VALUES(3)) ORDER BY col1;
   *     }}}
   *
   *  2. Attribute can be resolved using the hidden output. Attribute is added to
   *     `missingAttributes` which is used to update the plan using the
   *     [[ResolvesNameByHiddenOutput]].
   *     {{{
   *     -- This one will resolve `col2` from hidden output
   *     SELECT col1 FROM VALUES(1, 2) WHERE col2 > 2 ORDER BY col2;
   *     }}}
   *
   *  3. In case attribute can't be resolved from output nor from hidden output, throw
   *     `UNRESOLVED_COLUMN` exception:
   *     {{{
   *     -- Following queries throw `UNRESOLVED_COLUMN` exception:
   *     SELECT col1 FROM VALUES(1,2) GROUP BY col1 HAVING col1 > 1 ORDER BY col2;
   *     SELECT col1 FROM VALUES(1) ORDER BY col2;
   *     }}}
   */
  private def resolveOrderExpressions(
      partiallyResolvedSort: Sort): (Seq[SortOrder], Seq[Attribute]) = {
    val orderByOrdinal = conf.orderByOrdinal
    val replaceOrdinalsBeforeAnalysis = true

    val referencedAttributes = new HashMap[ExprId, Attribute]

    val resolvedSortOrder = partiallyResolvedSort.order.map { sortOrder =>
      val resolvedSortOrder = expressionResolver
        .resolveExpressionTreeInOperator(sortOrder, partiallyResolvedSort)
        .asInstanceOf[SortOrder]

      referencedAttributes.putAll(expressionResolver.getLastReferencedAttributes)

      if (replaceOrdinalsBeforeAnalysis) {
        resolvedSortOrder
      } else {
        legacyReplaceOrdinalInSortOrder(resolvedSortOrder, orderByOrdinal = orderByOrdinal)
      }
    }

    val missingAttributes = scopes.current.resolveMissingAttributesByHiddenOutput(
      referencedAttributes
    )

    (resolvedSortOrder, missingAttributes)
  }

  /**
   * Replaces the integer ordinal with the actual expression from the current scope output using
   * [[OrdinalResolver]].
   *
   * This logic is only relevant for the legacy behavior when
   * Ordinal replacement uses the legacy behavior when disabled.
   */
  private def legacyReplaceOrdinalInSortOrder(
      resolvedSortOrder: SortOrder,
      orderByOrdinal: Boolean): SortOrder = {
    if (!orderByOrdinal) {
      resolvedSortOrder
    } else {
      TryExtractOrdinal(resolvedSortOrder.child) match {
        case Some(ordinal) =>
          resolvedSortOrder.copy(child = ordinalResolver.resolve(ordinal))
        case None =>
          resolvedSortOrder
      }
    }
  }

  /**
   * Extracts the referenced grouping and aggregate expressions from the order expressions. This is
   * used to:
   *  - Update [[OperatorResolutionContext.subqueryExpressionsToValidate]] (see
   *    `updateSubqueryExpressionsInTheContextOfOperator` for more info)
   *  - Update the output of the child operator and add a [[Project]] as a parent of [[Sort]] later
   *    during the resolution (if needed).
   *
   * Consider the following example:
   * {{{
   * SELECT col1 FROM VALUES (1, 2) GROUP BY col1, col2 ORDER BY col2;
   * }}}
   *
   * The unresolved plan would look like this:
   *
   * 'Sort ['col2 ASC NULLS FIRST], true
   *   +- 'Aggregate ['col1, 'col2], ['col1]
   *     +- LocalRelation [col1, col2]
   *
   * As it can be seen, `col2` (ordering expression) is not present in the [[Aggregate]] operator
   * , and thus we return it from this method. The plan will be altered later during the resolution
   * using the [[ResolvesNameByHiddenOutput]] (`col2` will be added to
   * [[Aggregate.aggregateExpressions]], [[Project]] will be added as a top node with original
   * [[Aggregate]] output) and it will look like:
   *
   * Project [col1]
   *   +- Sort [col2 ASC NULLS FIRST], true
   *     +- Aggregate [col1, col2], [col1, col2]
   *       +- LocalRelation [col1, col2]
   *
   * Extraction is done in a top-down manner by traversing the expression tree of the condition,
   * swapping an underlying expression found in the grouping or aggregate expressions with the one
   * that matches it and populating the `referencedGroupingExpressions` and
   * `extractedAggregateExpressionAliases` lists to insert missing expressions later. If the
   * expression has already been previously extracted, instead of extracting it again, we will
   * use a reference to its [[Alias]].
   */
  private def extractReferencedGroupingAndAggregateExpressions(
      aggregate: Aggregate,
      sortOrderEntries: Seq[SortOrder]): (Seq[SortOrder], Seq[NamedExpression]) = {
    operatorResolutionContextStack.current.subqueryExpressionsToValidate.clear()

    val groupingAndAggregateExpressionsExtractor =
      new GroupingAndAggregateExpressionsExtractor(aggregate, autoGeneratedAliasProvider)

    val referencedGroupingExpressions = new LinkedHashMap[Expression, NamedExpression]
    val extractedAggregateExpressionAliases = new LinkedHashMap[Expression, Alias]

    val transformedSortOrderEntries = sortOrderEntries.map { sortOrder =>
      sortOrder.copy(child = sortOrder.child.transformDown {
        case expression: Expression =>
          val extractedExpression = groupingAndAggregateExpressionsExtractor
            .extractReferencedGroupingAndAggregateExpressions(
              expression = expression,
              referencedGroupingExpressions = referencedGroupingExpressions,
              extractedAggregateExpressionAliases = extractedAggregateExpressionAliases
            )

          updateSubqueryExpressionsInTheContextOfOperator(extractedExpression)

          extractedExpression
      })
    }

    (
      transformedSortOrderEntries,
      referencedGroupingExpressions.values().asScala.toSeq ++
      extractedAggregateExpressionAliases.values().asScala.toSeq
    )
  }

  /**
   * Updates the [[OperatorResolutionContext.subqueryExpressionsToValidate]] if the expression is a
   * [[SubqueryExpression]]. This is needed because sometimes we replace the subquery expression
   * with an attribute in `extractReferencedGroupingAndAggregateExpressions`. Consider the
   * following example:
   *
   * {{{ SELECT 1 GROUP BY 1 IN (SELECT 1) ORDER BY 1 IN (SELECT 1); }}}
   *
   * In this case, the sort order expression would be replaced with an attribute because it
   * references the grouping expression (they are semantically the same). Analyzed plan looks like:
   *
   * {{{
   * Project [1#2]
   * +- Sort [(1 IN (listquery()))#5 ASC NULLS FIRST], true
   *    +- Aggregate [1 IN (list#0 [])], [1 AS 1#2, 1 IN (list#1 []) AS (1 IN (listquery()))#5]
   *       :  :- Project [1 AS 1#3]
   *       :  :  +- OneRowRelation
   *       :  +- Project [1 AS 1#4]
   *       :     +- OneRowRelation
   *       +- OneRowRelation
   * }}}
   *
   * As it can be seen, there are no subquery expressions in the [[Sort]] operator, and thus we
   * don't fail (as we shouldn't).
   *
   * On the other side:
   *
   * {{{ SELECT 1 ORDER BY 1 IN (SELECT 1); }}}
   *
   * In this query the sort order expression contains a subquery expression (it's not extracted)
   * and we fail with `UNSUPPORTED_SUBQUERY_EXPRESSION_CATEGORY.UNSUPPORTED_IN_EXISTS_SUBQUERY`.
   */
  private def updateSubqueryExpressionsInTheContextOfOperator(expression: Expression): Unit = {
    expression match {
      case inSubquery: InSubquery =>
        operatorResolutionContextStack.current.subqueryExpressionsToValidate.add(inSubquery.query)
      case subqueryExpression: SubqueryExpression =>
        operatorResolutionContextStack.current.subqueryExpressionsToValidate.add(subqueryExpression)
      case _ =>
    }
  }

  /**
   * When resolving [[Sort]] on top of an [[Aggregate]] that has lateral column aliases,
   * [[extractReferencedGroupingAndAggregateExpressions]] may not correctly replace all
   * [[SortOrder]] expressions because of newly construct [[Project]] nodes coming from LCA
   * resolution. This method replaces all [[SortOrder]] with their aliases if those expressions
   * don't exist in child [[Project]] but the aliases do.
   * For more details see [[tryReplaceSortOrderOrHavingConditionWithAlias]].
   */
  private def tryReplaceSortOrderWithAlias(
      orderExpressions: Seq[SortOrder],
      missingExpressions: Seq[NamedExpression]
  ): (Seq[SortOrder], Seq[NamedExpression]) = {
    val replacedOrderExpressions = new mutable.ArrayBuffer[SortOrder]
    var currentMissingExpressions = missingExpressions

    orderExpressions.map { orderExpression =>
      val (replacedOrder, updatedMissingExpressions) =
        tryReplaceSortOrderOrHavingConditionWithAlias(
          sortOrderOrCondition = orderExpression,
          scopes = scopes,
          missingExpressions = currentMissingExpressions
        )

      replacedOrderExpressions += replacedOrder.asInstanceOf[SortOrder]
      currentMissingExpressions = updatedMissingExpressions
    }

    (replacedOrderExpressions.toSeq, currentMissingExpressions)
  }

  private def canOrderByAll(expressions: Seq[SortOrder]): Boolean = {
    val isOrderByAll = expressions match {
      case Seq(SortOrder(unresolvedAttribute: UnresolvedAttribute, _, _, _)) =>
        unresolvedAttribute.equalsIgnoreCase("ALL")
      case _ => false
    }
    isOrderByAll && scopes.current
      .resolveMultipartName(
        Seq("ALL"),
        NameResolutionParameters(canResolveNameByHiddenOutput = true)
      )
      .candidates
      .isEmpty
  }
}
