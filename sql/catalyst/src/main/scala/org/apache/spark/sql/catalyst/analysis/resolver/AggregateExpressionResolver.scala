/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.spark.sql.catalyst.analysis.resolver

import java.util.IdentityHashMap

import org.apache.spark.SparkException
import org.apache.spark.sql.AnalysisException
import org.apache.spark.sql.catalyst.analysis.{
  AnsiTypeCoercion,
  CollationTypeCoercion,
  TypeCoercion
}
import org.apache.spark.sql.catalyst.expressions.{Alias, Expression, OuterReference, SubExprUtils}
import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateExpression
import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, Sort}
import org.apache.spark.sql.catalyst.util.toPrettySQL
import org.apache.spark.sql.errors.QueryCompilationErrors

/**
 * A resolver for [[AggregateExpression]]s which are introduced while resolving an
 * [[UnresolvedFunction]]. It is responsible for the following:
 *  - Handling of the exceptions related to [[AggregateExpressions]].
 *  - Updating the [[ExpressionResolver.expressionResolutionContextStack]].
 *  - Applying type coercion rules to the [[AggregateExpressions]]s children. This is the only
 *    resolution that we apply here as we already resolved the children of [[AggregateExpression]]
 *    in the [[FunctionResolver]].
 */
class AggregateExpressionResolver(
    operatorResolver: Resolver,
    expressionResolver: ExpressionResolver,
    timezoneAwareExpressionResolver: TimezoneAwareExpressionResolver)
    extends TreeNodeResolver[AggregateExpression, Expression]
    with ResolvesExpressionChildren {
  private val typeCoercionTransformations: Seq[Expression => Expression] =
    if (conf.ansiEnabled) {
      AggregateExpressionResolver.ANSI_TYPE_COERCION_TRANSFORMATIONS
    } else {
      AggregateExpressionResolver.TYPE_COERCION_TRANSFORMATIONS
    }

  private val typeCoercionResolver: TypeCoercionResolver =
    new TypeCoercionResolver(timezoneAwareExpressionResolver, typeCoercionTransformations)

  private val expressionResolutionContextStack =
    expressionResolver.getExpressionResolutionContextStack
  private val subqueryRegistry = operatorResolver.getSubqueryRegistry
  private val traversals = expressionResolver.getExpressionTreeTraversals
  private val autoGeneratedAliasProvider = new AutoGeneratedAliasProvider(
    expressionResolver.getExpressionIdAssigner
  )

  /**
   * Resolves the given [[AggregateExpression]]:
   *  - Apply type coercion rules;
   *  - Validate the [[AggregateExpression]]:
   *   1. Nested aggregate functions are not allowed;
   *   2. Nondeterministic expressions in the subtree of a related aggregate function are not
   *      allowed;
   *   3. The mix of outer and local references is not allowed.
   *  - Update the [[ExpressionResolver.expressionResolutionContextStack]];
   *  - Handle the outer aggregate expression in a special way (see
   *    [[handleOuterAggregateExpression]]).
   */
  override def resolve(aggregateExpression: AggregateExpression): Expression = {
    val expressionResolutionContext = expressionResolutionContextStack.peek()

    val aggregateExpressionWithTypeCoercion =
      withResolvedChildren(aggregateExpression, typeCoercionResolver.resolve _)
        .asInstanceOf[AggregateExpression]

    validateResolvedAggregateExpression(aggregateExpressionWithTypeCoercion)

    expressionResolutionContext.hasAggregateExpressions = true

    // There are two different cases that we handle regarding the value of the flag:
    //
    //   - We have an attribute under an `AggregateExpression`:
    //       {{{ SELECT COUNT(col1) FROM VALUES (1); }}}
    //     In this case, value of the `hasAttributeOutsideOfAggregateExpressions` flag should be
    //     `false` as it indicates whether there is an attribute in the subtree that's not
    //     `AggregateExpression` so we can throw the `MISSING_GROUP_BY` exception appropriately.
    //
    //   - In the following example:
    //       {{{ SELECT COUNT(*), col1 + 1 FROM VALUES (1); }}}
    //     It would be `true` as described above.
    expressionResolutionContext.hasAttributeOutsideOfAggregateExpressions = false

    if (expressionResolutionContext.hasOuterReferences) {
      handleOuterAggregateExpression(aggregateExpressionWithTypeCoercion)
    } else {
      traversals.current.parentOperator match {
        case Sort(_, _, aggregate: Aggregate, _) =>
          handleAggregateExpressionInSort(aggregateExpressionWithTypeCoercion, aggregate)
        case other =>
          aggregateExpressionWithTypeCoercion
      }
    }
  }

  private def validateResolvedAggregateExpression(
      aggregateExpression: AggregateExpression): Unit = {
    if (expressionResolutionContextStack.peek().hasAggregateExpressions) {
      throwNestedAggregateFunction(aggregateExpression)
    }

    val nonDeterministicChild =
      aggregateExpression.aggregateFunction.children.collectFirst {
        case child if !child.deterministic => child
      }
    if (nonDeterministicChild.nonEmpty) {
      throwAggregateFunctionWithNondeterministicExpression(
        aggregateExpression,
        nonDeterministicChild.get
      )
    }
  }

  /**
   * If the [[AggregateExpression]] has outer references in its subtree, we need to handle it in a
   * special way. The whole process is explained in the [[SubqueryScope]] scaladoc, but in short
   * we need to:
   *  - Validate that we don't have local references in this subtree;
   *  - Create a new subtree without [[OuterReference]]s;
   *  - Alias this subtree and put it inside the current [[SubqueryScope]];
   *  - If outer aggregates are allowed, replace the [[AggregateExpression]] with an
   *    [[OuterReference]] to the auto-generated [[Alias]] that we created. This alias will later
   *    be injected into the outer [[Aggregate]]; We store the name that needs to be used for the
   *    [[OuterReference]] in [[OuterReference.SINGLE_PASS_SQL_STRING_OVERRIDE]] computed based on
   *    the [[AggregateExpression]] without [[OuterReference]] pulled out.
   *  - In case we have an [[AggregateExpression]] inside a [[Sort]] operator, we need to handle it
   *    in a special way (see [[handleAggregateExpressionInSort]] for more details).
   *  - Return the original [[AggregateExpression]] otherwise. This is done to stay compatible
   *    with the fixed-point Analyzer - a proper exception will be thrown later by
   *    [[ValidateSubqueryExpression]].
   */
  private def handleOuterAggregateExpression(
      aggregateExpression: AggregateExpression): Expression = {
    if (expressionResolutionContextStack.peek().hasLocalReferences) {
      throw QueryCompilationErrors.mixedRefsInAggFunc(
        aggregateExpression.sql,
        aggregateExpression.origin
      )
    }

    val resolvedOuterAggregateExpression =
      if (subqueryRegistry.currentScope.isOuterAggregateAllowed) {
        val aggregateExpressionWithStrippedOuterReferences =
          SubExprUtils.stripOuterReference(aggregateExpression)

        val outerAggregateExpressionAlias = autoGeneratedAliasProvider.newOuterAlias(
          child = aggregateExpressionWithStrippedOuterReferences
        )
        subqueryRegistry.currentScope.addOuterAggregateExpression(
          outerAggregateExpressionAlias,
          aggregateExpressionWithStrippedOuterReferences
        )

        OuterReference(outerAggregateExpressionAlias.toAttribute)
      } else {
        aggregateExpression
      }

    resolvedOuterAggregateExpression match {
      case outerReference: OuterReference =>
        outerReference.setTagValue(
          OuterReference.SINGLE_PASS_SQL_STRING_OVERRIDE,
          toPrettySQL(aggregateExpression)
        )
        outerReference
      case other => other
    }
  }

  /**
   * If we order by an [[AggregateExpression]] which is not present in the [[Aggregate]] operator
   * (child of the [[Sort]]) we have to extract it (by adding it to the
   * `extractedAggregateExpressionAliases` list of the current expression tree traversal) and add
   * it to the [[Aggregate]] operator afterwards (this is done in the [[SortResolver]]).
   */
  private def handleAggregateExpressionInSort(
      aggregateExpression: Expression,
      aggregate: Aggregate): Expression = {
    val aliasChildToAliasInAggregateExpressions = new IdentityHashMap[Expression, Alias]
    val aggregateExpressionsSemanticComparator = new SemanticComparator(
      aggregate.aggregateExpressions.collect {
        case alias: Alias =>
          aliasChildToAliasInAggregateExpressions.put(alias.child, alias)
          alias.child
      }
    )

    val referencedAggregateExpression =
      aggregateExpressionsSemanticComparator.collectFirst(aggregateExpression)

    referencedAggregateExpression match {
      case Some(expression) =>
        aliasChildToAliasInAggregateExpressions.get(expression) match {
          case null =>
            throw SparkException.internalError(
              s"No parent alias for expression $expression while extracting aggregate" +
              s"expressions in Sort operator."
            )
          case alias: Alias => alias.toAttribute
        }
      case None =>
        val alias = autoGeneratedAliasProvider.newAlias(child = aggregateExpression)
        traversals.current.extractedAggregateExpressionAliases.add(alias)
        alias.toAttribute
    }
  }

  private def throwNestedAggregateFunction(aggregateExpression: AggregateExpression): Nothing = {
    throw new AnalysisException(
      errorClass = "NESTED_AGGREGATE_FUNCTION",
      messageParameters = Map.empty,
      origin = aggregateExpression.origin
    )
  }

  private def throwAggregateFunctionWithNondeterministicExpression(
      aggregateExpression: AggregateExpression,
      nonDeterministicChild: Expression): Nothing = {
    throw new AnalysisException(
      errorClass = "AGGREGATE_FUNCTION_WITH_NONDETERMINISTIC_EXPRESSION",
      messageParameters = Map("sqlExpr" -> toSQLExpr(aggregateExpression)),
      origin = nonDeterministicChild.origin
    )
  }
}

object AggregateExpressionResolver {
  // Ordering in the list of type coercions should be in sync with the list in [[TypeCoercion]].
  private val TYPE_COERCION_TRANSFORMATIONS: Seq[Expression => Expression] = Seq(
    CollationTypeCoercion.apply,
    TypeCoercion.InTypeCoercion.apply,
    TypeCoercion.FunctionArgumentTypeCoercion.apply,
    TypeCoercion.IfTypeCoercion.apply,
    TypeCoercion.ImplicitTypeCoercion.apply
  )

  // Ordering in the list of type coercions should be in sync with the list in [[AnsiTypeCoercion]].
  private val ANSI_TYPE_COERCION_TRANSFORMATIONS: Seq[Expression => Expression] = Seq(
    CollationTypeCoercion.apply,
    AnsiTypeCoercion.InTypeCoercion.apply,
    AnsiTypeCoercion.FunctionArgumentTypeCoercion.apply,
    AnsiTypeCoercion.IfTypeCoercion.apply,
    AnsiTypeCoercion.ImplicitTypeCoercion.apply
  )
}
