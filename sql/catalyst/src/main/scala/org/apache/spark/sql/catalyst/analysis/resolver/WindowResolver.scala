/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.spark.sql.catalyst.analysis.resolver

import java.util.{ArrayList, HashMap}

import scala.collection.mutable.{ArrayBuffer, LinkedHashMap}
import scala.jdk.CollectionConverters._

import org.apache.spark.SparkException
import org.apache.spark.sql.catalyst.analysis.{AnalysisErrorAt, WindowResolution}
import org.apache.spark.sql.catalyst.analysis.resolver.WindowTypedefs.{
  WindowExpressionAliasesWithSpecId,
  WindowSpec
}
import org.apache.spark.sql.catalyst.expressions.{
  Alias,
  Expression,
  NamedExpression,
  SortOrder,
  WindowExpression,
  WindowFunctionType,
  WindowSpecDefinition
}
import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, LogicalPlan, Project, Window}
import org.apache.spark.sql.errors.QueryCompilationErrors

/**
 * Creates a series of [[Window]] operators corresponding to different window specifications.
 * This resolver is also responsible for building [[Window]] operator's source operator.
 */
class WindowResolver(expressionResolver: ExpressionResolver)
    extends CollectsWindowSourceExpressions {
  protected val windowResolutionContextStack = expressionResolver.getWindowResolutionContextStack
  private val autoGeneratedAliasProvider = expressionResolver.getAutoGeneratedAliasProvider
  private type Spec = (Seq[Expression], Seq[SortOrder], WindowFunctionType)

  /**
   * Builds and validates the [[Window]] operator.
   *
   * 1. [[extractWindowLayers]] builds window project list and source operator project list at each
   *    window expression nestedness level. It also returns the source operator's project list.
   * 2. Create the child operator for handling source expressions using original input operator and
   *    the expression list produced in the previous step.
   * 3. [[buildWindows]] creates the final [[Window]] plan by building [[Window]] operator chains
   *    for each window expression nestedness level on top of the source operator.
   * 4. Validate the final [[Window]] plan for unsupported constructs:
   *    - Correlated [[ScalarSubquery]] is unsupported in [[Window]], for example the analysis
   *      should fail for the following query:
   *
   *      {{{ SELECT RANK() OVER (ORDER BY col1), (SELECT col1) FROM VALUES 1, 2; }}}
   */
  def buildWindow(
      originalOperator: LogicalPlan,
      sourceOperatorChild: LogicalPlan,
      originalOutputList: Seq[NamedExpression],
      hasCorrelatedScalarSubqueryExpressions: Boolean): (Window, LogicalPlan) = {
    val (windowLayers, sourceProjectList) = extractWindowLayers(originalOutputList)

    val sourceOperator = originalOperator match {
      case project: Project =>
        project.copy(
          projectList = sourceProjectList,
          child = sourceOperatorChild
        )
      case aggregate: Aggregate =>
        aggregate.copy(
          aggregateExpressions = sourceProjectList,
          child = sourceOperatorChild
        )
      case other =>
        throw SparkException.internalError(
          s"Building a Window in unexpected operator ${other.getClass.getSimpleName}"
        )
    }

    val window = buildWindows(sourceOperator, windowLayers)

    validateWindow(window, hasCorrelatedScalarSubqueryExpressions)

    (window, sourceOperator)
  }

  /**
   * Extracts window expressions and creates specification maps and project lists at each window
   * expression nestedness level by invoking [[transformProjectList]]. Returns the sequence of
   * window layers and the final source operator's project list.
   *
   * In this query:
   *
   * {{{
   * SELECT
   *   SUM(col1), SUM(col1) OVER (PARTITION BY SUM(col2) OVER ()), SUM(col2) OVER (ORDER BY col2)
   * FROM VALUES (1, 2)
   * GROUP BY col1, col2;
   * }}}
   *
   * There are two window expression nestedness levels:
   *  - Level 0 (expressions which are not nested in window specification):
   *     [
   *      `SUM(col1)`,
   *      `SUM(col1) OVER (PARTITION BY SUM(col2) OVER ())`,
   *      `SUM(col2) OVER (ORDER BY col2)`
   *     ]
   *  - Level 1 (expressions nested in window specification): [`SUM(col2) OVER ()`]
   *
   * Source project list at each nestedness level:
   *  - Level 0: [`SUM(col1) as SUM(col1)`, `col1`, `SUM(col2) OVER () as _w0`, `col2`]
   *  - Level 1: [`SUM(col1) as SUM(col1)`, `col1`, `col2`]
   *
   * Window project list at each nestedness level:
   *  - Level 0: [
   *              `SUM(col1)`,
   *              `SUM(col1) OVER (PARTITION BY _w0)`,
   *              `_we_1_0`
   *             ]
   *  - Level 1: [
   *              `SUM(col1)`,
   *              `col1`,
   *              `SUM(col2) OVER () as _w0`,
   *              `col2`
   *             ]
   *
   * Each window expression in this query corresponds to a unique window spec:
   *  - Level 0: [
   *              `SUM(col1) OVER (PARTITION BY SUM(col2) OVER ())`,
   *              `SUM(col2) OVER (ORDER BY col2)`
   *             ]
   *  - Level 1: [`SUM(col2) OVER ()`]
   *
   * `currentProjectList` stores the value of source project list at each iteration. Its final
   * value in the example query is: [SUM(col1) as SUM(col1)`, `col1`, `col2`].
   */
  private def extractWindowLayers(originalOutputList: Seq[NamedExpression])
      : (Seq[TransformedWindowProjectList], Seq[NamedExpression]) = {
    val windowLayers = new ArrayBuffer[TransformedWindowProjectList]()
    var currentProjectList = originalOutputList
    var hasWindowExpressions = true

    while (hasWindowExpressions) {
      val transformedWindowProjectList = transformProjectList(currentProjectList)
      windowLayers.append(transformedWindowProjectList)
      currentProjectList = transformedWindowProjectList.sourceProjectList
      hasWindowExpressions = transformedWindowProjectList.hasNestedWindowExpressions
    }

    (windowLayers.toSeq, currentProjectList)
  }

  /**
   * Records all unique window specifications, creates a source expression list and transforms the
   * project list of the parent operator (which will later be used by the newly created parent
   * [[Window]] operator) by replacing expressions which are projected by source operator with
   * appropriate attributes.
   *
   * Validates `specificationMap` after transformation:
   * - Throw an exception if no window specification is found. This error occurs if a
   *   [[WindowExpression]] appears inside [[AggregateExpression]] (SC-7712/SC-11132/SPARK-21896).
   *
   * Consider the following example:
   *
   * {{{
   * SELECT
   * SUM(1 + SUM(col1)) OVER (PARTITION BY ABS(col2 + col3))
   * FROM
   * VALUES (1, 2, 1), (3, -2, 1), (0, 1, 1)
   * GROUP BY col2 + col3
   * }}}
   *
   * The final analyzed plan will consist of two operators - a [[Window]] and a source
   * [[Aggregate]]:
   *
   * Window [sum((1 + _w1#4)) windowspecdefinition(abs(_w0#3), ...)#5], [abs(_w0#3)]
   * +- Aggregate [(col2#1 + col3#2)], [(col2#1 + col3#2) AS _w0#3, sum(col1#0) as _w1#4]
   *
   * [[Window]] should reference expressions handled by the [[Aggregate]].
   *
   * In general [[Aggregate]] expression list can contain attribute references, aggregate
   * expressions (and their aliases), as well as its grouping expressions. Since there can be
   * complex non-aliased expressions coming from `GROUP BY` (e.g. col2 + col3), [[Aggregate]]
   * should provide internal aliases for them so that [[Window]] can reference them.
   *
   * Here's another example involving multiple [[Window]] operators in [[Project]]:
   *
   * {{{
   * SELECT
   * SUM(col1) OVER() + SUM(col1) OVER(ORDER BY col1)
   * FROM
   * VALUES (1, 2);
   * }}}
   *
   * The final analyzed plan will consist of three operators - two [[Window]]s (one for each
   * spec) and a [[Project]] for all the attribute occurrences. For clarity regarding the
   * structure of the analyzed plan refer to [[buildIntermediateWindows]].
   *
   * Window[...]
   * +- Window[...]
   *    +- Project[col1#0]
   *
   * The top [[Window]] operator should reference attributes of expressions handled by the
   * [[Project]], as well as the child window expressions.
   *
   * In this particular example, we will replace `SUM(col1) OVER(ORDER BY col1)` with
   * `_we_1_0#1`, as this particular [[WindowExpression]] will be assigned a new alias
   * using [[WindowResolver.replaceWindowExpression]]. Additionally, all occurrences of
   * `col1` will be replaced by `col1#0`.
   */
  private def transformProjectList(
      projectList: Seq[NamedExpression]): TransformedWindowProjectList = {
    val windowSourceExpressions = getWindowSourceExpressionsSemanticComparator()
    val specificationMap = LinkedHashMap.empty[WindowSpec, WindowExpressionAliasesWithSpecId]
    val sourceProjectList = new ArrayList[NamedExpression]()
    val expressionReplacementMap = new HashMap[Expression, NamedExpression]()
    var hasNestedWindowExpressions = false

    val windowBuildContext = WindowBuildContext(
      windowSourceExpressions = windowSourceExpressions,
      specificationMap = specificationMap,
      sourceProjectList = sourceProjectList,
      expressionReplacementMap = expressionReplacementMap
    )

    val transformedProjectList = projectList.map(
      expression => {
        val transformedWindowExpressionResult = transformExpression(
          expression = expression,
          windowBuildContext = windowBuildContext
        )
        hasNestedWindowExpressions |= transformedWindowExpressionResult.hasNestedWindowExpressions
        transformedWindowExpressionResult.expression.asInstanceOf[NamedExpression]
      }
    )

    if (specificationMap.isEmpty) {
      throw QueryCompilationErrors.windowFunctionInsideAggregateFunctionNotAllowedError()
    }

    TransformedWindowProjectList(
      specificationMap = specificationMap,
      windowProjectList = transformedProjectList,
      sourceProjectList = sourceProjectList.asScala.toSeq,
      hasNestedWindowExpressions = hasNestedWindowExpressions
    )
  }

  /**
   * Transforms an expression by recursively transforming its expression tree in post-order
   * traversal.
   *
   * - If expression's canonicalized form is present in `windowSourceExpressions`, it will be
   *   projected by a source child operator. Therefore, it should be replaced with an attribute by
   *   calling [[replaceSourceExpressionWithAttribute]]. Once we replace the expression with
   *   attribute, the recursion terminates.
   * - If expression is a window expression, transform it using `transformWindowExpression` and
   *   replace it using [[WindowResolution.replaceWindowExpression]].
   * - If expression is a window expression alias, perform analogous logic to the previous case,
   *   taking the alias into account.
   * - In all other cases, transform the children expressions recursively and return new expression
   *   with replaced children.
   *
   * Consider the following query:
   *
   * {{{
   * SELECT
   * SUM(SUM(col1)) OVER (),
   * (1 + MAX(SUM(col1)) OVER (ORDER BY col2))
   * FROM VALUES (1, 2)
   * GROUP BY col2;
   * }}}
   *
   * Parsed plan will contain this aggregate:
   *
   * 'Aggregate ['col2],
   *            [unresolvedalias('SUM('SUM('col1)) windowspecdefinition(...)),
   *            unresolvedalias((1 + 'MAX('SUM('col1)) windowspecdefinition('col2 ...)))]
   *
   * The final analyzed plan should include two [[Window]] operators (one for each spec definition)
   * and a source [[Aggregate]].
   *
   * Window [sum(_w0#2) windowspecdefinition(...) AS ...#4,
   *        (cast(1 as bigint) + _we_1_0#3) AS ...#5]
   * +- Window [_w0#2, col2#1, max(_w0#3) windowspecdefinition(col2#1 ...) AS _we_1_0#3],
   *           [col2#1 ASC NULLS FIRST]
   *    +- Aggregate [col2#1], [sum(col1#0) AS _w0#2, col2#1]
   *
   * The window expressions which do not match the first unique specification (in the pre-order
   * traversal) are going to be replaced by attributes in the window project list, leading to loss
   * of information about their expression trees (in this case `MAX(SUM(col1)) OVER (ORDER BY col2)`
   * is replaced by `_we_1_0`). In order to correctly extract its children source expressions, we
   * first process the children and then perform the window expression replacement. For this
   * particular case, it would mean processing `col2` and `SUM(col1)` and adding them to the
   * aggregate expression list before replacing `MAX(SUM(col1)) OVER (ORDER BY col2)` by `_we_1_0`.
   *
   * The method returns the transformed expression and a flag indicating whether the there are any
   * nested windows in the expression tree.
   */
  private def transformExpression(
      expression: Expression,
      windowBuildContext: WindowBuildContext): TransformedWindowExpressionResult = {
    var hasNestedWindowExpressions = false

    val transformedExpression = expression match {
      case expression
          if windowBuildContext.windowSourceExpressions.exists(expression.canonicalized) =>
        val transformedWindowExpressionResult = replaceSourceExpressionWithAttribute(
          expression = expression,
          sourceProjectList = windowBuildContext.sourceProjectList,
          expressionReplacementMap = windowBuildContext.expressionReplacementMap
        )
        hasNestedWindowExpressions = transformedWindowExpressionResult.hasNestedWindowExpressions
        transformedWindowExpressionResult.expression
      case alias @ Alias(windowExpression: WindowExpression, _) =>
        val transformedWindowExpressionResult = transformWindowExpression(
          windowExpression = windowExpression,
          windowBuildContext = windowBuildContext
        )
        hasNestedWindowExpressions = transformedWindowExpressionResult.hasNestedWindowExpressions
        val transformedWindowExpression =
          transformedWindowExpressionResult.expression.asInstanceOf[WindowExpression]
        val aliasWithTransformedChild =
          alias.withChild(transformedWindowExpression)
        WindowResolution.replaceWindowExpression(
          windowExpression = transformedWindowExpression,
          aliasOption = Some(aliasWithTransformedChild),
          specificationMap = windowBuildContext.specificationMap,
          aliasProvider = (windowExpression, name) =>
            autoGeneratedAliasProvider.newAlias(child = windowExpression, name = Some(name))
        )
      case windowExpression: WindowExpression =>
        val transformedWindowExpressionResult = transformWindowExpression(
          windowExpression = windowExpression,
          windowBuildContext = windowBuildContext
        )
        hasNestedWindowExpressions = transformedWindowExpressionResult.hasNestedWindowExpressions
        val transformedWindowExpression =
          transformedWindowExpressionResult.expression.asInstanceOf[WindowExpression]
        WindowResolution.replaceWindowExpression(
          windowExpression = transformedWindowExpression,
          aliasOption = None,
          specificationMap = windowBuildContext.specificationMap,
          aliasProvider = (windowExpression, name) =>
            autoGeneratedAliasProvider.newAlias(child = windowExpression, name = Some(name))
        )
      case expression: Expression =>
        val transformedChildren = expression.children.map(
          child => {
            val transformedWindowExpressionResult = transformExpression(
              expression = child,
              windowBuildContext = windowBuildContext
            )
            hasNestedWindowExpressions |=
            transformedWindowExpressionResult.hasNestedWindowExpressions
            transformedWindowExpressionResult.expression
          }
        )
        expression.withNewChildren(transformedChildren)
    }

    TransformedWindowExpressionResult(
      expression = transformedExpression,
      hasNestedWindowExpressions = hasNestedWindowExpressions
    )
  }

  /**
   * Adds an expression (or its internal replacement alias) to the `sourceProjectList` and returns
   * its attribute reference.
   *
   * Internal aliases are generated following the naming convention `_w{i}`, where `i` represents
   * the ordinal position of the expression in the post-order tree traversal to stay consistent with
   * fixed-point alias naming.
   *
   * This method is invoked in [[transformExpression]] which traverses the expression list in the
   * same order as `collect` method in fixed-point analyzer. To retain the correct alias naming
   * order, alias creation is handled here and not during the window source expression collection.
   *
   * This is necessary because collection is divided into two phases:
   *
   * - Attribute and aggregate expression collection during resolution.
   * - Grouping expression collection after the aggregate expression list has been fully resolved.
   *
   * For example in the following case:
   *
   * {{{
   * SELECT col1 + col2, col1, (1 + SUM(SUM(col3)) OVER ())
   * FROM VALUES (1, 2, 3)
   * GROUP BY col1, col1 + col2;
   * }}}
   *
   * Fixed-point analyzer assigns these aliases:
   *
   * - `col1 + col2` becomes `_w0`.
   * - `col1` becomes `_w1`.
   * - `SUM(col3)` becomes `_w2`.
   *
   * On the other hand, if we aliased the expressions in the order of their collection:
   *
   * - `col1` becomes `_w0`.
   * - `SUM(col3)` becomes `_w1`
   * - `col1 + col2` becomes `_w2`
   *
   * 1. Replacement:
   *     1. Check if expression is already aliased (true if it is present in
   *        `expressionReplacementMap`);
   *     2. If it is not already aliased, create its replacement alias and add it to
   *        `sourceProjectList`:
   *         - [[NamedExpression]]s are kept unchanged.
   *         - For other expressions, create an internal alias and put it in
   *           `expressionReplacementMap`.
   * 2. Set `hasNestedWindowExpression` to `true` if original expression is [[WindowExpression]] or
   *    it's an alias of a [[WindowExpression]]. We do this because in [[WindowExpressionResolver]]
   *    only nested window expressions need to be collected as source expressions.
   * 3. Return the `expressionReplacement` attribute reference and `hasNestedWindowExpression`.
   */
  private def replaceSourceExpressionWithAttribute(
      expression: Expression,
      sourceProjectList: ArrayList[NamedExpression],
      expressionReplacementMap: HashMap[Expression, NamedExpression])
      : TransformedWindowExpressionResult = {
    val canonicalizedExpression = expression.canonicalized

    val expressionReplacement =
      if (expressionReplacementMap.containsKey(canonicalizedExpression)) {
        expressionReplacementMap.get(canonicalizedExpression)
      } else {
        val replacementAlias = expression match {
          case namedExpression: NamedExpression =>
            namedExpression
          case expression =>
            autoGeneratedAliasProvider.newAlias(
              child = expression,
              name = Some(s"_w${sourceProjectList.size()}")
            )
        }
        expressionReplacementMap.put(canonicalizedExpression, replacementAlias)
        sourceProjectList.add(replacementAlias)
        replacementAlias
      }

    val hasNestedWindowExpression = expression match {
      case _: WindowExpression => true
      case _ @Alias(_: WindowExpression, _) => true
      case _ => false
    }

    TransformedWindowExpressionResult(
      expression = expressionReplacement.toAttribute,
      hasNestedWindowExpressions = hasNestedWindowExpression
    )
  }

  /**
   * Transforms window expression by transforming its children in a specific order.
   *
   * 1. Transform window spec using `transformExpression`.
   * 2. Transform window function by transforming each of its children using `transformExpression`.
   *    It's important to skip window function itself, and not apply transformations on it, because
   *    it is explicitly skipped during the collection process. Consider the following query:
   *
   *    {{{ SELECT (1 + SUM(col1)), SUM(col1) OVER () FROM VALUES 1 GROUP BY col1; }}}
   *
   *    `SUM(col1)` is collected as a source expression because it is a non-window function
   *    aggregate expression. For additional context refer to
   *    [[AggregateExpressionResolver.handleAggregateExpressionWithChildrenResolved]]. Therefore,
   *    window function `SUM(col1)` in `SUM(col1) OVER ()` is present in `windowSourceExpressions`.
   *    If we invoked `transformExpression` on it, it would get an internal replacement alias and
   *    query would fail with `UNSUPPORTED_EXPR_FOR_WINDOW` exception:
   *
   *    Window [(cast(1 as bigint) + _w0#1) ..., _w0#1 windowspecdefinition... AS ...#2]
   *    +- Aggregate [col1#0], [sum(col1#0) AS _w0#1, col1#0]
   *
   *    The proper behavior should be analogous to this query:
   *
   *    {{{ SELECT SUM(col1), SUM(col1) OVER () FROM VALUES 1 GROUP BY col1; }}}
   *
   *    Analyzed plan:
   *
   *    Window [sum(col1)#1, sum(col1#0) windowspecdefinition... AS ...#2]
   *    +- Aggregate [col1#0], [sum(col1#0) AS sum(col1)#1, col1#0]
   *
   *    Correct analyzed plan for the original query:
   *
   *    Window [(cast(1 as bigint) + _w0#1) ..., sum(col1#0) windowspecdefinition... AS ...#2]
   *    +- Aggregate [col1#0], [sum(col1#0) AS _w0#1, col1#0]
   *
   * The order of transformation matters to stay compatible with fixed-point, because internal
   * aliases must match so we can't apply generic `transformExpression`.
   *
   * Consider the following query:
   *
   * {{{
   *   SELECT
   *     SUM(SUM(col1)) OVER (PARTITION BY col1 + 1)
   *   FROM VALUES 1
   *   GROUP BY col1, col1 + 1;
   * }}}
   *
   * If we delegated the transformation of [[WindowExpression]] to `transformExpression`, final
   * analyzed plan would look like this, because we would first transform the function and then
   * the spec:
   *
   * Window [sum(_w0#2) windowspecdefinition(_w1#3, ...) AS ...#4], [_w1#3]
   * +- Aggregate [col1#0, _groupingexpression#1],
   *              [sum(col1#0) AS _w0#2, _groupingexpression#1 AS _w1#3]
   *
   * In fixed-point, the order of spec and function transformation is swapped, so we get:
   *
   * Window [sum(_w1#3) windowspecdefinition(_w0#2, ...) AS ...#4], [_w0#2]
   * +- Aggregate [col1#0, _groupingexpression#1],
   *              [_groupingexpression#1 AS _w0#2, sum(col1#0) AS _w1#3]
   */
  private def transformWindowExpression(
      windowExpression: WindowExpression,
      windowBuildContext: WindowBuildContext): TransformedWindowExpressionResult = {
    var hasNestedWindowExpressions = false

    val transformedWindowSpecResult = transformExpression(
      expression = windowExpression.windowSpec,
      windowBuildContext = windowBuildContext
    )
    hasNestedWindowExpressions |= transformedWindowSpecResult.hasNestedWindowExpressions

    val transformedWindowSpec =
      transformedWindowSpecResult.expression.asInstanceOf[WindowSpecDefinition]

    val transformedWindowFunctionChildren = windowExpression.windowFunction.children.map(
      child => {
        val transformedWindowExpressionResult = transformExpression(
          expression = child,
          windowBuildContext = windowBuildContext
        )
        hasNestedWindowExpressions |= transformedWindowExpressionResult.hasNestedWindowExpressions
        transformedWindowExpressionResult.expression
      }
    )

    val transformedWindowFunction = windowExpression.windowFunction.withNewChildren(
      transformedWindowFunctionChildren
    )

    val transformedWindowExpression = windowExpression.copy(
      windowFunction = transformedWindowFunction,
      windowSpec = transformedWindowSpec
    )

    TransformedWindowExpressionResult(
      expression = transformedWindowExpression,
      hasNestedWindowExpressions = hasNestedWindowExpressions
    )
  }

  /**
   * Builds the [[Window]] plan by constructing [[Window]] chains for each window expression
   * nestedness layer:
   *
   * 1. [[buildIntermediateWindows]] creates a chain of intermediate [[Window]] operators, for
   *    cases when layer contains multiple distinct window specifications.
   * 2. Create the final [[Window]] on top of all intermediate [[Window]] operators. This operator
   *    is handled separately because its project list needs to retain the same output schema as the
   *    operator it is replacing. Consider this example:
   *
   *    {{{ SELECT (1 + RANK() OVER (ORDER BY col1)) FROM VALUES 1, 2; }}}
   *
   *    The final analyzed plan should look like this:
   *
   *    Window [1 + rank(col1#0) windowspecdefinition(...)#1], [col1#0 ASC NULLS FIRST]
   *    +- Project [col1#0]
   *
   *    If we constructed it like we construct the intermediate windows, we would only copy
   *    project list of the child, so `1 + rank(col1#0)` would be missing.
   *
   *    Let's look at another query having multiple specs to demonstrate the difference when there
   *    are intermediate windows:
   *
   *    {{{
   *    SELECT
   *      SUM(x) OVER () +
   *      SUM(x) OVER (ORDER BY x) +
   *      SUM(x) OVER (ORDER BY x DESC)
   *    FROM t;
   *    }}}
   *
   *    Here's what the plan would look like if we constructed the final operator like the
   *    intermediate ones:
   *
   *    Window [x#0, _we_1_0#1, _we_2_0#2, sum(x#0) ...#3]
   *    +- Window [x#0, _we_1_0#1, sum(x#0) ... AS _we_2_0#2] [x#0 DESC NULLS LAST]
   *       +- Window [x#0, sum(x#0) ... AS _we_1_0#1] [x#0 ASC NULLS FIRST]
   *          +- Project [x#0]
   *
   *    This plan's output schema is different from that of the original [[Project]]. The
   *    correct plan would then be:
   *
   *    Window [((sum(x#0) ... + _we_1_0#1) + _we_2_0#2) AS ...#3]
   *    +- Window [x#0, _we_1_0#1, sum(x#0) ... AS _we_2_0#2] [x#0 DESC NULLS LAST]
   *       +- Window [x#0, sum(x#0) ... AS _we_1_0#1] [x#0 ASC NULLS FIRST]
   *          +- Project [x#0]
   *
   * We may have intermediate [[Window]]s at each nestedness level. Consider this query:
   *
   * {{{
   * SELECT
   *   SUM(col1) OVER (ORDER BY (SUM(col1) OVER () + SUM(col1) OVER (ORDER BY col1)))
   * FROM VALUES 1;
   * }}}
   *
   * There's only one top-level window expression, so there is a single window spec at its level.
   * At the second (and last) nestedness level there are two distinct specs. Therefore, there are
   * three distinct specs: 1 at first level, 2 at second level, meaning the final plan will
   * contain three [[Window]] operators:
   *
   * Window [sum(col1#0) windowspec((_w0#1 + _w1#2) ...) AS ...#3], [(_w0#1 + _w1#2) ...]
   * +- Window [sum(col1#0) windowspec(...)) AS _w0#1, _w1#2, col1#0]
   *    +- Window [col1#0, sum(col1#0) windowspec(col1#0 ...) AS _w1#2], [col1#0 ...]
   *       +- Project [col1#0]
   */
  private def buildWindows(
      sourceOperator: LogicalPlan,
      windowLayers: Seq[TransformedWindowProjectList]): Window = {
    windowLayers
      .foldRight(sourceOperator) { (layer, currentPlan) =>
        val currentOutputList = currentPlan match {
          case project: Project =>
            project.projectList
          case aggregate: Aggregate =>
            aggregate.aggregateExpressions
          case window: Window =>
            window.projectList
          case other =>
            throw SparkException.internalError(
              s"Building Window on top of unexpected type ${other.getClass.getSimpleName}"
            )
        }

        val planWithIntermediateWindows = buildIntermediateWindows(
          windowChild = currentPlan,
          sourceProjectList = currentOutputList.map(_.toAttribute),
          specificationMap = layer.specificationMap
        )

        val ((partitionSpec, orderSpec, _), _) = layer.specificationMap.head

        Window(
          projectList = layer.windowProjectList,
          partitionSpec = partitionSpec,
          orderSpec = orderSpec,
          child = planWithIntermediateWindows
        )
      }
      .asInstanceOf[Window]
  }

  /**
   * Builds a chain of intermediate [[Window]] operators, for cases when query contains multiple
   * distinct specifications. [[WindowExpression]]s with matching specifications all become part
   * of the same [[Window.projectList]]. For example:
   *
   * {{{
   * SELECT
   *   RANK() OVER (ORDER BY col1),
   *   RANK() OVER (ORDER BY col2),
   *   SUM(col1) OVER (ORDER BY col2),
   *   RANK() OVER (ORDER BY col2 DESC)
   * FROM VALUES (1, 2), (3, 4);
   * }}}
   *
   * In the described query the analyzed plan will contain three [[Window]] operators, corresponding
   * to the following unique specs:
   *  - (ORDER BY col1)
   *  - (ORDER BY col2)
   *  - (ORDER BY col2 DESC)
   *
   * In this step only [[Window]]s corresponding to all but the first spec are built, the first one
   * is handled differently in later step in [[planWindowsAndSourceExpressions]].
   *
   * The pattern for building parent window is as follows:
   * Parent project list contains union of the child project list and attribute references of window
   * expressions matching its particular specification. A general pattern of what the final plan
   * will look like if there are `n + 1` unique specifications:
   *
   * Window[attr1#, ..., we_n_0#, we_n_1#, ..., we_2_0#, ..., _we_1_0#, _we_1_1#, ..., _we_1_i#]
   * +- Window[attr1#, ..., we_n_0#, we_n#1, ..., we_2_0#, we_2_1#, ..., we_2_j#]
   *    +- ...
   *       +- Window[attr1#, ..., we_n_0#, we_n_1#, ..., we_n_k#]
   *          +- Project[attr1#, attr1#, ..., attr#l]
   *             +- ...
   *
   * @param windowChild The [[LogicalPlan]] placed below the bottom-most [[Window]] operator. It
   *                    can be a [[Project]], [[Aggregate]], or [[Window]].
   * @param specificationMap A map where each key is [[WindowSpecDefinition]] and the value is a
   *                          sequence of [[WindowExpression]]s that share that specification.
   */
  private def buildIntermediateWindows(
      windowChild: LogicalPlan,
      sourceProjectList: Seq[NamedExpression],
      specificationMap: LinkedHashMap[Spec, (Int, Seq[NamedExpression])]): LogicalPlan = {

    val allExpressions = ArrayBuffer[NamedExpression]()
    allExpressions ++= sourceProjectList.map(_.toAttribute)

    specificationMap.tail.foldLeft[LogicalPlan](windowChild) {
      case (plan, ((partitionSpec, orderSpec, _), (_, expressions))) =>
        val newPlan = Window(allExpressions.toSeq ++ expressions, partitionSpec, orderSpec, plan)
        allExpressions ++= expressions.map(_.toAttribute)
        newPlan
    }
  }

  private def validateWindow(
      window: Window,
      hasCorrelatedScalarSubqueryExpressions: Boolean): Unit = {
    if (hasCorrelatedScalarSubqueryExpressions) {
      window.failAnalysis(
        errorClass = "UNSUPPORTED_SUBQUERY_EXPRESSION_CATEGORY." +
          "UNSUPPORTED_CORRELATED_SCALAR_SUBQUERY_IN_WINDOW",
        messageParameters = scala.collection.immutable.Map("treeNode" -> window.toString)
      )
    }
  }
}
