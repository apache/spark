-- Automatically generated by SQLQueryTestSuite
-- !query
CREATE TEMPORARY VIEW tbl_view AS SELECT * FROM VALUES
  (10, 'name1', named_struct('f1', 1, 's2', named_struct('f2', 101, 'f3', 'a'))),
  (20, 'name2', named_struct('f1', 2, 's2', named_struct('f2', 202, 'f3', 'b'))),
  (30, 'name3', named_struct('f1', 3, 's2', named_struct('f2', 303, 'f3', 'c'))),
  (40, 'name4', named_struct('f1', 4, 's2', named_struct('f2', 404, 'f3', 'd'))),
  (50, 'name5', named_struct('f1', 5, 's2', named_struct('f2', 505, 'f3', 'e'))),
  (60, 'name6', named_struct('f1', 6, 's2', named_struct('f2', 606, 'f3', 'f'))),
  (70, 'name7', named_struct('f1', 7, 's2', named_struct('f2', 707, 'f3', 'g')))
AS tbl_view(id, name, data);
CREATE TABLE x (id INT) USING csv;

DECLARE sql_string STRING;
SET VAR sql_string = 'SELECT * from tbl_view where name = \'name1\'';

-- test commands
EXECUTE IMMEDIATE 'SET spark.sql.ansi.enabled=true';
EXECUTE IMMEDIATE 'CREATE TEMPORARY VIEW IDENTIFIER(:tblName) AS SELECT id, name FROM tbl_view' USING 'tbl_view_tmp' as tblName;
EXECUTE IMMEDIATE 'SELECT * FROM tbl_view_tmp';

EXECUTE IMMEDIATE 'REFRESH TABLE IDENTIFIER(:tblName)' USING 'x' as tblName;

-- test execute immediate without parameters
EXECUTE IMMEDIATE sql_string;
EXECUTE IMMEDIATE 'SELECT * from tbl_view where name = \'name1\'';

-- test positional parameters
SET VAR sql_string = 'SELECT * from tbl_view where name = ? or name = ?';
DECLARE a STRING;
SET VAR a = 'name1';
EXECUTE IMMEDIATE sql_string USING 'name1', 'name3';
EXECUTE IMMEDIATE sql_string USING a, 'name2';
EXECUTE IMMEDIATE 'SELECT * from tbl_view where name = ? or name = ?' USING 'name1', 'name3';
EXECUTE IMMEDIATE 'SELECT * from tbl_view where name = ? or name = ?' USING a, 'name2';
EXECUTE IMMEDIATE 'SELECT * from tbl_view where name = ? or name = ?' USING (a, 'name2');
-- test positional command
EXECUTE IMMEDIATE 'INSERT INTO x VALUES(?)' USING 1;
SELECT * from x;

-- test named parameters
SET VAR sql_string = 'SELECT * from tbl_view where name = :first or id = :second';
DECLARE b INT;
SET VAR b = 40;
EXECUTE IMMEDIATE sql_string USING 40 as second, 'name7' as first;
EXECUTE IMMEDIATE sql_string USING b as second, 'name7' as first;
EXECUTE IMMEDIATE 'SELECT * from tbl_view where name = :first or id = :second' USING 40 as second, 'name7' as first;
EXECUTE IMMEDIATE 'SELECT * from tbl_view where name = :first or id = :second' USING 'name7' as first, b as second;
-- named parameter used multiple times
EXECUTE IMMEDIATE 'SELECT tbl_view.*, :first as p FROM tbl_view WHERE name = :first' USING 'name7' as first;

-- test named command and setup for next test
EXECUTE IMMEDIATE 'SET VAR sql_string = ?' USING 'SELECT id from tbl_view where name = :first';
SELECT sql_string;

-- test into
DECLARE res_id INT;
EXECUTE IMMEDIATE sql_string INTO res_id USING 'name7' as first;
SELECT res_id;
EXECUTE IMMEDIATE sql_string INTO res_id USING a as first;
SELECT res_id;

-- test into without using
SET VAR sql_string = 'SELECT * from tbl_view where name = :first or id = :second';
EXECUTE IMMEDIATE 'SELECT 42' INTO res_id;
SELECT res_id;

-- multiple INTOs
EXECUTE IMMEDIATE 'SELECT id, name FROM tbl_view WHERE id = ?' INTO b, a USING 10;
SELECT b, a;

-- use AS for using positional params
EXECUTE IMMEDIATE 'SELECT * FROM tbl_view where id = ? AND name = ?' USING b as first, a;

-- empty query
EXECUTE IMMEDIATE 'SELECT 42 WHERE 2 = 1' INTO res_id;
SELECT res_id;

-- implicit casting
EXECUTE IMMEDIATE 'SELECT \'1707\'' INTO res_id;
SELECT res_id;

-- test errors
-- string to int error
EXECUTE IMMEDIATE 'SELECT \'invalid_cast_error_expected\'' INTO res_id;

-- require query when using INTO
EXECUTE IMMEDIATE 'INSERT INTO x VALUES (?)' INTO res_id USING 1;

-- use column in using - should fail as we expect variable here
EXECUTE IMMEDIATE 'SELECT * FROM tbl_view WHERE ? = id' USING id;

-- either positional or named parameters must be used
EXECUTE IMMEDIATE 'SELECT * FROM tbl_view where ? = id and :first = name' USING 1, 'name2' as first;

-- all paramerers must be named
EXECUTE IMMEDIATE 'SELECT * FROM tbl_view where :first = name' USING 1, 'name2' as first;

-- internal syntax error
EXECUTE IMMEDIATE 'SELCT Fa';

-- internal syntax error - test that both parseQuery and parsePlan fail
EXECUTE IMMEDIATE 'SELCT Fa' INTO res_id;

-- Parameter passed must be STRING
EXECUTE IMMEDIATE b;

-- test expressions should fail with parser error
SET VAR sql_string = 'SELECT * from tbl_view where name = :first or id = :second';
SET VAR a = 'na';

-- expressions not supported - feature not supported
EXECUTE IMMEDIATE 'SELECT * from tbl_view where name = :first' USING CONCAT(a , "me1") as first;
EXECUTE IMMEDIATE 'SELECT * from tbl_view where name = :first' USING (SELECT 42) as first, 'name2' as second;

-- INTO variables not matching scalar types
EXECUTE IMMEDIATE 'SELECT id, name FROM tbl_view WHERE id = ?' INTO a, b USING 10;

-- INTO does not support braces - parser error
EXECUTE IMMEDIATE 'SELECT id, name FROM tbl_view WHERE id = ?' INTO (a, b) USING 10;

-- Error too many rows
EXECUTE IMMEDIATE 'SELECT id FROM tbl_view' INTO res_id;

-- Error mismatch cardinality
EXECUTE IMMEDIATE 'SELECT id, data.f1 FROM tbl_view' INTO res_id;
EXECUTE IMMEDIATE 'SELECT id FROM tbl_view' INTO res_id, b;

-- duplicate aliases
EXECUTE IMMEDIATE 'SELECT id FROM tbl_view WHERE id = :first' USING 10 as first, 20 as first;

-- no alias
DECLARE p = 10;
EXECUTE IMMEDIATE 'SELECT id FROM tbl_view WHERE id = :p' USING p;

-- mixing literals and named parameters
EXECUTE IMMEDIATE 'SELECT id FROM tbl_view WHERE id = :p' USING p, 'p';

-- duplicate into entry
EXECUTE IMMEDIATE 'SELECT id, data.f1 FROM tbl_view WHERE id = 10' INTO res_id, res_id;

-- nested execute immediate
EXECUTE IMMEDIATE 'EXECUTE IMMEDIATE \'SELECT id FROM tbl_view WHERE id = ? USING 10\'';

-- sqlString is null
SET VAR sql_string = null;
EXECUTE IMMEDIATE sql_string;

-- =============================================================================
-- DDL STATEMENTS WITH PARAMETER MARKERS TESTS
-- =============================================================================

-- setup variables for DDL tests
DECLARE default_val INT;
SET VAR default_val = 42;

-- CREATE TABLE tests with parameter markers
EXECUTE IMMEDIATE 'CREATE TABLE test_table (id INT, name STRING DEFAULT :default_name, score INT DEFAULT :default_score) USING PARQUET' 
USING 'unknown' as default_name, default_val as default_score;
DESCRIBE EXTENDED test_table;

-- test positional parameters in CREATE TABLE
EXECUTE IMMEDIATE 'CREATE TABLE test_table2 (id INT, value INT DEFAULT ?) USING PARQUET' USING 100;
DESCRIBE EXTENDED test_table2;

-- ALTER TABLE tests with parameter markers
EXECUTE IMMEDIATE 'ALTER TABLE test_table ALTER COLUMN score SET DEFAULT :new_default' USING 99 as new_default;
DESCRIBE EXTENDED test_table;
EXECUTE IMMEDIATE 'ALTER TABLE test_table ADD COLUMN status STRING DEFAULT :status_default' USING 'active' as status_default;
DESCRIBE EXTENDED test_table;
-- test positional parameters in ALTER TABLE ADD COLUMN
EXECUTE IMMEDIATE 'ALTER TABLE test_table2 ADD COLUMN flag BOOLEAN DEFAULT ?' USING true;
DESCRIBE EXTENDED test_table2;

-- CREATE VIEW tests with parameter markers
EXECUTE IMMEDIATE 'CREATE VIEW test_view AS SELECT * FROM test_table WHERE score > :min_score' USING 50 as min_score;
DESCRIBE EXTENDED test_view;
-- test positional parameters in CREATE VIEW
EXECUTE IMMEDIATE 'CREATE VIEW test_view2 AS SELECT * FROM test_table WHERE score < ?' USING 80;
DESCRIBE EXTENDED test_view2;

-- ALTER VIEW AS tests with parameter markers
EXECUTE IMMEDIATE 'ALTER VIEW test_view AS SELECT id, name FROM test_table WHERE score BETWEEN :min_val AND :max_val' 
USING 30 as min_val, 70 as max_val;
DESCRIBE EXTENDED test_view;
-- test positional parameters in ALTER VIEW AS
EXECUTE IMMEDIATE 'ALTER VIEW test_view2 AS SELECT * FROM test_table WHERE score > ?' USING 60;
DESCRIBE EXTENDED test_view2;

-- DECLARE VARIABLE tests with parameter markers
EXECUTE IMMEDIATE 'DECLARE VARIABLE test_var INT DEFAULT :var_default' USING 123 as var_default;
SELECT test_var;
-- test positional parameters in DECLARE VARIABLE
EXECUTE IMMEDIATE 'DECLARE VARIABLE test_var2 STRING DEFAULT ?' USING 'default_string';
SELECT test_var2;

-- verify the created objects work
SELECT * FROM test_view;
SELECT test_var, test_var2;

-- test complex expressions in parameters for DDL
DECLARE expr_val INT;
SET VAR expr_val = 10;
EXECUTE IMMEDIATE 'CREATE TABLE expr_test (id INT, computed INT DEFAULT :expr_result) USING PARQUET' 
USING (expr_val * 5 + 2) as expr_result;
DESCRIBE EXTENDED expr_test;

-- test error: mixing positional and named parameters in DDL
EXECUTE IMMEDIATE 'CREATE TABLE error_table (id INT DEFAULT ?, name STRING DEFAULT :name_default) USING PARQUET' 
USING 1, 'test' as name_default;

-- test error: undefined parameter in DDL
EXECUTE IMMEDIATE 'CREATE TABLE error_table2 (id INT DEFAULT :undefined_param) USING PARQUET';

-- CREATE FUNCTION tests with parameter markers
EXECUTE IMMEDIATE 'CREATE FUNCTION test_func(x INT DEFAULT :func_default) RETURNS INT RETURN x + :increment' 
USING 10 as func_default, 5 as increment;
DESCRIBE FUNCTION EXTENDED test_func;
-- test positional parameters in CREATE FUNCTION
EXECUTE IMMEDIATE 'CREATE FUNCTION test_func2(x INT DEFAULT ?) RETURNS INT RETURN x * ?' USING 1, 2;
DESCRIBE FUNCTION EXTENDED test_func2;

-- =============================================================================
-- COMPREHENSIVE TESTS FOR MULTIPLE PARAMETER CONSUMPTION
-- =============================================================================

-- Test CREATE FUNCTION with multiple positional parameters across inputParamText, exprText, queryText
EXECUTE IMMEDIATE 'CREATE FUNCTION multi_param_func(a INT DEFAULT ?, b INT DEFAULT ?) RETURNS INT RETURN a + b + ?' 
USING 10, 20, 5;
DESCRIBE FUNCTION EXTENDED multi_param_func;

-- Test CREATE FUNCTION table function with parameters in all three sections
EXECUTE IMMEDIATE 'CREATE FUNCTION table_func(x INT DEFAULT ?, y INT DEFAULT ?) RETURNS TABLE(result INT) RETURN SELECT x + y + ? as result' 
USING 1, 2, 3;
DESCRIBE FUNCTION EXTENDED table_func;

-- Test CREATE TABLE with multiple columns having positional parameters
EXECUTE IMMEDIATE 'CREATE TABLE multi_col_table (id INT DEFAULT ?, name STRING DEFAULT ?, score INT DEFAULT ?, active BOOLEAN DEFAULT ?) USING PARQUET' 
USING 1, 'default_name', 100, true;
DESCRIBE EXTENDED multi_col_table;

-- Test CREATE TABLE with generation expressions and defaults using positional parameters
EXECUTE IMMEDIATE 'CREATE TABLE gen_and_default (id INT DEFAULT ?, doubled INT GENERATED ALWAYS AS (id * ?), tripled INT GENERATED ALWAYS AS (id * ?)) USING PARQUET' 
USING 42, 2, 3;
DESCRIBE EXTENDED gen_and_default;

-- Test ALTER TABLE ADD COLUMN with multiple columns using positional parameters
EXECUTE IMMEDIATE 'ALTER TABLE multi_col_table ADD COLUMN (status STRING DEFAULT ?, priority INT DEFAULT ?, created_at STRING DEFAULT ?)' 
USING 'pending', 1, '2023-01-01';
DESCRIBE EXTENDED multi_col_table;

-- Test ALTER TABLE ALTER COLUMN with multiple columns using positional parameters
EXECUTE IMMEDIATE 'ALTER TABLE multi_col_table ALTER COLUMN score SET DEFAULT ?' 
USING 200;
EXECUTE IMMEDIATE 'ALTER TABLE multi_col_table ALTER COLUMN priority SET DEFAULT ?' 
USING 5;
DESCRIBE EXTENDED multi_col_table;

-- Test complex CREATE FUNCTION with many positional parameters
EXECUTE IMMEDIATE 'CREATE FUNCTION complex_func(a INT DEFAULT ?, b STRING DEFAULT ?, c DOUBLE DEFAULT ?) RETURNS STRING RETURN CONCAT(b, CAST(a + c + ? AS STRING))' 
USING 10, 'prefix_', 3.14, 100;
DESCRIBE FUNCTION EXTENDED complex_func;

-- Test CREATE TABLE with mixed defaults and generation expressions
EXECUTE IMMEDIATE 'CREATE TABLE mixed_expressions (
  id INT DEFAULT ?,
  name STRING DEFAULT ?,
  base_score INT DEFAULT ?,
  bonus_score INT GENERATED ALWAYS AS (base_score + ?),
  total_score INT GENERATED ALWAYS AS (base_score + bonus_score + ?),
  description STRING DEFAULT ?
) USING PARQUET' 
USING 1, 'test', 50, 10, 5, 'default_desc';
DESCRIBE EXTENDED mixed_expressions;

-- Test CREATE VIEW with positional parameters (should consume 1 parameter)
EXECUTE IMMEDIATE 'CREATE VIEW param_view AS SELECT * FROM multi_col_table WHERE score > ?' 
USING 150;
DESCRIBE EXTENDED param_view;

-- Test ALTER VIEW AS with positional parameters
EXECUTE IMMEDIATE 'ALTER VIEW param_view AS SELECT id, name FROM multi_col_table WHERE score > ? AND priority > ?' 
USING 100, 3;
DESCRIBE EXTENDED param_view;

-- Test DECLARE VARIABLE with positional parameters
EXECUTE IMMEDIATE 'DECLARE VARIABLE test_var_pos INT DEFAULT ?' 
USING 999;
SELECT test_var_pos;

-- Test error case: not enough positional parameters for CREATE FUNCTION
EXECUTE IMMEDIATE 'CREATE FUNCTION error_func(x INT DEFAULT ?) RETURNS INT RETURN x + ?' 
USING 10;

-- Test error case: not enough positional parameters for CREATE TABLE
EXECUTE IMMEDIATE 'CREATE TABLE error_table_pos (id INT DEFAULT ?, name STRING DEFAULT ?) USING PARQUET' 
USING 1;

-- Advanced DDL tests with parameter markers
-- test nested DDL with parameter markers
EXECUTE IMMEDIATE 'CREATE VIEW nested_view AS SELECT test_func(:input_val) as result' USING 20 as input_val;
DESCRIBE EXTENDED nested_view;
-- test parameter markers in generation expressions
EXECUTE IMMEDIATE 'CREATE TABLE gen_table (id INT, doubled INT GENERATED ALWAYS AS (id * :multiplier)) USING PARQUET' 
USING 2 as multiplier;
DESCRIBE EXTENDED gen_table;
-- test multiple parameter occurrences in same DDL
EXECUTE IMMEDIATE 'CREATE TABLE multi_param (id INT DEFAULT :val, name STRING DEFAULT :name, score INT DEFAULT :val) USING PARQUET' 
USING 42 as val, 'test' as name;
DESCRIBE EXTENDED multi_param;


-- cleanup DDL test objects
DROP FUNCTION IF EXISTS test_func;
DROP FUNCTION IF EXISTS test_func2;
DROP FUNCTION IF EXISTS multi_param_func;
DROP FUNCTION IF EXISTS table_func;
DROP FUNCTION IF EXISTS complex_func;
DROP VIEW IF EXISTS nested_view;
DROP VIEW IF EXISTS param_view;
DROP TABLE IF EXISTS gen_table;
DROP TABLE IF EXISTS multi_param;
DROP TABLE IF EXISTS multi_col_table;
DROP TABLE IF EXISTS gen_and_default;
DROP TABLE IF EXISTS mixed_expressions;

DROP VIEW IF EXISTS test_view;
DROP VIEW IF EXISTS test_view2;
DROP TABLE IF EXISTS test_table;
DROP TABLE IF EXISTS test_table2;
DROP TABLE IF EXISTS expr_test;

DROP TABLE x;