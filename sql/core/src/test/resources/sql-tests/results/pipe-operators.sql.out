-- Automatically generated by SQLQueryTestSuite
-- !query
drop table if exists t
-- !query schema
struct<>
-- !query output



-- !query
create table t(x int, y string) using csv
-- !query schema
struct<>
-- !query output



-- !query
insert into t values (0, 'abc'), (1, 'def')
-- !query schema
struct<>
-- !query output



-- !query
drop table if exists other
-- !query schema
struct<>
-- !query output



-- !query
create table other(a int, b int) using json
-- !query schema
struct<>
-- !query output



-- !query
insert into other values (1, 1), (1, 2), (2, 4)
-- !query schema
struct<>
-- !query output



-- !query
drop table if exists st
-- !query schema
struct<>
-- !query output



-- !query
create table st(x int, col struct<i1:int, i2:int>) using parquet
-- !query schema
struct<>
-- !query output



-- !query
insert into st values (1, (2, 3))
-- !query schema
struct<>
-- !query output



-- !query
create temporary view courseSales as select * from values
  ("dotNET", 2012, 10000),
  ("Java", 2012, 20000),
  ("dotNET", 2012, 5000),
  ("dotNET", 2013, 48000),
  ("Java", 2013, 30000)
  as courseSales(course, year, earnings)
-- !query schema
struct<>
-- !query output



-- !query
create temporary view courseEarnings as select * from values
  ("dotNET", 15000, 48000, 22500),
  ("Java", 20000, 30000, NULL)
  as courseEarnings(course, `2012`, `2013`, `2014`)
-- !query schema
struct<>
-- !query output



-- !query
create temporary view courseEarningsAndSales as select * from values
  ("dotNET", 15000, NULL, 48000, 1, 22500, 1),
  ("Java", 20000, 1, 30000, 2, NULL, NULL)
  as courseEarningsAndSales(
    course, earnings2012, sales2012, earnings2013, sales2013, earnings2014, sales2014)
-- !query schema
struct<>
-- !query output



-- !query
create temporary view yearsWithComplexTypes as select * from values
  (2012, array(1, 1), map('1', 1), struct(1, 'a')),
  (2013, array(2, 2), map('2', 2), struct(2, 'b'))
  as yearsWithComplexTypes(y, a, m, s)
-- !query schema
struct<>
-- !query output



-- !query
create temporary view join_test_t1 as select * from values (1) as grouping(a)
-- !query schema
struct<>
-- !query output



-- !query
create temporary view join_test_t2 as select * from values (1) as grouping(a)
-- !query schema
struct<>
-- !query output



-- !query
create temporary view join_test_t3 as select * from values (1) as grouping(a)
-- !query schema
struct<>
-- !query output



-- !query
create temporary view join_test_empty_table as select a from join_test_t2 where false
-- !query schema
struct<>
-- !query output



-- !query
create temporary view lateral_test_t1(c1, c2)
  as values (0, 1), (1, 2)
-- !query schema
struct<>
-- !query output



-- !query
create temporary view lateral_test_t2(c1, c2)
  as values (0, 2), (0, 3)
-- !query schema
struct<>
-- !query output



-- !query
create temporary view lateral_test_t3(c1, c2)
  as values (0, array(0, 1)), (1, array(2)), (2, array()), (null, array(4))
-- !query schema
struct<>
-- !query output



-- !query
create temporary view lateral_test_t4(c1, c2)
  as values (0, 1), (0, 2), (1, 1), (1, 3)
-- !query schema
struct<>
-- !query output



-- !query
create temporary view natural_join_test_t1 as select * from values
  ("one", 1), ("two", 2), ("three", 3) as natural_join_test_t1(k, v1)
-- !query schema
struct<>
-- !query output



-- !query
create temporary view natural_join_test_t2 as select * from values
  ("one", 1), ("two", 22), ("one", 5) as natural_join_test_t2(k, v2)
-- !query schema
struct<>
-- !query output



-- !query
create temporary view natural_join_test_t3 as select * from values
  ("one", 4), ("two", 5), ("one", 6) as natural_join_test_t3(k, v3)
-- !query schema
struct<>
-- !query output



-- !query
table t
|> select 1 as x
-- !query schema
struct<x:int>
-- !query output
1
1


-- !query
table t
|> select x, y
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
1	def


-- !query
table t
|> select x, y
|> select x + length(y) as z
-- !query schema
struct<z:int>
-- !query output
3
4


-- !query
values (0), (1) tab(col)
|> select col * 2 as result
-- !query schema
struct<result:int>
-- !query output
0
2


-- !query
(select * from t union all select * from t)
|> select x + length(y) as result
-- !query schema
struct<result:int>
-- !query output
3
3
4
4


-- !query
(table t
 |> select x, y
 |> select x)
union all
select x from t where x < 1
-- !query schema
struct<x:int>
-- !query output
0
0
1


-- !query
(select col from st)
|> select col.i1
-- !query schema
struct<i1:int>
-- !query output
2


-- !query
table st
|> select st.col.i1
-- !query schema
struct<i1:int>
-- !query output
2


-- !query
table t
|> select (select a from other where x = a limit 1) as result
-- !query schema
struct<result:int>
-- !query output
1
NULL


-- !query
select (values (0) tab(col) |> select col) as result
-- !query schema
struct<result:int>
-- !query output
0


-- !query
table t
|> select (select any_value(a) from other where x = a limit 1) as result
-- !query schema
struct<result:int>
-- !query output
1
NULL


-- !query
table t
|> select x + length(x) as z, z + 1 as plus_one
-- !query schema
struct<z:int,plus_one:int>
-- !query output
1	2
2	3


-- !query
table t
|> select first_value(x) over (partition by y) as result
-- !query schema
struct<result:int>
-- !query output
0
1


-- !query
select 1 x, 2 y, 3 z
|> select 1 + sum(x) over (),
     avg(y) over (),
     x,
     avg(x+1) over (partition by y order by z) AS a2
|> select a2
-- !query schema
struct<a2:double>
-- !query output
2.0


-- !query
table t
|> select x, count(*) over ()
|> select x
-- !query schema
struct<x:int>
-- !query output
0
1


-- !query
table t
|> select distinct x, y
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
1	def


-- !query
table t
|> select *
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
1	def


-- !query
table t
|> select * except (y)
-- !query schema
struct<x:int>
-- !query output
0
1


-- !query
table t
|> select /*+ repartition(3) */ *
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
1	def


-- !query
table t
|> select /*+ repartition(3) */ distinct x
-- !query schema
struct<x:int>
-- !query output
0
1


-- !query
table t
|> select /*+ repartition(3) */ all x
-- !query schema
struct<x:int>
-- !query output
0
1


-- !query
table t
|> select sum(x) as result
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "PIPE_OPERATOR_SELECT_CONTAINS_AGGREGATE_FUNCTION",
  "sqlState" : "0A000",
  "messageParameters" : {
    "expr" : "sum(x#x)"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 19,
    "stopIndex" : 24,
    "fragment" : "sum(x)"
  } ]
}


-- !query
table t
|> select y, length(y) + sum(x) as result
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "PIPE_OPERATOR_SELECT_CONTAINS_AGGREGATE_FUNCTION",
  "sqlState" : "0A000",
  "messageParameters" : {
    "expr" : "sum(x#x)"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 34,
    "stopIndex" : 39,
    "fragment" : "sum(x)"
  } ]
}


-- !query
table t
|> where true
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
1	def


-- !query
table t
|> where x + length(y) < 4
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc


-- !query
table t
|> where x + length(y) < 4
|> where x + length(y) < 3
-- !query schema
struct<x:int,y:string>
-- !query output



-- !query
(select x, sum(length(y)) as sum_len from t group by x)
|> where x = 1
-- !query schema
struct<x:int,sum_len:bigint>
-- !query output
1	3


-- !query
table t
|> where t.x = 1
-- !query schema
struct<x:int,y:string>
-- !query output
1	def


-- !query
table t
|> where spark_catalog.default.t.x = 1
-- !query schema
struct<x:int,y:string>
-- !query output
1	def


-- !query
(select col from st)
|> where col.i1 = 1
-- !query schema
struct<col:struct<i1:int,i2:int>>
-- !query output



-- !query
table st
|> where st.col.i1 = 2
-- !query schema
struct<x:int,col:struct<i1:int,i2:int>>
-- !query output
1	{"i1":2,"i2":3}


-- !query
table t
|> where exists (select a from other where x = a limit 1)
-- !query schema
struct<x:int,y:string>
-- !query output
1	def


-- !query
table t
|> where (select any_value(a) from other where x = a limit 1) = 1
-- !query schema
struct<x:int,y:string>
-- !query output
1	def


-- !query
table t
|> where sum(x) = 1
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_WHERE_CONDITION",
  "sqlState" : "42903",
  "messageParameters" : {
    "condition" : "\"(sum(x) = 1)\"",
    "expressionList" : "sum(spark_catalog.default.t.x)"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 27,
    "fragment" : "table t\n|> where sum(x) = 1"
  } ]
}


-- !query
table t
|> where y = 'abc' or length(y) + sum(x) = 1
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_WHERE_CONDITION",
  "sqlState" : "42903",
  "messageParameters" : {
    "condition" : "\"((y = abc) OR ((length(y) + sum(x)) = 1))\"",
    "expressionList" : "sum(spark_catalog.default.t.x)"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 52,
    "fragment" : "table t\n|> where y = 'abc' or length(y) + sum(x) = 1"
  } ]
}


-- !query
table t
|> where first_value(x) over (partition by y) = 1
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "_LEGACY_ERROR_TEMP_1034",
  "messageParameters" : {
    "clauseName" : "WHERE"
  }
}


-- !query
select * from t where first_value(x) over (partition by y) = 1
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "_LEGACY_ERROR_TEMP_1034",
  "messageParameters" : {
    "clauseName" : "WHERE"
  }
}


-- !query
table t
|> select x, length(y) as z
|> where x + length(y) < 4
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "UNRESOLVED_COLUMN.WITH_SUGGESTION",
  "sqlState" : "42703",
  "messageParameters" : {
    "objectName" : "`y`",
    "proposal" : "`x`, `z`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 57,
    "stopIndex" : 57,
    "fragment" : "y"
  } ]
}


-- !query
(select x, sum(length(y)) as sum_len from t group by x)
|> where sum(length(y)) = 3
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "UNRESOLVED_COLUMN.WITH_SUGGESTION",
  "sqlState" : "42703",
  "messageParameters" : {
    "objectName" : "`y`",
    "proposal" : "`x`, `sum_len`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 77,
    "stopIndex" : 77,
    "fragment" : "y"
  } ]
}


-- !query
table courseSales
|> select `year`, course, earnings
|> pivot (
     sum(earnings)
     for course in ('dotNET', 'Java')
  )
-- !query schema
struct<year:int,dotNET:bigint,Java:bigint>
-- !query output
2012	15000	20000
2013	48000	30000


-- !query
table courseSales
|> select `year` as y, course as c, earnings as e
|> pivot (
     sum(e) as s, avg(e) as a
     for y in (2012 as firstYear, 2013 as secondYear)
   )
-- !query schema
struct<c:string,firstYear_s:bigint,firstYear_a:double,secondYear_s:bigint,secondYear_a:double>
-- !query output
Java	20000	20000.0	30000	30000.0
dotNET	15000	7500.0	48000	48000.0


-- !query
select course, `year`, y, a
from courseSales
join yearsWithComplexTypes on `year` = y
|> pivot (
     max(a)
     for (y, course) in ((2012, 'dotNET'), (2013, 'Java'))
   )
-- !query schema
struct<year:int,{2012, dotNET}:array<int>,{2013, Java}:array<int>>
-- !query output
2012	[1,1]	NULL
2013	NULL	[2,2]


-- !query
select earnings, `year`, s
from courseSales
join yearsWithComplexTypes on `year` = y
|> pivot (
     sum(earnings)
     for s in ((1, 'a'), (2, 'b'))
   )
-- !query schema
struct<year:int,{1, a}:bigint,{2, b}:bigint>
-- !query output
2012	35000	NULL
2013	NULL	78000


-- !query
table courseEarnings
|> unpivot (
     earningsYear for `year` in (`2012`, `2013`, `2014`)
   )
-- !query schema
struct<course:string,year:string,earningsYear:int>
-- !query output
Java	2012	20000
Java	2013	30000
dotNET	2012	15000
dotNET	2013	48000
dotNET	2014	22500


-- !query
table courseEarnings
|> unpivot include nulls (
     earningsYear for `year` in (`2012`, `2013`, `2014`)
   )
-- !query schema
struct<course:string,year:string,earningsYear:int>
-- !query output
Java	2012	20000
Java	2013	30000
Java	2014	NULL
dotNET	2012	15000
dotNET	2013	48000
dotNET	2014	22500


-- !query
table courseEarningsAndSales
|> unpivot include nulls (
     (earnings, sales) for `year` in (
       (earnings2012, sales2012) as `2012`,
       (earnings2013, sales2013) as `2013`,
       (earnings2014, sales2014) as `2014`)
   )
-- !query schema
struct<course:string,year:string,earnings:int,sales:int>
-- !query output
Java	2012	20000	1
Java	2013	30000	2
Java	2014	NULL	NULL
dotNET	2012	15000	NULL
dotNET	2013	48000	1
dotNET	2014	22500	1


-- !query
table courseSales
|> select course, earnings
|> pivot (
     sum(earnings)
     for `year` in (2012, 2013)
   )
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "UNRESOLVED_COLUMN.WITH_SUGGESTION",
  "sqlState" : "42703",
  "messageParameters" : {
    "objectName" : "`year`",
    "proposal" : "`course`, `earnings`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 49,
    "stopIndex" : 111,
    "fragment" : "pivot (\n     sum(earnings)\n     for `year` in (2012, 2013)\n   )"
  } ]
}


-- !query
table courseSales
|> pivot (
     sum(earnings)
     for `year` in (course, 2013)
   )
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "NON_LITERAL_PIVOT_VALUES",
  "sqlState" : "42K08",
  "messageParameters" : {
    "expression" : "\"course\""
  }
}


-- !query
table courseSales
|> select course, earnings
|> pivot (
     sum(earnings)
     for `year` in (2012, 2013)
   )
   unpivot (
     earningsYear for `year` in (`2012`, `2013`, `2014`)
   )
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "NOT_ALLOWED_IN_FROM.UNPIVOT_WITH_PIVOT",
  "sqlState" : "42601",
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 186,
    "fragment" : "table courseSales\n|> select course, earnings\n|> pivot (\n     sum(earnings)\n     for `year` in (2012, 2013)\n   )\n   unpivot (\n     earningsYear for `year` in (`2012`, `2013`, `2014`)\n   )"
  } ]
}


-- !query
table courseSales
|> select course, earnings
|> unpivot (
     earningsYear for `year` in (`2012`, `2013`, `2014`)
   )
   pivot (
     sum(earnings)
     for `year` in (2012, 2013)
   )
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "NOT_ALLOWED_IN_FROM.UNPIVOT_WITH_PIVOT",
  "sqlState" : "42601",
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 186,
    "fragment" : "table courseSales\n|> select course, earnings\n|> unpivot (\n     earningsYear for `year` in (`2012`, `2013`, `2014`)\n   )\n   pivot (\n     sum(earnings)\n     for `year` in (2012, 2013)\n   )"
  } ]
}


-- !query
table courseSales
|> select course, earnings
|> pivot (
     sum(earnings)
     for `year` in (2012, 2013)
   )
   pivot (
     sum(earnings)
     for `year` in (2012, 2013)
   )
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'pivot'",
    "hint" : ""
  }
}


-- !query
table courseSales
|> select course, earnings
|> unpivot (
     earningsYear for `year` in (`2012`, `2013`, `2014`)
   )
   unpivot (
     earningsYear for `year` in (`2012`, `2013`, `2014`)
   )
   pivot (
     sum(earnings)
     for `year` in (2012, 2013)
   )
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'unpivot'",
    "hint" : ""
  }
}


-- !query
table t
|> tablesample (100 percent) repeatable (0)
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
1	def


-- !query
table t
|> tablesample (2 rows) repeatable (0)
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
1	def


-- !query
table t
|> tablesample (bucket 1 out of 1) repeatable (0)
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
1	def


-- !query
table t
|> tablesample (100 percent) repeatable (0)
|> tablesample (5 rows) repeatable (0)
|> tablesample (bucket 1 out of 1) repeatable (0)
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
1	def


-- !query
table t
|> tablesample ()
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "_LEGACY_ERROR_TEMP_0014",
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 12,
    "stopIndex" : 25,
    "fragment" : "tablesample ()"
  } ]
}


-- !query
table t
|> tablesample (-100 percent) repeatable (0)
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "_LEGACY_ERROR_TEMP_0064",
  "messageParameters" : {
    "msg" : "Sampling fraction (-1.0) must be on interval [0, 1]"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 12,
    "stopIndex" : 52,
    "fragment" : "tablesample (-100 percent) repeatable (0)"
  } ]
}


-- !query
table t
|> tablesample (-5 rows)
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_LIMIT_LIKE_EXPRESSION.IS_NEGATIVE",
  "sqlState" : "42K0E",
  "messageParameters" : {
    "expr" : "\"-5\"",
    "name" : "limit",
    "v" : "-5"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 25,
    "stopIndex" : 26,
    "fragment" : "-5"
  } ]
}


-- !query
table t
|> tablesample (x rows)
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_LIMIT_LIKE_EXPRESSION.IS_UNFOLDABLE",
  "sqlState" : "42K0E",
  "messageParameters" : {
    "expr" : "\"x\"",
    "name" : "limit"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 25,
    "stopIndex" : 25,
    "fragment" : "x"
  } ]
}


-- !query
table t
|> tablesample (bucket 2 out of 1)
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "_LEGACY_ERROR_TEMP_0064",
  "messageParameters" : {
    "msg" : "Sampling fraction (2.0) must be on interval [0, 1]"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 12,
    "stopIndex" : 42,
    "fragment" : "tablesample (bucket 2 out of 1)"
  } ]
}


-- !query
table t
|> tablesample (200b) repeatable (0)
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "_LEGACY_ERROR_TEMP_0015",
  "messageParameters" : {
    "msg" : "byteLengthLiteral"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 12,
    "stopIndex" : 44,
    "fragment" : "tablesample (200b) repeatable (0)"
  } ]
}


-- !query
table t
|> tablesample (200) repeatable (0)
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "_LEGACY_ERROR_TEMP_0016",
  "messageParameters" : {
    "bytesStr" : "200"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 12,
    "stopIndex" : 43,
    "fragment" : "tablesample (200) repeatable (0)"
  } ]
}


-- !query
table join_test_t1
|> inner join join_test_empty_table
-- !query schema
struct<a:int,a:int>
-- !query output



-- !query
table join_test_t1
|> cross join join_test_empty_table
-- !query schema
struct<a:int,a:int>
-- !query output



-- !query
table join_test_t1
|> left outer join join_test_empty_table
-- !query schema
struct<a:int,a:int>
-- !query output
1	NULL


-- !query
table join_test_t1
|> right outer join join_test_empty_table
-- !query schema
struct<a:int,a:int>
-- !query output



-- !query
table join_test_t1
|> full outer join join_test_empty_table using (a)
-- !query schema
struct<a:int>
-- !query output
1


-- !query
table join_test_t1
|> full outer join join_test_empty_table on (join_test_t1.a = join_test_empty_table.a)
-- !query schema
struct<a:int,a:int>
-- !query output
1	NULL


-- !query
table join_test_t1
|> left semi join join_test_empty_table
-- !query schema
struct<a:int>
-- !query output



-- !query
table join_test_t1
|> left anti join join_test_empty_table
-- !query schema
struct<a:int>
-- !query output
1


-- !query
select * from join_test_t1 where true
|> inner join join_test_empty_table
-- !query schema
struct<a:int,a:int>
-- !query output



-- !query
select 1 as x, 2 as y
|> inner join (select 1 as x, 4 as y) using (x)
-- !query schema
struct<x:int,y:int,y:int>
-- !query output
1	2	4


-- !query
table join_test_t1
|> inner join (join_test_t2 jt2 inner join join_test_t3 jt3 using (a)) using (a)
|> select a, join_test_t1.a, jt2.a, jt3.a
-- !query schema
struct<a:int,a:int,a:int,a:int>
-- !query output
1	1	1	1


-- !query
table join_test_t1
|> inner join join_test_t2 tablesample (100 percent) repeatable (0) jt2 using (a)
-- !query schema
struct<a:int>
-- !query output
1


-- !query
table join_test_t1
|> inner join (select 1 as a) tablesample (100 percent) repeatable (0) jt2 using (a)
-- !query schema
struct<a:int>
-- !query output
1


-- !query
table join_test_t1
|> join join_test_t1 using (a)
-- !query schema
struct<a:int>
-- !query output
1


-- !query
table lateral_test_t1
|> join lateral (select c1)
-- !query schema
struct<c1:int,c2:int,c1:int>
-- !query output
0	1	0
1	2	1


-- !query
table lateral_test_t1
|> join lateral (select c1 from lateral_test_t2)
-- !query schema
struct<c1:int,c2:int,c1:int>
-- !query output
0	1	0
0	1	0
1	2	0
1	2	0


-- !query
table lateral_test_t1
|> join lateral (select lateral_test_t1.c1 from lateral_test_t2)
-- !query schema
struct<c1:int,c2:int,c1:int>
-- !query output
0	1	0
0	1	0
1	2	1
1	2	1


-- !query
table lateral_test_t1
|> join lateral (select lateral_test_t1.c1 + t2.c1 from lateral_test_t2 t2)
-- !query schema
struct<c1:int,c2:int,(outer(lateral_test_t1.c1) + c1):int>
-- !query output
0	1	0
0	1	0
1	2	1
1	2	1


-- !query
table lateral_test_t1
|> join lateral (select *)
-- !query schema
struct<c1:int,c2:int>
-- !query output
0	1
1	2


-- !query
table lateral_test_t1
|> join lateral (select * from lateral_test_t2)
-- !query schema
struct<c1:int,c2:int,c1:int,c2:int>
-- !query output
0	1	0	2
0	1	0	3
1	2	0	2
1	2	0	3


-- !query
table lateral_test_t1
|> join lateral (select lateral_test_t1.* from lateral_test_t2)
-- !query schema
struct<c1:int,c2:int,c1:int,c2:int>
-- !query output
0	1	0	1
0	1	0	1
1	2	1	2
1	2	1	2


-- !query
table lateral_test_t1
|> join lateral (select lateral_test_t1.*, t2.* from lateral_test_t2 t2)
-- !query schema
struct<c1:int,c2:int,c1:int,c2:int,c1:int,c2:int>
-- !query output
0	1	0	1	0	2
0	1	0	1	0	3
1	2	1	2	0	2
1	2	1	2	0	3


-- !query
table lateral_test_t1
|> join lateral_test_t2
|> join lateral (select lateral_test_t1.c2 + lateral_test_t2.c2)
-- !query schema
struct<c1:int,c2:int,c1:int,c2:int,(outer(lateral_test_t1.c2) + outer(lateral_test_t2.c2)):int>
-- !query output
0	1	0	2	3
0	1	0	3	4
1	2	0	2	4
1	2	0	3	5


-- !query
table natural_join_test_t1
|> natural join natural_join_test_t2
|> where k = "one"
-- !query schema
struct<k:string,v1:int,v2:int>
-- !query output
one	1	1
one	1	5


-- !query
table natural_join_test_t1
|> natural join natural_join_test_t2 nt2
|> select natural_join_test_t1.*
-- !query schema
struct<k:string,v1:int>
-- !query output
one	1
one	1
two	2


-- !query
table natural_join_test_t1
|> natural join natural_join_test_t2 nt2
|> natural join natural_join_test_t3 nt3
|> select natural_join_test_t1.*, nt2.*, nt3.*
-- !query schema
struct<k:string,v1:int,k:string,v2:int,k:string,v3:int>
-- !query output
one	1	one	1	one	4
one	1	one	1	one	6
one	1	one	5	one	4
one	1	one	5	one	6
two	2	two	22	two	5


-- !query
table join_test_t1
|> inner join join_test_empty_table
   inner join join_test_empty_table
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'inner'",
    "hint" : ""
  }
}


-- !query
table join_test_t1
|> select 1 + 2 as result
|> full outer join join_test_empty_table on (join_test_t1.a = join_test_empty_table.a)
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "UNRESOLVED_COLUMN.WITH_SUGGESTION",
  "sqlState" : "42703",
  "messageParameters" : {
    "objectName" : "`join_test_t1`.`a`",
    "proposal" : "`result`, `join_test_empty_table`.`a`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 91,
    "stopIndex" : 104,
    "fragment" : "join_test_t1.a"
  } ]
}


-- !query
table join_test_t1 jt
|> cross join (select * from jt)
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'jt'",
    "hint" : ""
  }
}


-- !query
table t
|> union all table t
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
0	abc
1	def
1	def


-- !query
table t
|> union table t
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
1	def


-- !query
(select * from t)
|> union all table t
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
0	abc
1	def
1	def


-- !query
(select * from t)
|> union table t
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
1	def


-- !query
values (0, 'abc') tab(x, y)
|> union all table t
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
0	abc
1	def


-- !query
values (0, 1) tab(x, y)
|> union table t
-- !query schema
struct<x:int,y:string>
-- !query output
0	1
0	abc
1	def


-- !query
(select * from t)
|> union all (select * from t)
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
0	abc
1	def
1	def


-- !query
table t
|> except all table t
-- !query schema
struct<x:int,y:string>
-- !query output



-- !query
table t
|> except table t
-- !query schema
struct<x:int,y:string>
-- !query output



-- !query
table t
|> intersect all table t
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
1	def


-- !query
table t
|> intersect table t
-- !query schema
struct<x:int,y:string>
-- !query output
0	abc
1	def


-- !query
table t
|> minus all table t
-- !query schema
struct<x:int,y:string>
-- !query output



-- !query
table t
|> minus table t
-- !query schema
struct<x:int,y:string>
-- !query output



-- !query
table t
|> select x
|> union all table t
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "NUM_COLUMNS_MISMATCH",
  "sqlState" : "42826",
  "messageParameters" : {
    "firstNumColumns" : "1",
    "invalidNumColumns" : "2",
    "invalidOrdinalNum" : "second",
    "operator" : "UNION"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 40,
    "fragment" : "table t\n|> select x\n|> union all table t"
  } ]
}


-- !query
table t
|> union all table st
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INCOMPATIBLE_COLUMN_TYPE",
  "sqlState" : "42825",
  "messageParameters" : {
    "columnOrdinalNumber" : "second",
    "dataType1" : "\"STRUCT<i1: INT, i2: INT>\"",
    "dataType2" : "\"STRING\"",
    "hint" : "",
    "operator" : "UNION",
    "tableOrdinalNumber" : "second"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 29,
    "fragment" : "table t\n|> union all table st"
  } ]
}


-- !query
drop table t
-- !query schema
struct<>
-- !query output



-- !query
drop table other
-- !query schema
struct<>
-- !query output



-- !query
drop table st
-- !query schema
struct<>
-- !query output

