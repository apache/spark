-- Automatically generated by SQLQueryTestSuite
-- !query
CREATE table  explain_temp1 (key int, val int) USING PARQUET
-- !query schema
struct<>
-- !query output



-- !query
CREATE table  explain_temp2 (key int, val int) USING PARQUET
-- !query schema
struct<>
-- !query output



-- !query
CREATE table  explain_temp3 (key int, val int) USING PARQUET
-- !query schema
struct<>
-- !query output



-- !query
CREATE table  explain_temp4 (key int, val string) USING PARQUET
-- !query schema
struct<>
-- !query output



-- !query
CREATE table  explain_temp5 (key int) USING PARQUET PARTITIONED BY(val string)
-- !query schema
struct<>
-- !query output



-- !query
SET spark.sql.codegen.wholeStage = true
-- !query schema
struct<key:string,value:string>
-- !query output
spark.sql.codegen.wholeStage	true


-- !query
EXPLAIN EXTENDED
  SELECT sum(distinct val)
  FROM explain_temp1
-- !query schema
struct<plan:string>
-- !query output
== Parsed Logical Plan ==
'Project [unresolvedalias('sum(distinct 'val))]
+- 'UnresolvedRelation [explain_temp1], [], false

== Analyzed Logical Plan ==
sum(DISTINCT val): bigint
Aggregate [sum(distinct val#x) AS sum(DISTINCT val)#xL]
+- SubqueryAlias spark_catalog.default.explain_temp1
   +- Relation spark_catalog.default.explain_temp1[key#x,val#x] parquet

== Optimized Logical Plan ==
Aggregate [sum(distinct val#x) AS sum(DISTINCT val)#xL]
+- Project [val#x]
   +- Relation spark_catalog.default.explain_temp1[key#x,val#x] parquet

== Physical Plan ==
*HashAggregate(keys=[], functions=[sum(distinct val#x)], output=[sum(DISTINCT val)#xL])
+- Exchange SinglePartition, ENSURE_REQUIREMENTS, [plan_id=x]
   +- *HashAggregate(keys=[], functions=[partial_sum(distinct val#x)], output=[sum#xL])
      +- *HashAggregate(keys=[val#x], functions=[], output=[val#x])
         +- Exchange hashpartitioning(val#x, 4), ENSURE_REQUIREMENTS, [plan_id=x]
            +- *HashAggregate(keys=[val#x], functions=[], output=[val#x])
               +- *ColumnarToRow
                  +- FileScan parquet spark_catalog.default.explain_temp1[val#x] Batched: true, DataFilters: [], Format: Parquet, Location [not included in comparison]/{warehouse_dir}/explain_temp1], PartitionFilters: [], PushedFilters: [], ReadSchema: struct<val:int>


-- !query
EXPLAIN FORMATTED
  SELECT key, max(val) 
  FROM   explain_temp1 
  WHERE  key > 0 
  GROUP  BY key 
  ORDER  BY key
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
* Sort (8)
+- Exchange (7)
   +- * HashAggregate (6)
      +- Exchange (5)
         +- * HashAggregate (4)
            +- * Filter (3)
               +- * ColumnarToRow (2)
                  +- Scan parquet spark_catalog.default.explain_temp1 (1)


(1) Scan parquet spark_catalog.default.explain_temp1
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp1]
PushedFilters: [IsNotNull(key), GreaterThan(key,0)]
ReadSchema: struct<key:int,val:int>

(2) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(3) Filter [codegen id : 1]
Input [2]: [key#x, val#x]
Condition : (isnotnull(key#x) AND (key#x > 0))

(4) HashAggregate [codegen id : 1]
Input [2]: [key#x, val#x]
Keys [1]: [key#x]
Functions [1]: [partial_max(val#x)]
Aggregate Attributes [1]: [max#x]
Results [2]: [key#x, max#x]

(5) Exchange
Input [2]: [key#x, max#x]
Arguments: hashpartitioning(key#x, 4), ENSURE_REQUIREMENTS, [plan_id=x]

(6) HashAggregate [codegen id : 2]
Input [2]: [key#x, max#x]
Keys [1]: [key#x]
Functions [1]: [max(val#x)]
Aggregate Attributes [1]: [max(val#x)#x]
Results [2]: [key#x, max(val#x)#x AS max(val)#x]

(7) Exchange
Input [2]: [key#x, max(val)#x]
Arguments: rangepartitioning(key#x ASC NULLS FIRST, 4), ENSURE_REQUIREMENTS, [plan_id=x]

(8) Sort [codegen id : 3]
Input [2]: [key#x, max(val)#x]
Arguments: [key#x ASC NULLS FIRST], true, 0


-- !query
EXPLAIN FORMATTED
  SELECT key, max(val)
  FROM explain_temp1
  WHERE key > 0
  GROUP BY key
  HAVING max(val) > 0
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
* Filter (7)
+- * HashAggregate (6)
   +- Exchange (5)
      +- * HashAggregate (4)
         +- * Filter (3)
            +- * ColumnarToRow (2)
               +- Scan parquet spark_catalog.default.explain_temp1 (1)


(1) Scan parquet spark_catalog.default.explain_temp1
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp1]
PushedFilters: [IsNotNull(key), GreaterThan(key,0)]
ReadSchema: struct<key:int,val:int>

(2) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(3) Filter [codegen id : 1]
Input [2]: [key#x, val#x]
Condition : (isnotnull(key#x) AND (key#x > 0))

(4) HashAggregate [codegen id : 1]
Input [2]: [key#x, val#x]
Keys [1]: [key#x]
Functions [1]: [partial_max(val#x)]
Aggregate Attributes [1]: [max#x]
Results [2]: [key#x, max#x]

(5) Exchange
Input [2]: [key#x, max#x]
Arguments: hashpartitioning(key#x, 4), ENSURE_REQUIREMENTS, [plan_id=x]

(6) HashAggregate [codegen id : 2]
Input [2]: [key#x, max#x]
Keys [1]: [key#x]
Functions [1]: [max(val#x)]
Aggregate Attributes [1]: [max(val#x)#x]
Results [2]: [key#x, max(val#x)#x AS max(val)#x]

(7) Filter [codegen id : 2]
Input [2]: [key#x, max(val)#x]
Condition : (isnotnull(max(val)#x) AND (max(val)#x > 0))


-- !query
EXPLAIN FORMATTED
  SELECT key, val FROM explain_temp1 WHERE key > 0
  UNION 
  SELECT key, val FROM explain_temp1 WHERE key > 1
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
* HashAggregate (10)
+- Exchange (9)
   +- * HashAggregate (8)
      +- Union (7)
         :- * Filter (3)
         :  +- * ColumnarToRow (2)
         :     +- Scan parquet spark_catalog.default.explain_temp1 (1)
         +- * Filter (6)
            +- * ColumnarToRow (5)
               +- Scan parquet spark_catalog.default.explain_temp1 (4)


(1) Scan parquet spark_catalog.default.explain_temp1
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp1]
PushedFilters: [IsNotNull(key), GreaterThan(key,0)]
ReadSchema: struct<key:int,val:int>

(2) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(3) Filter [codegen id : 1]
Input [2]: [key#x, val#x]
Condition : (isnotnull(key#x) AND (key#x > 0))

(4) Scan parquet spark_catalog.default.explain_temp1
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp1]
PushedFilters: [IsNotNull(key), GreaterThan(key,1)]
ReadSchema: struct<key:int,val:int>

(5) ColumnarToRow [codegen id : 2]
Input [2]: [key#x, val#x]

(6) Filter [codegen id : 2]
Input [2]: [key#x, val#x]
Condition : (isnotnull(key#x) AND (key#x > 1))

(7) Union

(8) HashAggregate [codegen id : 3]
Input [2]: [key#x, val#x]
Keys [2]: [key#x, val#x]
Functions: []
Aggregate Attributes: []
Results [2]: [key#x, val#x]

(9) Exchange
Input [2]: [key#x, val#x]
Arguments: hashpartitioning(key#x, val#x, 4), ENSURE_REQUIREMENTS, [plan_id=x]

(10) HashAggregate [codegen id : 4]
Input [2]: [key#x, val#x]
Keys [2]: [key#x, val#x]
Functions: []
Aggregate Attributes: []
Results [2]: [key#x, val#x]


-- !query
EXPLAIN FORMATTED
  SELECT * 
  FROM   explain_temp1 a, 
         explain_temp2 b 
  WHERE  a.key = b.key
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
* BroadcastHashJoin Inner BuildRight (8)
:- * Filter (3)
:  +- * ColumnarToRow (2)
:     +- Scan parquet spark_catalog.default.explain_temp1 (1)
+- BroadcastExchange (7)
   +- * Filter (6)
      +- * ColumnarToRow (5)
         +- Scan parquet spark_catalog.default.explain_temp2 (4)


(1) Scan parquet spark_catalog.default.explain_temp1
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp1]
PushedFilters: [IsNotNull(key)]
ReadSchema: struct<key:int,val:int>

(2) ColumnarToRow [codegen id : 2]
Input [2]: [key#x, val#x]

(3) Filter [codegen id : 2]
Input [2]: [key#x, val#x]
Condition : isnotnull(key#x)

(4) Scan parquet spark_catalog.default.explain_temp2
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp2]
PushedFilters: [IsNotNull(key)]
ReadSchema: struct<key:int,val:int>

(5) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(6) Filter [codegen id : 1]
Input [2]: [key#x, val#x]
Condition : isnotnull(key#x)

(7) BroadcastExchange
Input [2]: [key#x, val#x]
Arguments: HashedRelationBroadcastMode(List(cast(input[0, int, false] as bigint)),false), [plan_id=x]

(8) BroadcastHashJoin [codegen id : 2]
Left keys [1]: [key#x]
Right keys [1]: [key#x]
Join type: Inner
Join condition: None


-- !query
EXPLAIN FORMATTED
  SELECT * 
  FROM   explain_temp1 a 
         LEFT OUTER JOIN explain_temp2 b 
                      ON a.key = b.key
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
* BroadcastHashJoin LeftOuter BuildRight (7)
:- * ColumnarToRow (2)
:  +- Scan parquet spark_catalog.default.explain_temp1 (1)
+- BroadcastExchange (6)
   +- * Filter (5)
      +- * ColumnarToRow (4)
         +- Scan parquet spark_catalog.default.explain_temp2 (3)


(1) Scan parquet spark_catalog.default.explain_temp1
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp1]
ReadSchema: struct<key:int,val:int>

(2) ColumnarToRow [codegen id : 2]
Input [2]: [key#x, val#x]

(3) Scan parquet spark_catalog.default.explain_temp2
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp2]
PushedFilters: [IsNotNull(key)]
ReadSchema: struct<key:int,val:int>

(4) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(5) Filter [codegen id : 1]
Input [2]: [key#x, val#x]
Condition : isnotnull(key#x)

(6) BroadcastExchange
Input [2]: [key#x, val#x]
Arguments: HashedRelationBroadcastMode(List(cast(input[0, int, false] as bigint)),false), [plan_id=x]

(7) BroadcastHashJoin [codegen id : 2]
Left keys [1]: [key#x]
Right keys [1]: [key#x]
Join type: LeftOuter
Join condition: None


-- !query
EXPLAIN FORMATTED
  SELECT * 
  FROM   explain_temp1 
  WHERE  key = (SELECT max(key) 
                FROM   explain_temp2 
                WHERE  key = (SELECT max(key) 
                              FROM   explain_temp3 
                              WHERE  val > 0) 
                       AND val = 2) 
         AND val > 3
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
* Filter (3)
+- * ColumnarToRow (2)
   +- Scan parquet spark_catalog.default.explain_temp1 (1)


(1) Scan parquet spark_catalog.default.explain_temp1
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp1]
PushedFilters: [IsNotNull(key), IsNotNull(val), EqualTo(key,ScalarSubquery#x), GreaterThan(val,3)]
ReadSchema: struct<key:int,val:int>

(2) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(3) Filter [codegen id : 1]
Input [2]: [key#x, val#x]
Condition : (((isnotnull(key#x) AND isnotnull(val#x)) AND (key#x = ReusedSubquery Subquery scalar-subquery#x, [id=#x])) AND (val#x > 3))

===== Subqueries =====

Subquery:1 Hosting operator id = 3 Hosting Expression = ReusedSubquery Subquery scalar-subquery#x, [id=#x]

Subquery:2 Hosting operator id = 1 Hosting Expression = Subquery scalar-subquery#x, [id=#x]
* HashAggregate (10)
+- Exchange (9)
   +- * HashAggregate (8)
      +- * Project (7)
         +- * Filter (6)
            +- * ColumnarToRow (5)
               +- Scan parquet spark_catalog.default.explain_temp2 (4)


(4) Scan parquet spark_catalog.default.explain_temp2
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp2]
PushedFilters: [IsNotNull(key), IsNotNull(val), EqualTo(key,ScalarSubquery#x), EqualTo(val,2)]
ReadSchema: struct<key:int,val:int>

(5) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(6) Filter [codegen id : 1]
Input [2]: [key#x, val#x]
Condition : (((isnotnull(key#x) AND isnotnull(val#x)) AND (key#x = ReusedSubquery Subquery scalar-subquery#x, [id=#x])) AND (val#x = 2))

(7) Project [codegen id : 1]
Output [1]: [key#x]
Input [2]: [key#x, val#x]

(8) HashAggregate [codegen id : 1]
Input [1]: [key#x]
Keys: []
Functions [1]: [partial_max(key#x)]
Aggregate Attributes [1]: [max#x]
Results [1]: [max#x]

(9) Exchange
Input [1]: [max#x]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [plan_id=x]

(10) HashAggregate [codegen id : 2]
Input [1]: [max#x]
Keys: []
Functions [1]: [max(key#x)]
Aggregate Attributes [1]: [max(key#x)#x]
Results [1]: [max(key#x)#x AS max(key)#x]

Subquery:3 Hosting operator id = 6 Hosting Expression = ReusedSubquery Subquery scalar-subquery#x, [id=#x]

Subquery:4 Hosting operator id = 4 Hosting Expression = Subquery scalar-subquery#x, [id=#x]
* HashAggregate (17)
+- Exchange (16)
   +- * HashAggregate (15)
      +- * Project (14)
         +- * Filter (13)
            +- * ColumnarToRow (12)
               +- Scan parquet spark_catalog.default.explain_temp3 (11)


(11) Scan parquet spark_catalog.default.explain_temp3
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp3]
PushedFilters: [IsNotNull(val), GreaterThan(val,0)]
ReadSchema: struct<key:int,val:int>

(12) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(13) Filter [codegen id : 1]
Input [2]: [key#x, val#x]
Condition : (isnotnull(val#x) AND (val#x > 0))

(14) Project [codegen id : 1]
Output [1]: [key#x]
Input [2]: [key#x, val#x]

(15) HashAggregate [codegen id : 1]
Input [1]: [key#x]
Keys: []
Functions [1]: [partial_max(key#x)]
Aggregate Attributes [1]: [max#x]
Results [1]: [max#x]

(16) Exchange
Input [1]: [max#x]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [plan_id=x]

(17) HashAggregate [codegen id : 2]
Input [1]: [max#x]
Keys: []
Functions [1]: [max(key#x)]
Aggregate Attributes [1]: [max(key#x)#x]
Results [1]: [max(key#x)#x AS max(key)#x]


-- !query
EXPLAIN FORMATTED
  SELECT * 
  FROM   explain_temp1 
  WHERE  key = (SELECT max(key) 
                FROM   explain_temp2 
                WHERE  val > 0) 
         OR
         key = (SELECT avg(key)
                FROM   explain_temp3
                WHERE  val > 0)
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
* Filter (3)
+- * ColumnarToRow (2)
   +- Scan parquet spark_catalog.default.explain_temp1 (1)


(1) Scan parquet spark_catalog.default.explain_temp1
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp1]
ReadSchema: struct<key:int,val:int>

(2) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(3) Filter [codegen id : 1]
Input [2]: [key#x, val#x]
Condition : ((key#x = ReusedSubquery Subquery scalar-subquery#x, [id=#x]) OR (cast(key#x as double) = ReusedSubquery Subquery scalar-subquery#x, [id=#x]))

===== Subqueries =====

Subquery:1 Hosting operator id = 3 Hosting Expression = ReusedSubquery Subquery scalar-subquery#x, [id=#x]

Subquery:2 Hosting operator id = 3 Hosting Expression = ReusedSubquery Subquery scalar-subquery#x, [id=#x]

Subquery:3 Hosting operator id = 1 Hosting Expression = Subquery scalar-subquery#x, [id=#x]
* HashAggregate (10)
+- Exchange (9)
   +- * HashAggregate (8)
      +- * Project (7)
         +- * Filter (6)
            +- * ColumnarToRow (5)
               +- Scan parquet spark_catalog.default.explain_temp2 (4)


(4) Scan parquet spark_catalog.default.explain_temp2
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp2]
PushedFilters: [IsNotNull(val), GreaterThan(val,0)]
ReadSchema: struct<key:int,val:int>

(5) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(6) Filter [codegen id : 1]
Input [2]: [key#x, val#x]
Condition : (isnotnull(val#x) AND (val#x > 0))

(7) Project [codegen id : 1]
Output [1]: [key#x]
Input [2]: [key#x, val#x]

(8) HashAggregate [codegen id : 1]
Input [1]: [key#x]
Keys: []
Functions [1]: [partial_max(key#x)]
Aggregate Attributes [1]: [max#x]
Results [1]: [max#x]

(9) Exchange
Input [1]: [max#x]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [plan_id=x]

(10) HashAggregate [codegen id : 2]
Input [1]: [max#x]
Keys: []
Functions [1]: [max(key#x)]
Aggregate Attributes [1]: [max(key#x)#x]
Results [1]: [max(key#x)#x AS max(key)#x]

Subquery:4 Hosting operator id = 1 Hosting Expression = Subquery scalar-subquery#x, [id=#x]
* HashAggregate (17)
+- Exchange (16)
   +- * HashAggregate (15)
      +- * Project (14)
         +- * Filter (13)
            +- * ColumnarToRow (12)
               +- Scan parquet spark_catalog.default.explain_temp3 (11)


(11) Scan parquet spark_catalog.default.explain_temp3
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp3]
PushedFilters: [IsNotNull(val), GreaterThan(val,0)]
ReadSchema: struct<key:int,val:int>

(12) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(13) Filter [codegen id : 1]
Input [2]: [key#x, val#x]
Condition : (isnotnull(val#x) AND (val#x > 0))

(14) Project [codegen id : 1]
Output [1]: [key#x]
Input [2]: [key#x, val#x]

(15) HashAggregate [codegen id : 1]
Input [1]: [key#x]
Keys: []
Functions [1]: [partial_avg(key#x)]
Aggregate Attributes [2]: [sum#x, count#xL]
Results [2]: [sum#x, count#xL]

(16) Exchange
Input [2]: [sum#x, count#xL]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [plan_id=x]

(17) HashAggregate [codegen id : 2]
Input [2]: [sum#x, count#xL]
Keys: []
Functions [1]: [avg(key#x)]
Aggregate Attributes [1]: [avg(key#x)#x]
Results [1]: [avg(key#x)#x AS avg(key)#x]


-- !query
EXPLAIN FORMATTED
  SELECT (SELECT Avg(key) FROM explain_temp1) + (SELECT Avg(key) FROM explain_temp1)
  FROM explain_temp1
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
* Project (3)
+- * ColumnarToRow (2)
   +- Scan parquet spark_catalog.default.explain_temp1 (1)


(1) Scan parquet spark_catalog.default.explain_temp1
Output: []
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp1]
ReadSchema: struct<>

(2) ColumnarToRow [codegen id : 1]
Input: []

(3) Project [codegen id : 1]
Output [1]: [(Subquery scalar-subquery#x, [id=#x] + ReusedSubquery Subquery scalar-subquery#x, [id=#x]) AS (scalarsubquery() + scalarsubquery())#x]
Input: []

===== Subqueries =====

Subquery:1 Hosting operator id = 3 Hosting Expression = Subquery scalar-subquery#x, [id=#x]
* HashAggregate (8)
+- Exchange (7)
   +- * HashAggregate (6)
      +- * ColumnarToRow (5)
         +- Scan parquet spark_catalog.default.explain_temp1 (4)


(4) Scan parquet spark_catalog.default.explain_temp1
Output [1]: [key#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp1]
ReadSchema: struct<key:int>

(5) ColumnarToRow [codegen id : 1]
Input [1]: [key#x]

(6) HashAggregate [codegen id : 1]
Input [1]: [key#x]
Keys: []
Functions [1]: [partial_avg(key#x)]
Aggregate Attributes [2]: [sum#x, count#xL]
Results [2]: [sum#x, count#xL]

(7) Exchange
Input [2]: [sum#x, count#xL]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [plan_id=x]

(8) HashAggregate [codegen id : 2]
Input [2]: [sum#x, count#xL]
Keys: []
Functions [1]: [avg(key#x)]
Aggregate Attributes [1]: [avg(key#x)#x]
Results [1]: [avg(key#x)#x AS avg(key)#x]

Subquery:2 Hosting operator id = 3 Hosting Expression = ReusedSubquery Subquery scalar-subquery#x, [id=#x]


-- !query
EXPLAIN FORMATTED
  WITH cte1 AS (
    SELECT *
    FROM explain_temp1 
    WHERE key > 10
  )
  SELECT * FROM cte1 a, cte1 b WHERE a.key = b.key
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
* BroadcastHashJoin Inner BuildRight (8)
:- * Filter (3)
:  +- * ColumnarToRow (2)
:     +- Scan parquet spark_catalog.default.explain_temp1 (1)
+- BroadcastExchange (7)
   +- * Filter (6)
      +- * ColumnarToRow (5)
         +- Scan parquet spark_catalog.default.explain_temp1 (4)


(1) Scan parquet spark_catalog.default.explain_temp1
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp1]
PushedFilters: [IsNotNull(key), GreaterThan(key,10)]
ReadSchema: struct<key:int,val:int>

(2) ColumnarToRow [codegen id : 2]
Input [2]: [key#x, val#x]

(3) Filter [codegen id : 2]
Input [2]: [key#x, val#x]
Condition : (isnotnull(key#x) AND (key#x > 10))

(4) Scan parquet spark_catalog.default.explain_temp1
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp1]
PushedFilters: [IsNotNull(key), GreaterThan(key,10)]
ReadSchema: struct<key:int,val:int>

(5) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(6) Filter [codegen id : 1]
Input [2]: [key#x, val#x]
Condition : (isnotnull(key#x) AND (key#x > 10))

(7) BroadcastExchange
Input [2]: [key#x, val#x]
Arguments: HashedRelationBroadcastMode(List(cast(input[0, int, false] as bigint)),false), [plan_id=x]

(8) BroadcastHashJoin [codegen id : 2]
Left keys [1]: [key#x]
Right keys [1]: [key#x]
Join type: Inner
Join condition: None


-- !query
EXPLAIN FORMATTED
  WITH cte1 AS (
    SELECT key, max(val)
    FROM explain_temp1 
    WHERE key > 10
    GROUP BY key
  )
  SELECT * FROM cte1 a, cte1 b WHERE a.key = b.key
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
* BroadcastHashJoin Inner BuildRight (10)
:- * HashAggregate (6)
:  +- Exchange (5)
:     +- * HashAggregate (4)
:        +- * Filter (3)
:           +- * ColumnarToRow (2)
:              +- Scan parquet spark_catalog.default.explain_temp1 (1)
+- BroadcastExchange (9)
   +- * HashAggregate (8)
      +- ReusedExchange (7)


(1) Scan parquet spark_catalog.default.explain_temp1
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp1]
PushedFilters: [IsNotNull(key), GreaterThan(key,10)]
ReadSchema: struct<key:int,val:int>

(2) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(3) Filter [codegen id : 1]
Input [2]: [key#x, val#x]
Condition : (isnotnull(key#x) AND (key#x > 10))

(4) HashAggregate [codegen id : 1]
Input [2]: [key#x, val#x]
Keys [1]: [key#x]
Functions [1]: [partial_max(val#x)]
Aggregate Attributes [1]: [max#x]
Results [2]: [key#x, max#x]

(5) Exchange
Input [2]: [key#x, max#x]
Arguments: hashpartitioning(key#x, 4), ENSURE_REQUIREMENTS, [plan_id=x]

(6) HashAggregate [codegen id : 4]
Input [2]: [key#x, max#x]
Keys [1]: [key#x]
Functions [1]: [max(val#x)]
Aggregate Attributes [1]: [max(val#x)#x]
Results [2]: [key#x, max(val#x)#x AS max(val)#x]

(7) ReusedExchange [Reuses operator id: 5]
Output [2]: [key#x, max#x]

(8) HashAggregate [codegen id : 3]
Input [2]: [key#x, max#x]
Keys [1]: [key#x]
Functions [1]: [max(val#x)]
Aggregate Attributes [1]: [max(val#x)#x]
Results [2]: [key#x, max(val#x)#x AS max(val)#x]

(9) BroadcastExchange
Input [2]: [key#x, max(val)#x]
Arguments: HashedRelationBroadcastMode(List(cast(input[0, int, true] as bigint)),false), [plan_id=x]

(10) BroadcastHashJoin [codegen id : 4]
Left keys [1]: [key#x]
Right keys [1]: [key#x]
Join type: Inner
Join condition: None


-- !query
EXPLAIN FORMATTED
  CREATE VIEW explain_view AS
    SELECT key, val FROM explain_temp1
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
Execute CreateViewCommand (1)
   +- CreateViewCommand (2)
         +- Project (5)
            +- SubqueryAlias (4)
               +- LogicalRelation (3)


(1) Execute CreateViewCommand
Output: []

(2) CreateViewCommand
Arguments: `spark_catalog`.`default`.`explain_view`, SELECT key, val FROM explain_temp1, false, false, PersistedView, COMPENSATION, true

(3) LogicalRelation
Arguments: parquet, [key#x, val#x], `spark_catalog`.`default`.`explain_temp1`, false

(4) SubqueryAlias
Arguments: spark_catalog.default.explain_temp1

(5) Project
Arguments: [key#x, val#x]


-- !query
EXPLAIN FORMATTED
  SELECT
    COUNT(val) + SUM(key) as TOTAL,
    COUNT(key) FILTER (WHERE val > 1)
  FROM explain_temp1
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
* HashAggregate (5)
+- Exchange (4)
   +- * HashAggregate (3)
      +- * ColumnarToRow (2)
         +- Scan parquet spark_catalog.default.explain_temp1 (1)


(1) Scan parquet spark_catalog.default.explain_temp1
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp1]
ReadSchema: struct<key:int,val:int>

(2) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(3) HashAggregate [codegen id : 1]
Input [2]: [key#x, val#x]
Keys: []
Functions [3]: [partial_count(val#x), partial_sum(key#x), partial_count(key#x) FILTER (WHERE (val#x > 1))]
Aggregate Attributes [3]: [count#xL, sum#xL, count#xL]
Results [3]: [count#xL, sum#xL, count#xL]

(4) Exchange
Input [3]: [count#xL, sum#xL, count#xL]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [plan_id=x]

(5) HashAggregate [codegen id : 2]
Input [3]: [count#xL, sum#xL, count#xL]
Keys: []
Functions [3]: [count(val#x), sum(key#x), count(key#x)]
Aggregate Attributes [3]: [count(val#x)#xL, sum(key#x)#xL, count(key#x)#xL]
Results [2]: [(count(val#x)#xL + sum(key#x)#xL) AS TOTAL#xL, count(key#x)#xL AS count(key) FILTER (WHERE (val > 1))#xL]


-- !query
EXPLAIN FORMATTED
  SELECT key, sort_array(collect_set(val))[0]
  FROM explain_temp4
  GROUP BY key
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
ObjectHashAggregate (5)
+- Exchange (4)
   +- ObjectHashAggregate (3)
      +- * ColumnarToRow (2)
         +- Scan parquet spark_catalog.default.explain_temp4 (1)


(1) Scan parquet spark_catalog.default.explain_temp4
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp4]
ReadSchema: struct<key:int,val:string>

(2) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(3) ObjectHashAggregate
Input [2]: [key#x, val#x]
Keys [1]: [key#x]
Functions [1]: [partial_collect_set(val#x, 0, 0)]
Aggregate Attributes [1]: [buf#x]
Results [2]: [key#x, buf#x]

(4) Exchange
Input [2]: [key#x, buf#x]
Arguments: hashpartitioning(key#x, 4), ENSURE_REQUIREMENTS, [plan_id=x]

(5) ObjectHashAggregate
Input [2]: [key#x, buf#x]
Keys [1]: [key#x]
Functions [1]: [collect_set(val#x, 0, 0)]
Aggregate Attributes [1]: [collect_set(val#x, 0, 0)#x]
Results [2]: [key#x, sort_array(collect_set(val#x, 0, 0)#x, true)[0] AS sort_array(collect_set(val), true)[0]#x]


-- !query
EXPLAIN FORMATTED
  SELECT key, MIN(val)
  FROM explain_temp4
  GROUP BY key
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
SortAggregate (7)
+- * Sort (6)
   +- Exchange (5)
      +- SortAggregate (4)
         +- * Sort (3)
            +- * ColumnarToRow (2)
               +- Scan parquet spark_catalog.default.explain_temp4 (1)


(1) Scan parquet spark_catalog.default.explain_temp4
Output [2]: [key#x, val#x]
Batched: true
Location [not included in comparison]/{warehouse_dir}/explain_temp4]
ReadSchema: struct<key:int,val:string>

(2) ColumnarToRow [codegen id : 1]
Input [2]: [key#x, val#x]

(3) Sort [codegen id : 1]
Input [2]: [key#x, val#x]
Arguments: [key#x ASC NULLS FIRST], false, 0

(4) SortAggregate
Input [2]: [key#x, val#x]
Keys [1]: [key#x]
Functions [1]: [partial_min(val#x)]
Aggregate Attributes [1]: [min#x]
Results [2]: [key#x, min#x]

(5) Exchange
Input [2]: [key#x, min#x]
Arguments: hashpartitioning(key#x, 4), ENSURE_REQUIREMENTS, [plan_id=x]

(6) Sort [codegen id : 2]
Input [2]: [key#x, min#x]
Arguments: [key#x ASC NULLS FIRST], false, 0

(7) SortAggregate
Input [2]: [key#x, min#x]
Keys [1]: [key#x]
Functions [1]: [min(val#x)]
Aggregate Attributes [1]: [min(val#x)#x]
Results [2]: [key#x, min(val#x)#x AS min(val)#x]


-- !query
EXPLAIN EXTENDED INSERT INTO TABLE explain_temp5 SELECT * FROM explain_temp4
-- !query schema
struct<plan:string>
-- !query output
== Parsed Logical Plan ==
'InsertIntoStatement 'UnresolvedRelation [explain_temp5], [__required_write_privileges__=INSERT], false, false, false, false
+- 'Project [*]
   +- 'UnresolvedRelation [explain_temp4], [], false

== Analyzed Logical Plan ==
InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/explain_temp5, false, [val#x], Parquet, [path=file:[not included in comparison]/{warehouse_dir}/explain_temp5], Append, `spark_catalog`.`default`.`explain_temp5`, org.apache.spark.sql.execution.datasources.CatalogFileIndex(file:[not included in comparison]/{warehouse_dir}/explain_temp5), [key, val]
+- Project [key#x, val#x]
   +- SubqueryAlias spark_catalog.default.explain_temp4
      +- Relation spark_catalog.default.explain_temp4[key#x,val#x] parquet

== Optimized Logical Plan ==
InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/explain_temp5, false, [val#x], Parquet, [path=file:[not included in comparison]/{warehouse_dir}/explain_temp5], Append, `spark_catalog`.`default`.`explain_temp5`, org.apache.spark.sql.execution.datasources.CatalogFileIndex(file:[not included in comparison]/{warehouse_dir}/explain_temp5), [key, val]
+- WriteFiles
   +- Sort [val#x ASC NULLS FIRST], false
      +- Project [key#x, empty2null(val#x) AS val#x]
         +- Relation spark_catalog.default.explain_temp4[key#x,val#x] parquet

== Physical Plan ==
Execute InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/explain_temp5, false, [val#x], Parquet, [path=file:[not included in comparison]/{warehouse_dir}/explain_temp5], Append, `spark_catalog`.`default`.`explain_temp5`, org.apache.spark.sql.execution.datasources.CatalogFileIndex(file:[not included in comparison]/{warehouse_dir}/explain_temp5), [key, val]
+- WriteFiles
   +- *Sort [val#x ASC NULLS FIRST], false, 0
      +- *Project [key#x, empty2null(val#x) AS val#x]
         +- *ColumnarToRow
            +- FileScan parquet spark_catalog.default.explain_temp4[key#x,val#x] Batched: true, DataFilters: [], Format: Parquet, Location [not included in comparison]/{warehouse_dir}/explain_temp4], PartitionFilters: [], PushedFilters: [], ReadSchema: struct<key:int,val:string>


-- !query
DROP TABLE explain_temp1
-- !query schema
struct<>
-- !query output



-- !query
DROP TABLE explain_temp2
-- !query schema
struct<>
-- !query output



-- !query
DROP TABLE explain_temp3
-- !query schema
struct<>
-- !query output



-- !query
DROP TABLE explain_temp4
-- !query schema
struct<>
-- !query output



-- !query
DROP TABLE explain_temp5
-- !query schema
struct<>
-- !query output



-- !query
CREATE table  t(v array<string>) USING PARQUET
-- !query schema
struct<>
-- !query output



-- !query
EXPLAIN SELECT * FROM t  WHERE v IN (array('a'), null)
-- !query schema
struct<plan:string>
-- !query output
== Physical Plan ==
*Filter v#x IN ([a],null)
+- *ColumnarToRow
   +- FileScan parquet spark_catalog.default.t[v#x] Batched: true, DataFilters: [v#x IN ([a],null)], Format: Parquet, Location [not included in comparison]/{warehouse_dir}/t], PartitionFilters: [], PushedFilters: [In(v, [[a],null])], ReadSchema: struct<v:array<string>>


-- !query
DROP TABLE t
-- !query schema
struct<>
-- !query output

