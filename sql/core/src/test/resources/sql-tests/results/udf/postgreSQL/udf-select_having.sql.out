-- Automatically generated by SQLQueryTestSuite
-- !query
CREATE TABLE test_having (a int, b int, c string, d string) USING parquet
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO test_having VALUES (6, 4, 'cccc', 'g')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO test_having VALUES (7, 4, 'cccc', 'h')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j')
-- !query schema
struct<>
-- !query output



-- !query
SELECT udf(b), udf(c) FROM test_having
	GROUP BY b, c HAVING udf(count(*)) = 1 ORDER BY udf(b), udf(c)
-- !query schema
struct<udf(b):int,udf(c):string>
-- !query output
1	XXXX
3	bbbb


-- !query
SELECT udf(b), udf(c) FROM test_having
	GROUP BY b, c HAVING udf(b) = 3 ORDER BY udf(b), udf(c)
-- !query schema
struct<udf(b):int,udf(c):string>
-- !query output
3	BBBB
3	bbbb


-- !query
SELECT udf(c), max(udf(a)) FROM test_having
	GROUP BY c HAVING udf(count(*)) > 2 OR udf(min(a)) = udf(max(a))
	ORDER BY c
-- !query schema
struct<udf(c):string,max(udf(a)):int>
-- !query output
XXXX	0
bbbb	5


-- !query
SELECT udf(udf(min(udf(a)))), udf(udf(max(udf(a)))) FROM test_having HAVING udf(udf(min(udf(a)))) = udf(udf(max(udf(a))))
-- !query schema
struct<udf(udf(min(udf(a)))):int,udf(udf(max(udf(a)))):int>
-- !query output



-- !query
SELECT udf(min(udf(a))), udf(udf(max(a))) FROM test_having HAVING udf(min(a)) < udf(max(udf(a)))
-- !query schema
struct<udf(min(udf(a))):int,udf(udf(max(a))):int>
-- !query output
0	9


-- !query
SELECT udf(a) FROM test_having HAVING udf(min(a)) < udf(max(a))
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
grouping expressions sequence is empty, and 'spark_catalog.default.test_having.a' is not an aggregate function. Wrap '(min(spark_catalog.default.test_having.a) AS `min(a#x)`, max(spark_catalog.default.test_having.a) AS `max(a#x)`)' in windowing function(s) or wrap 'spark_catalog.default.test_having.a' in first() (or first_value) if you don't care which value you get.


-- !query
SELECT 1 AS one FROM test_having HAVING udf(a) > 1
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "UNRESOLVED_COLUMN",
  "errorSubClass" : "WITH_SUGGESTION",
  "sqlState" : "42000",
  "messageParameters" : {
    "objectName" : "`a`",
    "proposal" : "`one`"
  }
}


-- !query
SELECT 1 AS one FROM test_having HAVING udf(udf(1) > udf(2))
-- !query schema
struct<one:int>
-- !query output



-- !query
SELECT 1 AS one FROM test_having HAVING udf(udf(1) < udf(2))
-- !query schema
struct<one:int>
-- !query output
1


-- !query
SELECT 1 AS one FROM test_having WHERE 1/udf(a) = 1 HAVING 1 < 2
-- !query schema
struct<>
-- !query output
org.apache.spark.SparkArithmeticException
{
  "errorClass" : "DIVIDE_BY_ZERO",
  "sqlState" : "22012",
  "messageParameters" : {
    "config" : "\"spark.sql.ansi.enabled\""
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 40,
    "stopIndex" : 47,
    "fragment" : "1/udf(a)"
  } ]
}


-- !query
DROP TABLE test_having
-- !query schema
struct<>
-- !query output

