-- Automatically generated by SQLQueryTestSuite
-- Number of queries: 117


-- !query
WITH q1(x,y) AS (SELECT 1,2)
SELECT * FROM q1, q1 AS q2
-- !query schema
struct<x:int,y:int,x:int,y:int>
-- !query output
1	2	1	2


-- !query
SELECT count(*) FROM (
  WITH q1(x) AS (SELECT random() FROM (SELECT EXPLODE(SEQUENCE(1, 5))))
    SELECT * FROM q1
  UNION
    SELECT * FROM q1
) ss
-- !query schema
struct<count(1):bigint>
-- !query output
10


-- !query
WITH RECURSIVE t(n) AS (
    VALUES (1)
UNION ALL
    SELECT n+1 FROM t WHERE n < 100
)
SELECT sum(n) FROM t
-- !query schema
struct<sum(n):bigint>
-- !query output
5050


-- !query
WITH RECURSIVE t(n) AS (
    SELECT (VALUES(1))
UNION ALL
    SELECT n+1 FROM t WHERE n < 5
)
SELECT * FROM t
-- !query schema
struct<n:int>
-- !query output
1
2
3
4
5


-- !query
CREATE TEMPORARY VIEW nums AS
WITH RECURSIVE nums (n) AS (
    VALUES (1)
UNION ALL
    SELECT n+1 FROM nums WHERE n < 5
)
SELECT * FROM nums
-- !query schema
struct<>
-- !query output



-- !query
SELECT * FROM nums
-- !query schema
struct<n:int>
-- !query output
1
2
3
4
5


-- !query
CREATE OR REPLACE TEMPORARY VIEW nums AS
WITH RECURSIVE nums (n) AS (
    VALUES (1)
UNION ALL
    SELECT n+1 FROM nums WHERE n < 6
)
SELECT * FROM nums
-- !query schema
struct<>
-- !query output



-- !query
SELECT * FROM nums
-- !query schema
struct<n:int>
-- !query output
1
2
3
4
5
6


-- !query
WITH RECURSIVE t(n) AS (
    SELECT 1
UNION
    SELECT 10-n FROM t)
SELECT * FROM t
-- !query schema
struct<n:int>
-- !query output
1
9


-- !query
WITH q AS (SELECT 'foo' AS x)
SELECT x FROM q
-- !query schema
struct<x:string>
-- !query output
foo


-- !query
WITH RECURSIVE t(n) AS (
    SELECT 'foo'
UNION ALL
    SELECT n || ' bar' FROM t WHERE length(n) < 20
)
SELECT n AS is_text FROM t
-- !query schema
struct<is_text:string>
-- !query output
foo
foo bar
foo bar bar
foo bar bar bar
foo bar bar bar bar
foo bar bar bar bar bar


-- !query
WITH RECURSIVE t(n) AS (
    SELECT '7'
UNION ALL
    SELECT n+1 FROM t WHERE n < 10
)
SELECT n FROM t
-- !query schema
struct<>
-- !query output
org.apache.spark.SparkException
Failed to merge incompatible data types string and double


-- !query
CREATE TABLE department (
	id INTEGER,  -- department ID
	parent_department INTEGER, -- upper department ID
	name string -- department name
) USING parquet
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO department VALUES (0, NULL, 'ROOT')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO department VALUES (1, 0, 'A')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO department VALUES (2, 1, 'B')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO department VALUES (3, 2, 'C')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO department VALUES (4, 2, 'D')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO department VALUES (5, 0, 'E')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO department VALUES (6, 4, 'F')
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO department VALUES (7, 5, 'G')
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE subdepartment AS
(
	SELECT name as root_name, * FROM department WHERE name = 'A'

	UNION ALL

	SELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd
		WHERE d.parent_department = sd.id
)
SELECT * FROM subdepartment ORDER BY name
-- !query schema
struct<root_name:string,id:int,parent_department:int,name:string>
-- !query output
A	1	0	A
A	2	1	B
A	3	2	C
A	4	2	D
A	6	4	F


-- !query
WITH RECURSIVE subdepartment(level, id, parent_department, name) AS
(
	SELECT 1, * FROM department WHERE name = 'A'

	UNION ALL

	SELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd
		WHERE d.parent_department = sd.id
)
SELECT * FROM subdepartment ORDER BY name
-- !query schema
struct<level:int,id:int,parent_department:int,name:string>
-- !query output
1	1	0	A
2	2	1	B
3	3	2	C
3	4	2	D
4	6	4	F


-- !query
WITH RECURSIVE subdepartment(level, id, parent_department, name) AS
(
	SELECT 1, * FROM department WHERE name = 'A'

	UNION ALL

	SELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd
		WHERE d.parent_department = sd.id
)
SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name
-- !query schema
struct<level:int,id:int,parent_department:int,name:string>
-- !query output
2	2	1	B
3	3	2	C
3	4	2	D
4	6	4	F


-- !query
WITH RECURSIVE subdepartment AS
(
	SELECT * FROM department WHERE name = 'A'
)
SELECT * FROM subdepartment ORDER BY name
-- !query schema
struct<id:int,parent_department:int,name:string>
-- !query output
1	0	A


-- !query
SET spark.sql.cte.recursion.level.limit=200
-- !query schema
struct<key:string,value:string>
-- !query output
spark.sql.cte.recursion.level.limit	200


-- !query
SELECT count(*) FROM (
    WITH RECURSIVE t(n) AS (
        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 200
    )
    SELECT * FROM t) AS t WHERE n < (
        SELECT count(*) FROM (
            WITH RECURSIVE t(n) AS (
                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100
                )
            SELECT * FROM t WHERE n < 50000
         ) AS t WHERE n < 100)
-- !query schema
struct<count(1):bigint>
-- !query output
98


-- !query
SET spark.sql.cte.recursion.level.limit=100
-- !query schema
struct<key:string,value:string>
-- !query output
spark.sql.cte.recursion.level.limit	100


-- !query
WITH q1(x,y) AS (
    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred
  )
SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub)
-- !query schema
struct<count(1):bigint>
-- !query output
50


-- !query
CREATE VIEW vsubdepartment AS
	WITH RECURSIVE subdepartment AS
	(
		SELECT * FROM department WHERE name = 'A'
		UNION ALL
		SELECT d.* FROM department AS d, subdepartment AS sd
			WHERE d.parent_department = sd.id
	)
	SELECT * FROM subdepartment
-- !query schema
struct<>
-- !query output



-- !query
SELECT * FROM vsubdepartment ORDER BY name
-- !query schema
struct<id:int,parent_department:int,name:string>
-- !query output
1	0	A
2	1	B
3	2	C
4	2	D
6	4	F


-- !query
SHOW CREATE TABLE vsubdepartment AS SERDE
-- !query schema
struct<createtab_stmt:string>
-- !query output
CREATE VIEW `default`.`vsubdepartment`(
  `id`,
  `parent_department`,
  `name`)
AS WITH RECURSIVE subdepartment AS
	(
		SELECT * FROM department WHERE name = 'A'
		UNION ALL
		SELECT d.* FROM department AS d, subdepartment AS sd
			WHERE d.parent_department = sd.id
	)
	SELECT * FROM subdepartment


-- !query
DROP VIEW vsubdepartment
-- !query schema
struct<>
-- !query output



-- !query
CREATE VIEW sums_1_100 AS
WITH RECURSIVE t(n) AS (
    VALUES (1)
UNION ALL
    SELECT n+1 FROM t WHERE n < 100
)
SELECT sum(n) FROM t
-- !query schema
struct<>
-- !query output



-- !query
SHOW CREATE TABLE sums_1_100 AS SERDE
-- !query schema
struct<createtab_stmt:string>
-- !query output
CREATE VIEW `default`.`sums_1_100`(
  `sum(n)`)
AS WITH RECURSIVE t(n) AS (
    VALUES (1)
UNION ALL
    SELECT n+1 FROM t WHERE n < 100
)
SELECT sum(n) FROM t


-- !query
DROP VIEW sums_1_100
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE t(i,j) AS (
	VALUES (1,2)
	UNION ALL
	SELECT t2.i, t.j+1 FROM
		(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2
		JOIN t ON (t2.i = t.i+1))

	SELECT * FROM t
-- !query schema
struct<i:int,j:int>
-- !query output
1	2
2	3
3	4


-- !query
CREATE TABLE tree(
    id INTEGER,
    parent_id INTEGER
) USING parquet
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO tree
VALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),
       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11)
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE t(id, path) AS (
    VALUES(1,cast(array() as array<Int>))
UNION ALL
    SELECT tree.id, t.path || array(tree.id)
    FROM tree JOIN t ON (tree.parent_id = t.id)
)
SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON
	(t1.path[0] = t2.path[0] AND
	size(t1.path) = 1 AND
	size(t2.path) > 1)
	ORDER BY t1.id, t2.id
-- !query schema
struct<id:int,path:array<int>,id:int,path:array<int>>
-- !query output
2	[2]	4	[2,4]
2	[2]	5	[2,5]
2	[2]	6	[2,6]
2	[2]	9	[2,4,9]
2	[2]	10	[2,4,10]
2	[2]	14	[2,4,9,14]
3	[3]	7	[3,7]
3	[3]	8	[3,8]
3	[3]	11	[3,7,11]
3	[3]	12	[3,7,12]
3	[3]	13	[3,7,13]
3	[3]	15	[3,7,11,15]
3	[3]	16	[3,7,11,16]


-- !query
WITH RECURSIVE t(id, path) AS (
    VALUES(1,cast(array() as array<Int>))
UNION ALL
    SELECT tree.id, t.path || array(tree.id)
    FROM tree JOIN t ON (tree.parent_id = t.id)
)
SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON
	(t1.path[0] = t2.path[0] AND
	size(t1.path) = 1 AND
	size(t2.path) > 1)
	GROUP BY t1.id
	ORDER BY t1.id
-- !query schema
struct<id:int,count(id, path):bigint>
-- !query output
2	6
3	7


-- !query
WITH RECURSIVE t(id, path) AS (
    VALUES(1,cast(array() as array<Int>))
UNION ALL
    SELECT tree.id, t.path || array(tree.id)
    FROM tree JOIN t ON (tree.parent_id = t.id)
)
SELECT t1.id, t2.path, struct(t2.*) FROM t AS t1 JOIN t AS t2 ON
(t1.id=t2.id)
-- !query schema
struct<id:int,path:array<int>,struct(id, path):struct<id:int,path:array<int>>>
-- !query output
1	[]	{"id":1,"path":[]}
10	[2,4,10]	{"id":10,"path":[2,4,10]}
11	[3,7,11]	{"id":11,"path":[3,7,11]}
12	[3,7,12]	{"id":12,"path":[3,7,12]}
13	[3,7,13]	{"id":13,"path":[3,7,13]}
14	[2,4,9,14]	{"id":14,"path":[2,4,9,14]}
15	[3,7,11,15]	{"id":15,"path":[3,7,11,15]}
16	[3,7,11,16]	{"id":16,"path":[3,7,11,16]}
2	[2]	{"id":2,"path":[2]}
3	[3]	{"id":3,"path":[3]}
4	[2,4]	{"id":4,"path":[2,4]}
5	[2,5]	{"id":5,"path":[2,5]}
6	[2,6]	{"id":6,"path":[2,6]}
7	[3,7]	{"id":7,"path":[3,7]}
8	[3,8]	{"id":8,"path":[3,8]}
9	[2,4,9]	{"id":9,"path":[2,4,9]}


-- !query
create table graph( f int, t int, label string ) USING parquet
-- !query schema
struct<>
-- !query output



-- !query
insert into graph values
	(1, 2, 'arc 1 -> 2'),
	(1, 3, 'arc 1 -> 3'),
	(2, 3, 'arc 2 -> 3'),
	(1, 4, 'arc 1 -> 4'),
	(4, 5, 'arc 4 -> 5'),
	(5, 1, 'arc 5 -> 1')
-- !query schema
struct<>
-- !query output



-- !query
with recursive search_graph(f, t, label, path, cycle) as (
	select *, array(struct(g.f, g.t)), false from graph g
	union all
	select g.*, path || array(struct(g.f, g.t)), array_contains(path, struct(g.f, g.t))
	from graph g, search_graph sg
	where g.f = sg.t and not cycle
)
select * from search_graph
-- !query schema
struct<f:int,t:int,label:string,path:array<struct<f:int,t:int>>,cycle:boolean>
-- !query output
1	2	arc 1 -> 2	[{"f":1,"t":2}]	false
1	2	arc 1 -> 2	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
1	2	arc 1 -> 2	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
1	2	arc 1 -> 2	[{"f":5,"t":1},{"f":1,"t":2}]	false
1	3	arc 1 -> 3	[{"f":1,"t":3}]	false
1	3	arc 1 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	3	arc 1 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	3	arc 1 -> 3	[{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	true
1	4	arc 1 -> 4	[{"f":1,"t":4}]	false
1	4	arc 1 -> 4	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	false
1	4	arc 1 -> 4	[{"f":5,"t":1},{"f":1,"t":4}]	false
2	3	arc 2 -> 3	[{"f":1,"t":2},{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
4	5	arc 4 -> 5	[{"f":1,"t":4},{"f":4,"t":5}]	false
4	5	arc 4 -> 5	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	true
4	5	arc 4 -> 5	[{"f":4,"t":5}]	false
4	5	arc 4 -> 5	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	false
5	1	arc 5 -> 1	[{"f":4,"t":5},{"f":5,"t":1}]	false
5	1	arc 5 -> 1	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	true
5	1	arc 5 -> 1	[{"f":5,"t":1}]	false


-- !query
with recursive search_graph(f, t, label, path, cycle) as (
	select *, array(struct(g.f, g.t)), false from graph g
	union all
	select g.*, path || array(struct(g.f, g.t)), array_contains(path, struct(g.f, g.t))
	from graph g, search_graph sg
	where g.f = sg.t and not cycle
)
select * from search_graph order by path
-- !query schema
struct<f:int,t:int,label:string,path:array<struct<f:int,t:int>>,cycle:boolean>
-- !query output
1	2	arc 1 -> 2	[{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":1,"t":4}]	false
4	5	arc 4 -> 5	[{"f":1,"t":4},{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	false
1	2	arc 1 -> 2	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	true
2	3	arc 2 -> 3	[{"f":2,"t":3}]	false
4	5	arc 4 -> 5	[{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":4,"t":5},{"f":5,"t":1}]	false
1	2	arc 1 -> 2	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	false
4	5	arc 4 -> 5	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	true
5	1	arc 5 -> 1	[{"f":5,"t":1}]	false
1	2	arc 1 -> 2	[{"f":5,"t":1},{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":5,"t":1},{"f":1,"t":4}]	false
4	5	arc 4 -> 5	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	true


-- !query
WITH RECURSIVE
  y (id) AS (VALUES (1)),
  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)
SELECT * FROM x
-- !query schema
struct<id:int>
-- !query output
1
2
3
4
5


-- !query
WITH RECURSIVE
    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),
    y(id) AS (values (1))
 SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Table or view not found: y; line 2 pos 28


-- !query
WITH RECURSIVE
   x(id) AS
     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),
   y(id) AS
     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)
 SELECT y.*, x.* FROM y LEFT JOIN x ON x.id = y.id
-- !query schema
struct<id:int,id:int>
-- !query output
1	1
10	NULL
2	2
3	3
4	4
5	5
6	NULL
7	NULL
8	NULL
9	NULL


-- !query
WITH RECURSIVE
   x(id) AS
     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),
   y(id) AS
     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)
 SELECT y.*, x.* FROM y LEFT JOIN x ON x.id = y.id
-- !query schema
struct<id:int,id:int>
-- !query output
1	1
2	2
3	3
4	4
5	5
6	NULL


-- !query
WITH RECURSIVE
   x(id) AS
     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),
   y(id) AS
     (SELECT * FROM x UNION ALL SELECT * FROM x),
   z(id) AS
     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)
 SELECT * FROM z
-- !query schema
struct<id:int>
-- !query output
1
10
10
10
2
2
3
3
3
4
4
4
5
5
5
6
6
6
7
7
7
8
8
8
9
9
9


-- !query
WITH RECURSIVE
   x(id) AS
     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),
   y(id) AS
     (SELECT * FROM x UNION ALL SELECT * FROM x),
   z(id) AS
     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)
 SELECT * FROM z
-- !query schema
struct<id:int>
-- !query output
1
1
10
10
10
10
10
10
2
2
2
2
3
3
3
3
3
3
4
4
4
4
4
4
5
5
5
5
5
5
6
6
6
6
6
6
7
7
7
7
7
7
8
8
8
8
8
8
9
9
9
9
9
9


-- !query
CREATE TABLE y (a INTEGER) USING parquet
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO y SELECT EXPLODE(SEQUENCE(1, 10))
-- !query schema
struct<>
-- !query output



-- !query
DROP TABLE y
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT SELECT n+1 FROM x)
	SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query
WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT ALL SELECT n+1 FROM x)
	SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query
WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT SELECT n+1 FROM x)
	SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query
WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT ALL SELECT n+1 FROM x)
	SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query
WITH RECURSIVE x(n) AS (SELECT n FROM x)
	SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query
WITH RECURSIVE x(n) AS (SELECT n FROM x UNION ALL SELECT 1)
	SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive query x should not contain recursive references in its anchor (first) term.;


-- !query
CREATE TABLE y (a INTEGER) USING parquet
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO y SELECT EXPLODE(SEQUENCE(1, 10))
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1
	UNION ALL
	SELECT x.n+1 FROM y LEFT JOIN x ON x.n = y.a WHERE n < 10)
SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query
WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1
	UNION ALL
	SELECT x.n+1 FROM x RIGHT JOIN y ON x.n = y.a WHERE n < 10)
SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query
WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1
	UNION ALL
	SELECT x.n+1 FROM x FULL JOIN y ON x.n = y.a WHERE n < 10)
SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query
WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x
                          WHERE n IN (SELECT * FROM x))
  SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive query x should not contain recursive references in its subquery.;


-- !query
WITH RECURSIVE x(n) AS (SELECT 1L UNION ALL SELECT count(*) FROM x)
  SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query
WITH RECURSIVE x(n) AS (SELECT 1L UNION ALL SELECT sum(n) FROM x)
  SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query
WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x ORDER BY 1)
  SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query
WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x LIMIT 10)
  SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query
WITH RECURSIVE x(id) AS (values (1)
    UNION ALL
    SELECT (SELECT * FROM x) FROM x WHERE id < 5
) SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive query x should not contain recursive references in its subquery.;


-- !query
WITH RECURSIVE
  x (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM y WHERE id < 5),
  y (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 5)
SELECT * FROM x
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
cannot resolve '`id`' given input columns: [spark_catalog.default.y.a]; line 2 pos 57


-- !query
WITH RECURSIVE foo(i) AS
    (values (1)
    UNION ALL
       (SELECT i+1 FROM foo WHERE i < 10
          UNION ALL
       SELECT i+1 FROM foo WHERE i < 5)
) SELECT * FROM foo
-- !query schema
struct<i:int>
-- !query output
1
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
2
2
3
3
3
3
4
4
4
4
4
4
4
4
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
8
8
8
8
8
8
8
8
8
8
8
8
8
8
8
8
9
9
9
9
9
9
9
9
9
9
9
9
9
9
9
9


-- !query
WITH RECURSIVE foo(i) AS
    (values (1)
    UNION ALL
	   SELECT * FROM
       (SELECT i+1 FROM foo WHERE i < 10
          UNION ALL
       SELECT i+1 FROM foo WHERE i < 5) AS t
) SELECT * FROM foo
-- !query schema
struct<i:int>
-- !query output
1
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
2
2
3
3
3
3
4
4
4
4
4
4
4
4
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
8
8
8
8
8
8
8
8
8
8
8
8
8
8
8
8
9
9
9
9
9
9
9
9
9
9
9
9
9
9
9
9


-- !query
WITH RECURSIVE foo(i) AS
    (values (1)
    UNION ALL
       (SELECT i+1 FROM foo WHERE i < 10
          EXCEPT
       SELECT i+1 FROM foo WHERE i < 5)
) SELECT * FROM foo
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive reference foo cannot be used multiple times in a recursive term.;


-- !query
WITH RECURSIVE foo(i) AS
    (values (1)
    UNION ALL
       (SELECT i+1 FROM foo WHERE i < 10
          INTERSECT
       SELECT i+1 FROM foo WHERE i < 5)
) SELECT * FROM foo
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive reference foo cannot be used multiple times in a recursive term.;


-- !query
WITH RECURSIVE foo(i) AS
   (SELECT i FROM (VALUES(1),(2)) t(i)
   UNION ALL
   SELECT cast((i+1) AS decimal(10,0)) FROM foo WHERE i < 10)
SELECT * FROM foo
-- !query schema
struct<>
-- !query output
org.apache.spark.SparkException
Failed to merge incompatible data types int and decimal(10,0)


-- !query
WITH RECURSIVE foo(i) AS
   (SELECT cast(i as decimal(3,0)) FROM (VALUES(1),(2)) t(i)
   UNION ALL
   SELECT cast((i+1) AS decimal(10,0)) FROM foo WHERE i < 10)
SELECT * FROM foo
-- !query schema
struct<>
-- !query output
org.apache.spark.SparkException
Failed to merge decimal types with incompatible precision 3 and 10


-- !query
with cte(foo) as ( select 42 ) select * from ((select foo from cte)) q
-- !query schema
struct<foo:int>
-- !query output
42


-- !query
WITH RECURSIVE t(j) AS (
    WITH RECURSIVE s(i) AS (
        VALUES (1)
        UNION ALL
        SELECT i+1 FROM s WHERE i < 10
    )
    SELECT i FROM s
    UNION ALL
    SELECT j+1 FROM t WHERE j < 10
)
SELECT * FROM t
-- !query schema
struct<j:int>
-- !query output
1
10
10
10
10
10
10
10
10
10
10
2
2
3
3
3
4
4
4
4
5
5
5
5
5
6
6
6
6
6
6
7
7
7
7
7
7
7
8
8
8
8
8
8
8
8
9
9
9
9
9
9
9
9
9


-- !query
WITH outermost(x) AS (
  SELECT 1
  UNION (WITH innermost as (SELECT 2)
         SELECT * FROM innermost
         UNION SELECT 3)
)
SELECT * FROM outermost ORDER BY 1
-- !query schema
struct<x:int>
-- !query output
1
2
3


-- !query
WITH outermost(x) AS (
  SELECT 1
  UNION (WITH innermost as (SELECT 2)
         SELECT * FROM outermost  -- fail
         UNION SELECT * FROM innermost)
)
SELECT * FROM outermost ORDER BY 1
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Table or view not found: outermost; line 4 pos 23


-- !query
WITH RECURSIVE outermost(x) AS (
  SELECT 1
  UNION (WITH innermost as (SELECT 2)
         SELECT * FROM outermost
         UNION SELECT * FROM innermost)
)
SELECT * FROM outermost ORDER BY 1
-- !query schema
struct<x:int>
-- !query output
1
2


-- !query
WITH RECURSIVE outermost(x) AS (
  WITH innermost as (SELECT 2 FROM outermost) -- fail
    SELECT * FROM innermost
    UNION SELECT * from outermost
)
SELECT * FROM outermost ORDER BY 1
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Recursive query outermost should not contain recursive references in its anchor (first) term.;


-- !query
WITH RECURSIVE
  tab(id_key,link) AS (VALUES (1,17), (2,17), (3,17), (4,17), (6,17), (5,17)),
  iter (id_key, row_type, link) AS (
      SELECT 0, 'base', 17
    UNION ALL (
      WITH remaining(id_key, row_type, link, min) AS (
        SELECT tab.id_key, 'true', iter.link, MIN(tab.id_key) OVER ()
        FROM tab INNER JOIN iter ON iter.link=tab.link
        WHERE tab.id_key > iter.id_key
      ),
      first_remaining AS (
        SELECT id_key, row_type, link
        FROM remaining
        WHERE id_key=min
      ),
      effect AS (
        SELECT tab.id_key, 'new', tab.link
        FROM first_remaining e INNER JOIN tab ON e.id_key=tab.id_key
        WHERE e.row_type = 'false'
      )
      SELECT * FROM first_remaining
      UNION ALL SELECT * FROM effect
    )
  )
SELECT * FROM iter
-- !query schema
struct<id_key:int,row_type:string,link:int>
-- !query output
0	base	17
1	true	17
2	true	17
3	true	17
4	true	17
5	true	17
6	true	17


-- !query
WITH RECURSIVE
  tab(id_key,link) AS (VALUES (1,17), (2,17), (3,17), (4,17), (6,17), (5,17)),
  iter (id_key, row_type, link) AS (
      SELECT 0, 'base', 17
    UNION (
      WITH remaining(id_key, row_type, link, min) AS (
        SELECT tab.id_key, 'true', iter.link, MIN(tab.id_key) OVER ()
        FROM tab INNER JOIN iter ON iter.link=tab.link
        WHERE tab.id_key > iter.id_key
      ),
      first_remaining AS (
        SELECT id_key, row_type, link
        FROM remaining
        WHERE id_key=min
      ),
      effect AS (
        SELECT tab.id_key, 'new', tab.link
        FROM first_remaining e INNER JOIN tab ON e.id_key=tab.id_key
        WHERE e.row_type = 'false'
      )
      SELECT * FROM first_remaining
      UNION ALL SELECT * FROM effect
    )
  )
SELECT * FROM iter
-- !query schema
struct<id_key:int,row_type:string,link:int>
-- !query output
0	base	17
1	true	17
2	true	17
3	true	17
4	true	17
5	true	17
6	true	17


-- !query
CREATE TABLE withz USING parquet AS SELECT i AS k, CAST(i || ' v' AS string) v FROM (SELECT EXPLODE(SEQUENCE(1, 16, 3)) i)
-- !query schema
struct<>
-- !query output



-- !query
SELECT * FROM withz ORDER BY k
-- !query schema
struct<k:int,v:string>
-- !query output
1	1 v
4	4 v
7	7 v
10	10 v
13	13 v
16	16 v


-- !query
DROP TABLE withz
-- !query schema
struct<>
-- !query output



-- !query
TRUNCATE TABLE y
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO y SELECT EXPLODE(SEQUENCE(1, 3))
-- !query schema
struct<>
-- !query output



-- !query
CREATE TABLE yy (a INTEGER) USING parquet
-- !query schema
struct<>
-- !query output



-- !query
SELECT * FROM y
-- !query schema
struct<a:int>
-- !query output
1
2
3


-- !query
SELECT * FROM yy
-- !query schema
struct<a:int>
-- !query output



-- !query
SELECT * FROM y
-- !query schema
struct<a:int>
-- !query output
1
2
3


-- !query
SELECT * FROM yy
-- !query schema
struct<a:int>
-- !query output



-- !query
CREATE TABLE parent ( id int, val string ) USING parquet
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO parent VALUES ( 1, 'p1' )
-- !query schema
struct<>
-- !query output



-- !query
SELECT * FROM parent
-- !query schema
struct<id:int,val:string>
-- !query output
1	p1


-- !query
SELECT * FROM parent
-- !query schema
struct<id:int,val:string>
-- !query output
1	p1


-- !query
WITH RECURSIVE t AS (
	INSERT INTO y
		SELECT * FROM t
)
VALUES(FALSE)
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH RECURSIVE t AS (\n\tINSERT'(line 2, pos 1)

== SQL ==
WITH RECURSIVE t AS (
	INSERT INTO y
-^^^
		SELECT * FROM t
)
VALUES(FALSE)


-- !query
WITH t AS (
	INSERT INTO y VALUES(0)
)
SELECT * FROM t
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH t AS (\n\tINSERT'(line 2, pos 1)

== SQL ==
WITH t AS (
	INSERT INTO y VALUES(0)
-^^^
)
SELECT * FROM t


-- !query
create table foo (with baz)
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'with'(line 1, pos 18)

== SQL ==
create table foo (with baz)
------------------^^^


-- !query
create table foo (with ordinality)
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'with'(line 1, pos 18)

== SQL ==
create table foo (with ordinality)
------------------^^^


-- !query
with ordinality as (select 1 as x) select * from ordinality
-- !query schema
struct<x:int>
-- !query output
1


-- !query
WITH test AS (SELECT 42) INSERT INTO test VALUES (1)
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
Table not found: test;


-- !query
create table test (i int) USING parquet
-- !query schema
struct<>
-- !query output



-- !query
with test as (select 42) insert into test select * from test
-- !query schema
struct<>
-- !query output



-- !query
select * from test
-- !query schema
struct<i:int>
-- !query output
42


-- !query
drop table test
-- !query schema
struct<>
-- !query output



-- !query
DROP TABLE department
-- !query schema
struct<>
-- !query output



-- !query
DROP TABLE tree
-- !query schema
struct<>
-- !query output



-- !query
DROP TABLE graph
-- !query schema
struct<>
-- !query output



-- !query
DROP TABLE y
-- !query schema
struct<>
-- !query output



-- !query
DROP TABLE yy
-- !query schema
struct<>
-- !query output



-- !query
DROP TABLE parent
-- !query schema
struct<>
-- !query output

