-- Automatically generated by SQLQueryTestSuite
-- !query
WITH r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "TABLE_OR_VIEW_NOT_FOUND",
  "sqlState" : "42P01",
  "messageParameters" : {
    "relationName" : "`r`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 67,
    "stopIndex" : 67,
    "fragment" : "r"
  } ]
}


-- !query
WITH RECURSIVE r AS (
  SELECT 0 AS level
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query schema
struct<level:int>
-- !query output
0
1
2
3
4
5
6
7
8
9


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query schema
struct<level:int>
-- !query output
0
1
2
3
4
5
6
7
8
9


-- !query
WITH RECURSIVE r(c) AS (
  SELECT 'a'
  UNION ALL
  SELECT c || char(ascii(substr(c, -1)) + 1) FROM r WHERE LENGTH(c) < 10
)
SELECT * FROM r
-- !query schema
struct<c:string>
-- !query output
a
ab
abc
abcd
abcde
abcdef
abcdefg
abcdefgh
abcdefghi
abcdefghij


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.SparkException
{
  "errorClass" : "RECURSION_LEVEL_LIMIT_EXCEEDED",
  "sqlState" : "42836",
  "messageParameters" : {
    "levelLimit" : "25"
  }
}


-- !query
CREATE TEMPORARY VIEW ZeroAndOne(current, next) AS VALUES
    (0,0),
    (0,1),
    (1,0),
    (1,1)
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE t(n) AS (
    SELECT 1
    UNION ALL
    SELECT next FROM t LEFT JOIN ZeroAndOne ON n = current
)
SELECT * FROM t
-- !query schema
struct<>
-- !query output
org.apache.spark.SparkException
{
  "errorClass" : "RECURSION_ROW_LIMIT_EXCEEDED",
  "sqlState" : "42836",
  "messageParameters" : {
    "rowLimit" : "50"
  }
}


-- !query
DROP VIEW ZeroAndOne
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE r(level) MAX RECURSION LEVEL 35 AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 30
  )
SELECT * FROM r
-- !query schema
struct<level:int>
-- !query output
0
1
10
11
12
13
14
15
16
17
18
19
2
20
21
22
23
24
25
26
27
28
29
3
30
4
5
6
7
8
9


-- !query
WITH r(level) MAX RECURSION LEVEL 35 AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 30
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "_LEGACY_ERROR_TEMP_0035",
  "messageParameters" : {
    "message" : "Cannot specify MAX RECURSION LEVEL when the CTE is not marked as RECURSIVE"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 125,
    "fragment" : "WITH r(level) MAX RECURSION LEVEL 35 AS (\n  VALUES 0\n  UNION ALL\n  SELECT level + 1 FROM r WHERE level < 30\n)\nSELECT * FROM r"
  } ]
}


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 150
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.SparkException
{
  "errorClass" : "RECURSION_LEVEL_LIMIT_EXCEEDED",
  "sqlState" : "42836",
  "messageParameters" : {
    "levelLimit" : "25"
  }
}


-- !query
CREATE TEMPORARY VIEW ZeroAndOne(current, next) AS VALUES
    (0,0),
    (0,1),
    (1,0),
    (1,1)
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE t(n) AS (
    SELECT 1
    UNION ALL
    SELECT next FROM t LEFT JOIN ZeroAndOne ON n = current
    )
SELECT * FROM t LIMIT 60
-- !query schema
struct<n:int>
-- !query output
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1


-- !query
DROP VIEW ZeroAndOne
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT * FROM r LIMIT 10
-- !query schema
struct<level:int>
-- !query output
0
1
2
3
4
5
6
7
8
9


-- !query
WITH RECURSIVE r AS (
  SELECT 0 as level
  UNION
  SELECT (level + 1) % 10 FROM r
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "UNION_NOT_SUPPORTED_IN_RECURSIVE_CTE",
  "sqlState" : "42836",
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 100,
    "fragment" : "WITH RECURSIVE r AS (\n  SELECT 0 as level\n  UNION\n  SELECT (level + 1) % 10 FROM r\n)\nSELECT * FROM r"
  } ]
}


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION
  SELECT (level + 1) % 10 FROM r
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "UNION_NOT_SUPPORTED_IN_RECURSIVE_CTE",
  "sqlState" : "42836",
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 98,
    "fragment" : "WITH RECURSIVE r(level) AS (\n  VALUES 0\n  UNION\n  SELECT (level + 1) % 10 FROM r\n)\nSELECT * FROM r"
  } ]
}


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT level, level FROM r ORDER BY 1 LIMIT 10
-- !query schema
struct<>
-- !query output
org.apache.spark.SparkException
{
  "errorClass" : "RECURSION_LEVEL_LIMIT_EXCEEDED",
  "sqlState" : "42836",
  "messageParameters" : {
    "levelLimit" : "25"
  }
}


-- !query
WITH RECURSIVE r(level) AS (
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_CTE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level) AS (
  SELECT level + 1 FROM r WHERE level < 9
  UNION ALL
  VALUES 0
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "UNRESOLVED_COLUMN.WITHOUT_SUGGESTION",
  "sqlState" : "42703",
  "messageParameters" : {
    "objectName" : "`level`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 62,
    "stopIndex" : 66,
    "fragment" : "level"
  } ]
}


-- !query
WITH RECURSIVE t(n) AS (
    SELECT 1
    UNION ALL
    SELECT 2
)
SELECT * FROM t
-- !query schema
struct<n:int>
-- !query output
1
2


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  INTERSECT
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_CTE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE t(col) (
  SELECT 1
  UNION ALL
  SELECT (SELECT max(col) FROM t)
)
SELECT * FROM t LIMIT 5
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH
  t1 AS (SELECT 1 as n),
  t2(n) AS (
    WITH RECURSIVE t3(n) AS (
      SELECT 1
      UNION ALL
      SELECT n+1 FROM (SELECT MAX(n) FROM t3)
    )
    SELECT * FROM t3
  )
SELECT * FROM t2
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE t1(n) AS (
    SELECT 1
    UNION ALL
    SELECT (SELECT n+1 FROM t1 WHERE n<5)
)
SELECT * FROM t1 LIMIT 5
-- !query schema
struct<n:int>
-- !query output
1
2
3
4
5


-- !query
WITH RECURSIVE
  t1 AS (
    SELECT 1 AS level
    UNION ALL (
      WITH t2 AS (SELECT level + 1 FROM t1 WHERE level < 10)
      SELECT * FROM t2
    )
  )
SELECT * FROM t1
-- !query schema
struct<level:int>
-- !query output
1
10
2
3
4
5
6
7
8
9


-- !query
SET spark.sql.legacy.ctePrecedencePolicy=CORRECTED
-- !query schema
struct<key:string,value:string>
-- !query output
spark.sql.legacy.ctePrecedencePolicy	CORRECTED


-- !query
WITH
  t1 AS (SELECT 1),
  t2 AS (
    WITH RECURSIVE
      t1 AS (
        SELECT 1 AS level
        UNION ALL (
          WITH t3 AS (SELECT level + 1 FROM t1 WHERE level < 10)
          SELECT * FROM t3
        )
      )
    SELECT * FROM t1
  )
SELECT * FROM t2
-- !query schema
struct<level:int>
-- !query output
1
10
2
3
4
5
6
7
8
9


-- !query
SET spark.sql.legacy.ctePrecedencePolicy=EXCEPTION
-- !query schema
struct<key:string,value:string>
-- !query output
spark.sql.legacy.ctePrecedencePolicy	EXCEPTION


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT r1.level + 1, r1.data
  FROM r AS r1
  JOIN r AS r2 ON r2.data = r1.data
  WHERE r1.level < 9
)
SELECT * FROM r
-- !query schema
struct<level:int,data:int>
-- !query output
0	0
1	0
2	0
3	0
4	0
5	0
6	0
7	0
8	0
9	0


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  LEFT OUTER JOIN (
    SELECT 0 AS data
  ) AS t ON t.data = r.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query schema
struct<level:int,data:int>
-- !query output
0	0
1	0
2	0
3	0
4	0
5	0
6	0
7	0
8	0
9	0


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM (
    SELECT 0 AS data
  ) AS t
  LEFT OUTER JOIN r ON r.data = t.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM (
    SELECT 0 AS data
  ) AS t
  RIGHT OUTER JOIN r ON r.data = t.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query schema
struct<level:int,data:int>
-- !query output
0	0
1	0
2	0
3	0
4	0
5	0
6	0
7	0
8	0
9	0


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  RIGHT OUTER JOIN (
    SELECT 0 AS data
  ) AS t ON t.data = r.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  FULL OUTER JOIN (
    SELECT 0 AS data
  ) AS t ON t.data = r.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  LEFT SEMI JOIN (
    SELECT 0 AS data
  ) AS t ON t.data = r.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query schema
struct<level:int,data:int>
-- !query output
0	0
1	0
2	0
3	0
4	0
5	0
6	0
7	0
8	0
9	0


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, data
  FROM (
    SELECT 0 AS level, 0 AS data
  ) AS t
  LEFT SEMI JOIN r ON r.data = t.data AND r.level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  LEFT ANTI JOIN (
    SELECT -1 AS data
  ) AS t ON t.data = r.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query schema
struct<level:int,data:int>
-- !query output
0	0
1	0
2	0
3	0
4	0
5	0
6	0
7	0
8	0
9	0


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, data
  FROM (
    SELECT 0 AS level, 0 AS data
  ) AS t
  LEFT ANTI JOIN r ON r.data = t.data AND r.level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 1L)
  UNION ALL
  SELECT MAX(level) + 1, SUM(data) FROM r WHERE level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(n) AS (
    SELECT 1
    UNION ALL
    SELECT n+1 FROM r GROUP BY n)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
CREATE TEMPORARY VIEW rv AS
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output



-- !query
SELECT * FROM rv
-- !query schema
struct<level:int>
-- !query output
0
1
2
3
4
5
6
7
8
9


-- !query
DROP VIEW rv
-- !query schema
struct<>
-- !query output



-- !query
CREATE TABLE rt(level INT) USING csv
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
INSERT INTO rt SELECT * FROM r
-- !query schema
struct<>
-- !query output



-- !query
SELECT * from rt
-- !query schema
struct<level:int>
-- !query output
0
1
2
3
4
5
6
7
8
9


-- !query
DROP TABLE rt
-- !query schema
struct<>
-- !query output



-- !query
CREATE TABLE rt2(level INT) USING csv
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE r(level) AS (
    VALUES (0)
    UNION ALL
    SELECT level + 1 FROM r WHERE level < 9
)
FROM r
INSERT INTO rt2 SELECT *
INSERT INTO rt2 SELECT *
-- !query schema
struct<>
-- !query output



-- !query
SELECT * FROM rt2
-- !query schema
struct<level:int>
-- !query output
0
0
1
1
2
2
3
3
4
4
5
5
6
6
7
7
8
8
9
9


-- !query
DROP TABLE rt2
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE
  r1 AS (
    SELECT 0 AS level
    UNION ALL
    SELECT level + 1 FROM r1 WHERE level < 9
  ),
  r2 AS (
    SELECT 10 AS level
    UNION ALL
    SELECT level + 1 FROM r2 WHERE level < 19
  )
SELECT *
FROM r1
JOIN r2 ON r2.level = r1.level + 10
-- !query schema
struct<level:int,level:int>
-- !query output
0	10
1	11
2	12
3	13
4	14
5	15
6	16
7	17
8	18
9	19


-- !query
WITH RECURSIVE r AS (
  SELECT 0 AS level
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT *
FROM r AS r1
JOIN r AS r2 ON r2.level = r1.level
-- !query schema
struct<level:int,level:int>
-- !query output
0	0
1	1
2	2
3	3
4	4
5	5
6	6
7	7
8	8
9	9


-- !query
WITH RECURSIVE r2 AS (
  WITH RECURSIVE r1 AS (
    SELECT 0 AS innerlevel
    UNION ALL
    SELECT innerlevel + 1 FROM r1 WHERE innerlevel < 3
  )
  SELECT 0 AS outerlevel, innerlevel FROM r1
  UNION ALL
  SELECT outerlevel + 1, innerlevel FROM r2 WHERE outerlevel < 3
)
SELECT * FROM r2
-- !query schema
struct<outerlevel:int,innerlevel:int>
-- !query output
0	0
0	1
0	2
0	3
1	0
1	1
1	2
1	3
2	0
2	1
2	2
2	3
3	0
3	1
3	2
3	3


-- !query
WITH RECURSIVE r(level) AS (
  WITH RECURSIVE r(level) AS (
    VALUES 0
    UNION ALL
    SELECT level + 1 FROM r WHERE level < 3
  )
  SELECT * FROM r
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 3
)
SELECT * FROM r
-- !query schema
struct<level:int>
-- !query output
0
1
1
2
2
3
3


-- !query
WITH RECURSIVE r(level) AS (
  (WITH RECURSIVE r(level) AS (
    VALUES 0
    UNION ALL
    SELECT level + 1 FROM r WHERE level < 3
  )
  SELECT * FROM r)
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 3
)
SELECT * FROM r
-- !query schema
struct<level:int>
-- !query output
0
1
1
2
2
2
3
3
3
3


-- !query
CREATE TEMPORARY VIEW routes(origin, destination) AS VALUES
  ('New York', 'Washington'),
  ('New York', 'Boston'),
  ('Boston', 'New York'),
  ('Washington', 'Boston'),
  ('Washington', 'Raleigh')
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE destinations_from_new_york AS (
  SELECT 'New York' AS destination, ARRAY('New York') AS path, 0 AS length
  UNION ALL
  SELECT r.destination, CONCAT(d.path, ARRAY(r.destination)), d.length + 1
  FROM routes AS r
  JOIN destinations_from_new_york AS d ON d.destination = r.origin AND NOT ARRAY_CONTAINS(d.path, r.destination)
)
SELECT * FROM destinations_from_new_york
-- !query schema
struct<destination:string,path:array<string>,length:int>
-- !query output
Boston	["New York","Boston"]	1
Boston	["New York","Washington","Boston"]	2
New York	["New York"]	0
Raleigh	["New York","Washington","Raleigh"]	2
Washington	["New York","Washington"]	1


-- !query
DROP VIEW routes
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE fibonacci AS (
  VALUES (0, 1) AS t(a, b)
  UNION ALL
  SELECT b, a + b FROM fibonacci WHERE a < 10
)
SELECT a FROM fibonacci ORDER BY a
-- !query schema
struct<a:int>
-- !query output
0
1
1
2
3
5
8
13


-- !query
WITH RECURSIVE t1(a,b,c) AS (
    SELECT 1,1,1
    UNION ALL
    SELECT a+1,a+1,a+1 FROM t1)
SELECT a FROM t1 LIMIT 5
-- !query schema
struct<a:int>
-- !query output
1
2
3
4
5


-- !query
CREATE TABLE tb (next INT) USING json
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO tb VALUES (0), (1)
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE t(n) AS (
    SELECT 1
    UNION ALL
    SELECT next FROM t CROSS JOIN tb
    )
SELECT * FROM t LIMIT 63
-- !query schema
struct<n:int>
-- !query output
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1


-- !query
DROP TABLE tb
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE
    x(id) AS (SELECT 1 UNION SELECT 2),
    t(id, xid) AS (
        SELECT 0 AS id, 0 AS xid
        UNION ALL
        SELECT t.id + 1, xid * 10 + x.id FROM t CROSS JOIN x WHERE t.id < 3
    )
SELECT * FROM t
-- !query schema
struct<id:int,xid:int>
-- !query output
0	0
1	1
1	2
2	11
2	12
2	21
2	22
3	111
3	112
3	121
3	122
3	211
3	212
3	221
3	222


-- !query
WITH RECURSIVE t1(a, b) AS (
    SELECT 1, 1
    UNION ALL
    SELECT a + b, a FROM t1 WHERE a < 20
),
t2(n) AS (
    SELECT 1
    UNION ALL
    SELECT n + 1 FROM t2, t1 WHERE n + 1 = a
)
SELECT * FROM t2
-- !query schema
struct<n:int>
-- !query output
1
2
3


-- !query
WITH RECURSIVE t1 (n) AS (
    VALUES(1)
    UNION ALL
    (
    WITH t2(j) AS (
            SELECT n + 1 FROM t1
        ),
        t3(k) AS (
            SELECT j FROM t2
        )
        SELECT k FROM t3 WHERE k <= 5
    )
)
SELECT n FROM t1
-- !query schema
struct<n:int>
-- !query output
1
2
3
4
5


-- !query
WITH RECURSIVE r2(outerlevel1, innerlevel1) AS (
    WITH RECURSIVE r1 AS (
        SELECT 0 AS innerlevel
        UNION ALL
        SELECT innerlevel + 1 FROM r1 WHERE innerlevel < 3
    )
    SELECT 0 AS outerlevel, innerlevel FROM r1
    UNION ALL
    SELECT outerlevel1 + 1, innerlevel1 FROM r2 WHERE outerlevel1 < 3
)
SELECT * FROM r2
-- !query schema
struct<outerlevel1:int,innerlevel1:int>
-- !query output
0	0
0	1
0	2
0	3
1	0
1	1
1	2
1	3
2	0
2	1
2	2
2	3
3	0
3	1
3	2
3	3


-- !query
WITH RECURSIVE t1(n) AS (
    WITH t2(n) AS (SELECT * FROM t1)
    SELECT 1
    UNION ALL
    SELECT n+1 FROM t2 WHERE n < 5)
SELECT * FROM t1
-- !query schema
struct<n:int>
-- !query output
1
2
3
4
5


-- !query
WITH RECURSIVE t1 AS (
    WITH t2(n) AS (SELECT * FROM t1)
    SELECT 1 AS n
    UNION ALL
    SELECT n+1 FROM t2 WHERE n < 5)
SELECT * FROM t1
-- !query schema
struct<n:int>
-- !query output
1
2
3
4
5


-- !query
WITH RECURSIVE tmp(x) AS (
    values (1), (2), (3), (4), (5)
), rcte(x, y) AS (
    SELECT x, x FROM tmp WHERE x = 1
    UNION ALL
    SELECT x + 1, x FROM rcte WHERE x < 5
)
SELECT * FROM rcte
-- !query schema
struct<x:int,y:int>
-- !query output
1	1
2	1
3	2
4	3
5	4


-- !query
SET spark.sql.cteRecursionAnchorRowsLimitToConvertToLocalRelation=0
-- !query schema
struct<key:string,value:string>
-- !query output
spark.sql.cteRecursionAnchorRowsLimitToConvertToLocalRelation	0


-- !query
WITH RECURSIVE tmp(x) AS (
    values (1), (2), (3), (4), (5)
), rcte(x, y) AS (
    SELECT x, x FROM tmp WHERE x = 1
    UNION ALL
    SELECT x + 1, x FROM rcte WHERE x < 5
)
SELECT * FROM rcte
-- !query schema
struct<x:int,y:int>
-- !query output
1	1
2	1
3	2
4	3
5	4


-- !query
SET spark.sql.cteRecursionAnchorRowsLimitToConvertToLocalRelation=100
-- !query schema
struct<key:string,value:string>
-- !query output
spark.sql.cteRecursionAnchorRowsLimitToConvertToLocalRelation	100


-- !query
WITH RECURSIVE tmp(x) AS (
    values (1), (2), (3), (4), (5)
), rcte(x, y, z, t) AS (
    SELECT x, x, x, x FROM tmp WHERE x = 1
    UNION ALL
    SELECT x + 1, x, y + 1, y FROM rcte WHERE x < 5
)
SELECT * FROM rcte
-- !query schema
struct<x:int,y:int,z:int,t:int>
-- !query output
1	1	1	1
2	1	2	1
3	2	2	1
4	3	3	2
5	4	4	3


-- !query
WITH RECURSIVE randoms(val) AS (
    SELECT CAST(floor(rand(82374) * 5 + 1) AS INT)
    UNION ALL
    SELECT CAST(floor(rand(237685) * 5 + 1) AS INT)
    FROM randoms
)
SELECT val FROM randoms LIMIT 5
-- !query schema
struct<val:int>
-- !query output
1
3
4
4
5


-- !query
WITH RECURSIVE randoms(val) AS (
    SELECT CAST(UNIFORM(1, 6, 82374) AS INT)
    UNION ALL
    SELECT CAST(UNIFORM(1, 6, 237685) AS INT)
    FROM randoms
)
SELECT val FROM randoms LIMIT 5
-- !query schema
struct<val:int>
-- !query output
1
3
4
4
5


-- !query
WITH RECURSIVE randoms(val) AS (
    SELECT CAST(floor(randn(82374) * 5 + 1) AS INT)
    UNION ALL
    SELECT CAST(floor(randn(237685) * 5 + 1) AS INT)
    FROM randoms
)
SELECT val FROM randoms LIMIT 5
-- !query schema
struct<val:int>
-- !query output
-2
2
2
5
6


-- !query
WITH RECURSIVE randoms(val) AS (
    SELECT randstr(10, 82374)
    UNION ALL
    SELECT randstr(10, 237685)
    FROM randoms
)
SELECT val FROM randoms LIMIT 5
-- !query schema
struct<val:string>
-- !query output
IpXzdTW03I
Zj7uI2Ex6e
dBlWnfo7rO
fmfDBMf60f
kFeBV7dQWi


-- !query
WITH RECURSIVE randoms(val) AS (
    SELECT UUID(82374)
    UNION ALL
    SELECT UUID(237685)
    FROM randoms
)
SELECT val FROM randoms LIMIT 5
-- !query schema
struct<val:string>
-- !query output
19974dca-21f6-47ef-b58c-73908ab52aa0
4ea190e3-c088-4ddd-a545-fb431059ae3c
8b88900e-f862-468c-8d3b-828188116155
be4f5346-1c7f-4697-8a2c-1343347872c5
d0032efe-ae60-461b-8582-f6a7c649f238


-- !query
WITH RECURSIVE randoms(val) AS (
    SELECT ARRAY(1,2,3,4,5)
    UNION ALL
    SELECT SHUFFLE(ARRAY(1,2,3,4,5), 237685)
    FROM randoms
)
SELECT val FROM randoms LIMIT 5
-- !query schema
struct<val:array<int>>
-- !query output
[1,2,3,4,5]
[1,2,3,5,4]
[2,1,5,3,4]
[4,3,2,5,1]
[4,5,1,2,3]


-- !query
WITH RECURSIVE t1(n, m) AS (
    SELECT 1, CAST(1 AS BIGINT)
    UNION ALL
    SELECT n+1, n+1 FROM t1 WHERE n < 5)
SELECT * FROM t1
-- !query schema
struct<n:int,m:bigint>
-- !query output
1	1
2	2
3	3
4	4
5	5


-- !query
WITH RECURSIVE t1(n, m) AS (
    SELECT 1, 1
    UNION ALL
    SELECT n+1, CAST(n+1 AS BIGINT) FROM t1 WHERE n < 5)
SELECT * FROM t1
-- !query schema
struct<>
-- !query output
org.apache.spark.SparkException
{
  "errorClass" : "CANNOT_MERGE_INCOMPATIBLE_DATA_TYPE",
  "sqlState" : "42825",
  "messageParameters" : {
    "left" : "\"INT\"",
    "right" : "\"BIGINT\""
  }
}


-- !query
WITH RECURSIVE t1(n) AS (
    SELECT 1
    UNION ALL
    SELECT CASE WHEN n < 5 THEN n + 1 ELSE NULL END FROM t1
)
SELECT * FROM t1 LIMIT 25
-- !query schema
struct<n:int>
-- !query output
1
2
3
4
5
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL


-- !query
WITH RECURSIVE t1(n) AS (
    SELECT 1
    UNION ALL
    SELECT n + 1 FROM t1 WHERE n < 5
)
SELECT (SELECT SUM(n) FROM (SELECT * FROM t1)), (SELECT SUM(n) FROM (SELECT * FROM t1 LIMIT 3))
-- !query schema
struct<scalarsubquery():bigint,scalarsubquery():bigint>
-- !query output
15	6


-- !query
WITH RECURSIVE t1(n) AS (
    SELECT 1
    UNION ALL
    SELECT n + 1 FROM t1
)
SELECT (SELECT SUM(n) FROM (SELECT * FROM t1 LIMIT 5)), (SELECT SUM(n) FROM (SELECT * FROM t1 LIMIT 3))
-- !query schema
struct<scalarsubquery():bigint,scalarsubquery():bigint>
-- !query output
15	6


-- !query
WITH RECURSIVE t1(n) AS (
    SELECT 1
    UNION ALL
    SELECT n + 1 FROM t1
), t2(m) AS (
    SELECT (SELECT SUM(n) FROM (SELECT n FROM t1 LIMIT 10) AS sums)
    UNION ALL
    SELECT m + (SELECT SUM(n) FROM (SELECT n FROM t1 LIMIT 3) AS sums) FROM t2
)
SELECT * FROM t2 LIMIT 20
-- !query schema
struct<m:bigint>
-- !query output
103
109
115
121
127
133
139
145
151
157
163
169
55
61
67
73
79
85
91
97


-- !query
WITH RECURSIVE t1(n) AS (
    SELECT 1
    UNION ALL
    SELECT n + 1 FROM t1
)
    ((SELECT n FROM t1) UNION ALL (SELECT n FROM t1)) LIMIT 20
-- !query schema
struct<n:int>
-- !query output
1
10
11
12
13
14
15
16
17
18
19
2
20
3
4
5
6
7
8
9


-- !query
WITH RECURSIVE win(id, val) AS (
    SELECT 1, CAST(10 AS BIGINT)
    UNION ALL
    SELECT id + 1, SUM(val) OVER (ORDER BY id ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)
    FROM win WHERE id < 3
)
SELECT * FROM win
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE t1(n) AS (
    SELECT 1
    UNION ALL
    (SELECT n + 1 FROM t1 WHERE n < 5 ORDER BY n)
)
SELECT * FROM t1
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}
