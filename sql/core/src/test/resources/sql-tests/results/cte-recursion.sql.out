-- Automatically generated by SQLQueryTestSuite
-- !query
WITH r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "TABLE_OR_VIEW_NOT_FOUND",
  "sqlState" : "42P01",
  "messageParameters" : {
    "relationName" : "`r`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 67,
    "stopIndex" : 67,
    "fragment" : "r"
  } ]
}


-- !query
WITH RECURSIVE r AS (
  SELECT 0 AS level
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query schema
struct<level:int>
-- !query output
0
1
2
3
4
5
6
7
8
9


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query schema
struct<level:int>
-- !query output
0
1
2
3
4
5
6
7
8
9


-- !query
WITH RECURSIVE r(c) AS (
  SELECT 'a'
  UNION ALL
  SELECT c || char(ascii(substr(c, -1)) + 1) FROM r WHERE LENGTH(c) < 10
)
SELECT * FROM r
-- !query schema
struct<c:string>
-- !query output
a
ab
abc
abcd
abcde
abcdef
abcdefg
abcdefgh
abcdefghi
abcdefghij


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.SparkException
{
  "errorClass" : "RECURSION_LEVEL_LIMIT_EXCEEDED",
  "sqlState" : "42836",
  "messageParameters" : {
    "levelLimit" : "100"
  }
}


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT * FROM r LIMIT 10
-- !query schema
struct<level:int>
-- !query output
0
1
2
3
4
5
6
7
8
9


-- !query
WITH RECURSIVE r AS (
  SELECT 0 as level
  UNION
  SELECT (level + 1) % 10 FROM r
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "UNION_NOT_SUPPORTED_IN_RECURSIVE_CTE",
  "sqlState" : "42836",
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 100,
    "fragment" : "WITH RECURSIVE r AS (\n  SELECT 0 as level\n  UNION\n  SELECT (level + 1) % 10 FROM r\n)\nSELECT * FROM r"
  } ]
}


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION
  SELECT (level + 1) % 10 FROM r
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "UNION_NOT_SUPPORTED_IN_RECURSIVE_CTE",
  "sqlState" : "42836",
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 98,
    "fragment" : "WITH RECURSIVE r(level) AS (\n  VALUES 0\n  UNION\n  SELECT (level + 1) % 10 FROM r\n)\nSELECT * FROM r"
  } ]
}


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT level, level FROM r ORDER BY 1 LIMIT 10
-- !query schema
struct<>
-- !query output
org.apache.spark.SparkException
{
  "errorClass" : "RECURSION_LEVEL_LIMIT_EXCEEDED",
  "sqlState" : "42836",
  "messageParameters" : {
    "levelLimit" : "100"
  }
}


-- !query
WITH RECURSIVE r(level) AS (
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_CTE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level) AS (
  SELECT level + 1 FROM r WHERE level < 9
  UNION ALL
  VALUES 0
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "UNRESOLVED_COLUMN.WITHOUT_SUGGESTION",
  "sqlState" : "42703",
  "messageParameters" : {
    "objectName" : "`level`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 62,
    "stopIndex" : 66,
    "fragment" : "level"
  } ]
}


-- !query
WITH RECURSIVE t(n) AS (
    SELECT 1
    UNION ALL
    SELECT 2
)
SELECT * FROM t
-- !query schema
struct<n:int>
-- !query output
1
2


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  INTERSECT
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_CTE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE t(col) (
  SELECT 1
  UNION ALL
  SELECT (SELECT max(col) FROM t)
)
SELECT * FROM t
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH
  t1 AS (SELECT 1 as n),
  t2(n) AS (
    WITH RECURSIVE t3(n) AS (
      SELECT 1
      UNION ALL
      SELECT n+1 FROM (SELECT MAX(n) FROM t3)
    )
    SELECT * FROM t3
  )
SELECT * FROM t2
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE
  t1 AS (
    SELECT 1 AS level
    UNION (
      WITH t2 AS (SELECT level + 1 FROM t1 WHERE level < 10)
      SELECT * FROM t2
    )
  )
SELECT * FROM t1
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "TABLE_OR_VIEW_NOT_FOUND",
  "sqlState" : "42P01",
  "messageParameters" : {
    "relationName" : "`t1`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 100,
    "stopIndex" : 101,
    "fragment" : "t1"
  } ]
}


-- !query
SET spark.sql.legacy.ctePrecedencePolicy=CORRECTED
-- !query schema
struct<key:string,value:string>
-- !query output
spark.sql.legacy.ctePrecedencePolicy	CORRECTED


-- !query
WITH
  t1 AS (SELECT 1),
  t2 AS (
    WITH RECURSIVE
      t1 AS (
        SELECT 1 AS level
        UNION ALL (
          WITH t3 AS (SELECT level + 1 FROM t1 WHERE level < 10)
          SELECT * FROM t3
        )
      )
    SELECT * FROM t1
  )
SELECT * FROM t2
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "TABLE_OR_VIEW_NOT_FOUND",
  "sqlState" : "42P01",
  "messageParameters" : {
    "relationName" : "`t1`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 159,
    "stopIndex" : 160,
    "fragment" : "t1"
  } ]
}


-- !query
SET spark.sql.legacy.ctePrecedencePolicy=EXCEPTION
-- !query schema
struct<key:string,value:string>
-- !query output
spark.sql.legacy.ctePrecedencePolicy	EXCEPTION


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT r1.level + 1, r1.data
  FROM r AS r1
  JOIN r AS r2 ON r2.data = r1.data
  WHERE r1.level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.NUMBER",
  "sqlState" : "42836",
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 183,
    "fragment" : "WITH RECURSIVE r(level, data) AS (\n  VALUES (0, 0)\n  UNION ALL\n  SELECT r1.level + 1, r1.data\n  FROM r AS r1\n  JOIN r AS r2 ON r2.data = r1.data\n  WHERE r1.level < 9\n)\nSELECT * FROM r"
  } ]
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  LEFT OUTER JOIN (
    SELECT 0 AS data
  ) AS t ON t.data = r.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query schema
struct<level:int,data:int>
-- !query output
0	0
1	0
2	0
3	0
4	0
5	0
6	0
7	0
8	0
9	0


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM (
    SELECT 0 AS data
  ) AS t
  LEFT OUTER JOIN r ON r.data = t.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM (
    SELECT 0 AS data
  ) AS t
  RIGHT OUTER JOIN r ON r.data = t.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query schema
struct<level:int,data:int>
-- !query output
0	0
1	0
2	0
3	0
4	0
5	0
6	0
7	0
8	0
9	0


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  RIGHT OUTER JOIN (
    SELECT 0 AS data
  ) AS t ON t.data = r.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  FULL OUTER JOIN (
    SELECT 0 AS data
  ) AS t ON t.data = r.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  LEFT SEMI JOIN (
    SELECT 0 AS data
  ) AS t ON t.data = r.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query schema
struct<level:int,data:int>
-- !query output
0	0
1	0
2	0
3	0
4	0
5	0
6	0
7	0
8	0
9	0


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, data
  FROM (
    SELECT 0 AS level, 0 AS data
  ) AS t
  LEFT SEMI JOIN r ON r.data = t.data AND r.level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  LEFT ANTI JOIN (
    SELECT -1 AS data
  ) AS t ON t.data = r.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query schema
struct<level:int,data:int>
-- !query output
0	0
1	0
2	0
3	0
4	0
5	0
6	0
7	0
8	0
9	0


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, data
  FROM (
    SELECT 0 AS level, 0 AS data
  ) AS t
  LEFT ANTI JOIN r ON r.data = t.data AND r.level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 1L)
  UNION ALL
  SELECT MAX(level) + 1, SUM(data) FROM r WHERE level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(n) AS (
    SELECT 1
    UNION ALL
    SELECT n+1 FROM r GROUP BY n)
SELECT * FROM r
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
CREATE TEMPORARY VIEW rv AS
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query schema
struct<>
-- !query output



-- !query
SELECT * FROM rv
-- !query schema
struct<level:int>
-- !query output
0
1
2
3
4
5
6
7
8
9


-- !query
DROP VIEW rv
-- !query schema
struct<>
-- !query output



-- !query
CREATE TABLE rt(level INT) USING csv
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
INSERT INTO rt SELECT * FROM r
-- !query schema
struct<>
-- !query output



-- !query
SELECT * from rt
-- !query schema
struct<level:int>
-- !query output
0
1
2
3
4
5
6
7
8
9


-- !query
DROP TABLE rt
-- !query schema
struct<>
-- !query output



-- !query
CREATE TABLE rt2(level INT) USING csv
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE r(level) AS (
    VALUES (0)
    UNION ALL
    SELECT level + 1 FROM r WHERE level < 9
)
FROM r
INSERT INTO rt2 SELECT *
INSERT INTO rt2 SELECT *
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "RECURSIVE_CTE_WHEN_INLINING_IS_FORCED",
  "sqlState" : "42836",
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 160,
    "fragment" : "WITH RECURSIVE r(level) AS (\n    VALUES (0)\n    UNION ALL\n    SELECT level + 1 FROM r WHERE level < 9\n)\nFROM r\nINSERT INTO rt2 SELECT *\nINSERT INTO rt2 SELECT *"
  } ]
}


-- !query
DROP TABLE rt2
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE
  r1 AS (
    SELECT 0 AS level
    UNION ALL
    SELECT level + 1 FROM r1 WHERE level < 9
  ),
  r2 AS (
    SELECT 10 AS level
    UNION ALL
    SELECT level + 1 FROM r2 WHERE level < 19
  )
SELECT *
FROM r1
JOIN r2 ON r2.level = r1.level + 10
-- !query schema
struct<level:int,level:int>
-- !query output
0	10
1	11
2	12
3	13
4	14
5	15
6	16
7	17
8	18
9	19


-- !query
WITH RECURSIVE r AS (
  SELECT 0 AS level
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT *
FROM r AS r1
JOIN r AS r2 ON r2.level = r1.level
-- !query schema
struct<level:int,level:int>
-- !query output
0	0
1	1
2	2
3	3
4	4
5	5
6	6
7	7
8	8
9	9


-- !query
WITH RECURSIVE r2 AS (
  WITH RECURSIVE r1 AS (
    SELECT 0 AS innerlevel
    UNION ALL
    SELECT innerlevel + 1 FROM r1 WHERE innerlevel < 3
  )
  SELECT 0 AS outerlevel, innerlevel FROM r1
  UNION ALL
  SELECT outerlevel + 1, innerlevel FROM r2 WHERE outerlevel < 3
)
SELECT * FROM r2
-- !query schema
struct<outerlevel:int,innerlevel:int>
-- !query output
0	0
0	1
0	2
0	3
1	0
1	1
1	2
1	3
2	0
2	1
2	2
2	3
3	0
3	1
3	2
3	3


-- !query
WITH RECURSIVE r(level) AS (
  WITH RECURSIVE r(level) AS (
    VALUES 0
    UNION ALL
    SELECT level + 1 FROM r WHERE level < 3
  )
  SELECT * FROM r
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 3
)
SELECT * FROM r
-- !query schema
struct<level:int>
-- !query output
0
1
1
2
2
3
3


-- !query
WITH RECURSIVE r(level) AS (
  (WITH RECURSIVE r(level) AS (
    VALUES 0
    UNION ALL
    SELECT level + 1 FROM r WHERE level < 3
  )
  SELECT * FROM r)
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 3
)
SELECT * FROM r
-- !query schema
struct<level:int>
-- !query output
0
1
1
2
2
2
3
3
3
3


-- !query
CREATE TEMPORARY VIEW routes(origin, destination) AS VALUES
  ('New York', 'Washington'),
  ('New York', 'Boston'),
  ('Boston', 'New York'),
  ('Washington', 'Boston'),
  ('Washington', 'Raleigh')
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE destinations_from_new_york AS (
  SELECT 'New York' AS destination, ARRAY('New York') AS path, 0 AS length
  UNION ALL
  SELECT r.destination, CONCAT(d.path, ARRAY(r.destination)), d.length + 1
  FROM routes AS r
  JOIN destinations_from_new_york AS d ON d.destination = r.origin AND NOT ARRAY_CONTAINS(d.path, r.destination)
)
SELECT * FROM destinations_from_new_york
-- !query schema
struct<destination:string,path:array<string>,length:int>
-- !query output
Boston	["New York","Boston"]	1
Boston	["New York","Washington","Boston"]	2
New York	["New York"]	0
Raleigh	["New York","Washington","Raleigh"]	2
Washington	["New York","Washington"]	1


-- !query
DROP VIEW routes
-- !query schema
struct<>
-- !query output



-- !query
WITH RECURSIVE fibonacci AS (
  VALUES (0, 1) AS t(a, b)
  UNION ALL
  SELECT b, a + b FROM fibonacci WHERE a < 10
)
SELECT a FROM fibonacci ORDER BY a
-- !query schema
struct<a:int>
-- !query output
0
1
1
2
3
5
8
13
