-- Automatically generated by SQLQueryTestSuite
-- !query
set spark.sql.optimizer.supportNestedCorrelatedSubqueries.enabled=true
-- !query schema
struct<key:string,value:string>
-- !query output
spark.sql.optimizer.supportNestedCorrelatedSubqueries.enabled	true


-- !query
set spark.sql.optimizer.supportNestedCorrelatedSubqueriesForScalarSubqueries.enabled=true
-- !query schema
struct<key:string,value:string>
-- !query output
spark.sql.optimizer.supportNestedCorrelatedSubqueriesForScalarSubqueries.enabled	true


-- !query
DROP TABLE IF EXISTS myt1
-- !query schema
struct<>
-- !query output



-- !query
DROP TABLE IF EXISTS myt2
-- !query schema
struct<>
-- !query output



-- !query
DROP TABLE IF EXISTS myt3
-- !query schema
struct<>
-- !query output



-- !query
CREATE TABLE myt1(a INT, b INT, c INT)
-- !query schema
struct<>
-- !query output



-- !query
CREATE TABLE myt2(a INT, b INT, c INT)
-- !query schema
struct<>
-- !query output



-- !query
CREATE TABLE myt3(a INT, b INT, c INT)
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO myt1 VALUES (0, 0, 0), (1, 1, 1), (2, 2, 2), (3, 3, 3), (NULL, NULL, NULL)
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO myt2 VALUES (0, 0, 0), (1, 1, 1), (2, 2, 2), (3, 3, 3), (NULL, NULL, NULL)
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO myt3 VALUES (0, 0, 0), (1, 1, 1), (2, 2, 2), (3, 3, 3), (NULL, NULL, NULL)
-- !query schema
struct<>
-- !query output



-- !query
SELECT *
FROM myt1
WHERE myt1.a = (
  SELECT MAX(myt2.a)
  FROM myt2
  WHERE myt2.a = (
   SELECT MAX(myt3.a)
   FROM myt3
   WHERE myt3.b > myt2.b AND myt3.c > myt1.c
  ) AND myt2.b > myt1.b
)
-- !query schema
struct<a:int,b:int,c:int>
-- !query output



-- !query
SELECT *
FROM myt1
WHERE myt1.a = (
  SELECT MAX(myt2.a)
  FROM myt2
  WHERE myt2.a = (
   SELECT MAX(myt3.a)
   FROM myt3
   WHERE myt3.b = myt2.b AND myt3.c = myt1.c
  ) AND myt2.b = myt1.b
)
-- !query schema
struct<a:int,b:int,c:int>
-- !query output
0	0	0
1	1	1
2	2	2
3	3	3


-- !query
SELECT *
FROM myt1
WHERE myt1.a = (
  SELECT COUNT(myt2.a)
  FROM myt2
  WHERE myt2.a = (
   SELECT COUNT(myt3.a)
   FROM myt3
   WHERE myt3.b > myt2.b AND myt3.c > myt1.c
  ) AND myt2.b > myt1.b
)
-- !query schema
struct<a:int,b:int,c:int>
-- !query output
0	0	0


-- !query
SELECT *
FROM myt1
WHERE myt1.a = (
  SELECT COUNT(myt2.a)
  FROM myt2
  WHERE myt2.a = (
   SELECT COUNT(myt3.a)
   FROM myt3
   WHERE myt3.b = myt2.b AND myt3.c = myt1.c
  ) AND myt2.b = myt1.b
)
-- !query schema
struct<a:int,b:int,c:int>
-- !query output
0	0	0
1	1	1


-- !query
SELECT myt1.a, (
    SELECT (
            SELECT MAX(myt3.a)
            FROM myt3
            WHERE myt3.b > myt2.b AND myt3.c > myt1.c
        )
    FROM myt2
)
FROM myt1
-- !query schema
struct<>
-- !query output
org.apache.spark.SparkRuntimeException
{
  "errorClass" : "SCALAR_SUBQUERY_TOO_MANY_ROWS",
  "sqlState" : "21000"
}


-- !query
SELECT myt1.a, (
    SELECT (
            SELECT MAX(myt3.a)
            FROM myt3
            WHERE myt3.b = myt2.b AND myt3.c = myt1.c
        )
    FROM myt2
)
FROM myt1
-- !query schema
struct<a:int,scalarsubquery(c):int>
-- !query output
0	0
1	1
2	2
3	3
NULL	NULL


-- !query
SELECT myt1.a, (
    SELECT (
            SELECT COUNT(myt3.a)
            FROM myt3
            WHERE myt3.b > myt2.b AND myt3.c > myt1.c
        )
    FROM myt2
)
FROM myt1
-- !query schema
struct<>
-- !query output
org.apache.spark.SparkRuntimeException
{
  "errorClass" : "SCALAR_SUBQUERY_TOO_MANY_ROWS",
  "sqlState" : "21000"
}


-- !query
SELECT myt1.a, (
    SELECT (
            SELECT COUNT(myt3.a)
            FROM myt3
            WHERE myt3.b = myt2.b AND myt3.c = myt1.c
        )
    FROM myt2
)
FROM myt1
-- !query schema
struct<a:int,scalarsubquery(c):bigint>
-- !query output
0	1
1	1
2	1
3	1
NULL	NULL


-- !query
SELECT MIN(
        SELECT MAX(
            SELECT MAX(myt3.a)
            FROM myt3
            WHERE myt3.b > myt2.b AND myt3.c > myt1.c
        )
        FROM myt2
    )
FROM myt1
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'MAX'",
    "hint" : ""
  }
}


-- !query
SELECT MIN(
        SELECT MAX(
            SELECT MAX(myt3.a)
            FROM myt3
            WHERE myt3.b = myt2.b AND myt3.c = myt1.c
        )
        FROM myt2
    )
FROM myt1
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'MAX'",
    "hint" : ""
  }
}


-- !query
SELECT COUNT(
        SELECT COUNT(
            SELECT COUNT(myt3.a)
            FROM myt3
            WHERE myt3.b > myt2.b AND myt3.c > myt1.c
        )
        FROM myt2
    )
FROM myt1
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'COUNT'",
    "hint" : ""
  }
}


-- !query
SELECT COUNT(
        SELECT COUNT(
            SELECT COUNT(myt3.a)
            FROM myt3
            WHERE myt3.b = myt2.b AND myt3.c = myt1.c
        )
        FROM myt2
    )
FROM myt1
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'COUNT'",
    "hint" : ""
  }
}


-- !query
SELECT b, MAX(myt1.a)
FROM myt1
GROUP BY b
HAVING (
    SELECT MAX(myt2.a)
    FROM myt2
    WHERE myt2.a = (
        SELECT MAX(myt3.a)
        FROM myt3
        WHERE myt3.a > MAX(myt1.a)
    ) AND myt2.b > myt1.b
)
-- !query schema
struct<b:int,max(a):int>
-- !query output
0	0
1	1
2	2


-- !query
SELECT b, MAX(myt1.a)
FROM myt1
GROUP BY b
HAVING (
    SELECT MAX(myt2.a)
    FROM myt2
    WHERE myt2.a = (
        SELECT MAX(myt3.a)
        FROM myt3
        WHERE myt3.a = MAX(myt1.a)
    ) AND myt2.b = myt1.b
)
-- !query schema
struct<b:int,max(a):int>
-- !query output
1	1
2	2
3	3


-- !query
SELECT b, MAX(myt1.a)
FROM myt1
GROUP BY b
HAVING (
    SELECT COUNT(myt2.a)
    FROM myt2
    WHERE myt2.a = (
        SELECT COUNT(myt3.a)
        FROM myt3
        WHERE myt3.a > MAX(myt1.a)
    ) AND myt2.b > myt1.b
)
-- !query schema
struct<b:int,max(a):int>
-- !query output
0	0
1	1


-- !query
SELECT b, MAX(myt1.a)
FROM myt1
GROUP BY b
HAVING (
    SELECT COUNT(myt2.a)
    FROM myt2
    WHERE myt2.a = (
        SELECT COUNT(myt3.a)
        FROM myt3
        WHERE myt3.a = MAX(myt1.a)
    ) AND myt2.b = myt1.b
)
-- !query schema
struct<b:int,max(a):int>
-- !query output
1	1


-- !query
SELECT myt1.a
FROM myt1
WHERE EXISTS (
  SELECT 1
  FROM myt2
  WHERE myt2.a = (
    SELECT MAX(myt3.a)
    FROM myt3
    WHERE myt3.b > myt2.b AND myt3.c > myt1.c
  ) AND myt2.b > myt1.b
)
-- !query schema
struct<>
-- !query output
org.apache.spark.SparkException
{
  "errorClass" : "INTERNAL_ERROR",
  "sqlState" : "XX000",
  "messageParameters" : {
    "message" : "The Spark SQL phase optimization failed with an internal error. You hit a bug in Spark or the Spark plugins you use. Please, report this bug to the corresponding communities or vendors, and provide the full stack trace."
  }
}


-- !query
SELECT myt1.a
FROM myt1
WHERE myt1.b = (
  SELECT myt2.b
  FROM myt2
  WHERE EXISTS (
    SELECT 1
    FROM myt3
    WHERE myt3.b > myt2.b AND myt3.c > myt1.c
  ) AND myt2.b > myt1.b
)
-- !query schema
struct<>
-- !query output
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "NESTED_REFERENCES_IN_SUBQUERY_NOT_SUPPORTED",
  "sqlState" : "0A000",
  "messageParameters" : {
    "expression" : "spark_catalog.default.myt1.c"
  }
}


-- !query
SELECT 1 FROM (SELECT 1) t0(c0) WHERE (SELECT (SELECT c0)) = 1
-- !query schema
struct<1:int>
-- !query output
1


-- !query
DROP TABLE IF EXISTS table_integers
-- !query schema
struct<>
-- !query output



-- !query
CREATE TABLE table_integers(i INTEGER)
-- !query schema
struct<>
-- !query output



-- !query
INSERT INTO table_integers VALUES (1), (2), (3), (NULL)
-- !query schema
struct<>
-- !query output



-- !query
SELECT i, (SELECT (SELECT 42+i1.i)+42+i1.i) AS j FROM table_integers i1 ORDER BY i
-- !query schema
struct<i:int,j:int>
-- !query output
NULL	NULL
1	86
2	88
3	90


-- !query
SELECT i, (SELECT (SELECT (SELECT (SELECT 42+i1.i)++i1.i)+42+i1.i)+42+i1.i) AS j FROM table_integers i1 ORDER BY i
-- !query schema
struct<i:int,j:int>
-- !query output
NULL	NULL
1	130
2	134
3	138


-- !query
SELECT i, (SELECT (SELECT (SELECT (SELECT i1.i+i1.i+i1.i+i1.i+i1.i)))) AS j FROM table_integers i1 ORDER BY i
-- !query schema
struct<i:int,j:int>
-- !query output
NULL	NULL
1	5
2	10
3	15


-- !query
SELECT i, (SELECT (SELECT (SELECT (SELECT i1.i+i1.i+i1.i+i1.i+i1.i+i2.i) FROM table_integers i2 WHERE i2.i=i1.i))) AS j FROM table_integers i1 ORDER BY i
-- !query schema
struct<>
-- !query output
org.apache.spark.SparkRuntimeException
{
  "errorClass" : "SCALAR_SUBQUERY_TOO_MANY_ROWS",
  "sqlState" : "21000"
}


-- !query
SELECT i, (SELECT SUM(s1.i) FROM (SELECT i FROM table_integers WHERE i=i1.i) s1 LEFT OUTER JOIN table_integers s2 ON s1.i=s2.i) AS j FROM table_integers i1 ORDER BY i
-- !query schema
struct<i:int,j:bigint>
-- !query output
NULL	NULL
1	1
2	2
3	3


-- !query
SELECT i, (SELECT SUM(s1.i) FROM (SELECT i FROM table_integers WHERE i<>i1.i) s1 LEFT OUTER JOIN table_integers s2 ON s1.i=s2.i) AS j FROM table_integers i1 ORDER BY i
-- !query schema
struct<i:int,j:bigint>
-- !query output
NULL	NULL
1	5
2	4
3	3


-- !query
SELECT i, (SELECT SUM(ss2.i) FROM (SELECT i FROM table_integers s1 WHERE i=i1.i) ss2) AS j FROM table_integers i1 ORDER BY i
-- !query schema
struct<i:int,j:bigint>
-- !query output
NULL	NULL
1	1
2	2
3	3


-- !query
SELECT i, (SELECT * FROM (SELECT (SELECT 42+i1.i)) s1) AS j FROM table_integers i1 ORDER BY i
-- !query schema
struct<i:int,j:int>
-- !query output
NULL	NULL
1	43
2	44
3	45


-- !query
SELECT i, (SELECT s1.k+s2.k FROM (SELECT (SELECT 42+i1.i) AS k) s1, (SELECT (SELECT 42+i1.i) AS k) s2) AS j FROM table_integers i1 ORDER BY i
-- !query schema
struct<i:int,j:int>
-- !query output
NULL	NULL
1	86
2	88
3	90


-- !query
SELECT i, (SELECT s1.k+s2.k FROM (SELECT (SELECT 42+i1.i) AS k) s1 LEFT OUTER JOIN (SELECT (SELECT 42+i1.i) AS k) s2 ON s1.k=s2.k) AS j FROM table_integers i1 ORDER BY i
-- !query schema
struct<i:int,j:int>
-- !query output
NULL	NULL
1	86
2	88
3	90


-- !query
SELECT i, (SELECT i1.i IN (1, 2, 3, 4, 5, 6, 7, 8)) AS j FROM table_integers i1 ORDER BY i
-- !query schema
struct<i:int,j:boolean>
-- !query output
NULL	NULL
1	true
2	true
3	true
