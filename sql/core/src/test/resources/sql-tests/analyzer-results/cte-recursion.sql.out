-- Automatically generated by SQLQueryTestSuite
-- !query
WITH r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query analysis
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "TABLE_OR_VIEW_NOT_FOUND",
  "sqlState" : "42P01",
  "messageParameters" : {
    "relationName" : "`r`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 67,
    "stopIndex" : 67,
    "fragment" : "r"
  } ]
}


-- !query
WITH RECURSIVE r AS (
  SELECT 0 AS level
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r
:     +- UnionLoop xxxx
:        :- Project [0 AS level#x]
:        :  +- OneRowRelation
:        +- Project [(level#x + 1) AS (level + 1)#x]
:           +- Filter (level#x < 9)
:              +- SubqueryAlias r
:                 +- UnionLoopRef xxxx, [level#x], false
+- Project [level#x]
   +- SubqueryAlias r
      +- CTERelationRef xxxx, true, [level#x], false, false


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r
:     +- Project [col1#x AS level#x]
:        +- UnionLoop xxxx
:           :- LocalRelation [col1#x]
:           +- Project [(level#x + 1) AS (level + 1)#x]
:              +- Filter (level#x < 9)
:                 +- SubqueryAlias r
:                    +- Project [col1#x AS level#x]
:                       +- UnionLoopRef xxxx, [col1#x], false
+- Project [level#x]
   +- SubqueryAlias r
      +- CTERelationRef xxxx, true, [level#x], false, false


-- !query
WITH RECURSIVE r(c) AS (
  SELECT 'a'
  UNION ALL
  SELECT c || char(ascii(substr(c, -1)) + 1) FROM r WHERE LENGTH(c) < 10
)
SELECT * FROM r
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r
:     +- Project [a#x AS c#x]
:        +- UnionLoop xxxx
:           :- Project [a AS a#x]
:           :  +- OneRowRelation
:           +- Project [concat(c#x, char(cast((ascii(substr(c#x, -1, 2147483647)) + 1) as bigint))) AS concat(c, char((ascii(substr(c, -1, 2147483647)) + 1)))#x]
:              +- Filter (length(c#x) < 10)
:                 +- SubqueryAlias r
:                    +- Project [a#x AS c#x]
:                       +- UnionLoopRef xxxx, [a#x], false
+- Project [c#x]
   +- SubqueryAlias r
      +- CTERelationRef xxxx, true, [c#x], false, false


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT * FROM r
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r
:     +- Project [col1#x AS level#x]
:        +- UnionLoop xxxx
:           :- LocalRelation [col1#x]
:           +- Project [(level#x + 1) AS (level + 1)#x]
:              +- SubqueryAlias r
:                 +- Project [col1#x AS level#x]
:                    +- UnionLoopRef xxxx, [col1#x], false
+- Project [level#x]
   +- SubqueryAlias r
      +- CTERelationRef xxxx, true, [level#x], false, false


-- !query
CREATE TEMPORARY VIEW ZeroAndOne(current, next) AS VALUES
    (0,0),
    (0,1),
    (1,0),
    (1,1)
-- !query analysis
CreateViewCommand `ZeroAndOne`, [(current,None), (next,None)], VALUES
    (0,0),
    (0,1),
    (1,0),
    (1,1), false, false, LocalTempView, UNSUPPORTED, true
   +- LocalRelation [col1#x, col2#x]


-- !query
WITH RECURSIVE t(n) AS (
    SELECT 1
    UNION ALL
    SELECT next FROM t LEFT JOIN ZeroAndOne ON n = current
)
SELECT * FROM t
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t
:     +- Project [1#x AS n#x]
:        +- UnionLoop xxxx
:           :- Project [1 AS 1#x]
:           :  +- OneRowRelation
:           +- Project [next#x]
:              +- Join LeftOuter, (n#x = current#x)
:                 :- SubqueryAlias t
:                 :  +- Project [1#x AS n#x]
:                 :     +- UnionLoopRef xxxx, [1#x], false
:                 +- SubqueryAlias zeroandone
:                    +- View (`ZeroAndOne`, [current#x, next#x])
:                       +- Project [cast(col1#x as int) AS current#x, cast(col2#x as int) AS next#x]
:                          +- LocalRelation [col1#x, col2#x]
+- Project [n#x]
   +- SubqueryAlias t
      +- CTERelationRef xxxx, true, [n#x], false, false


-- !query
DROP VIEW ZeroAndOne
-- !query analysis
DropTempViewCommand ZeroAndOne


-- !query
CREATE TEMPORARY VIEW ZeroAndOne(current, next) AS VALUES
    (0,0),
    (0,1),
    (1,0),
    (1,1)
-- !query analysis
CreateViewCommand `ZeroAndOne`, [(current,None), (next,None)], VALUES
    (0,0),
    (0,1),
    (1,0),
    (1,1), false, false, LocalTempView, UNSUPPORTED, true
   +- LocalRelation [col1#x, col2#x]


-- !query
SET spark.sql.cteRecursionRowLimit=25
-- !query analysis
SetCommand (spark.sql.cteRecursionRowLimit,Some(25))


-- !query
WITH RECURSIVE t(n) AS (
    SELECT 1
    UNION ALL
    SELECT next FROM t LEFT JOIN ZeroAndOne ON n = current
    )
SELECT * FROM t LIMIT 30
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t
:     +- Project [1#x AS n#x]
:        +- UnionLoop xxxx
:           :- Project [1 AS 1#x]
:           :  +- OneRowRelation
:           +- Project [next#x]
:              +- Join LeftOuter, (n#x = current#x)
:                 :- SubqueryAlias t
:                 :  +- Project [1#x AS n#x]
:                 :     +- UnionLoopRef xxxx, [1#x], false
:                 +- SubqueryAlias zeroandone
:                    +- View (`ZeroAndOne`, [current#x, next#x])
:                       +- Project [cast(col1#x as int) AS current#x, cast(col2#x as int) AS next#x]
:                          +- LocalRelation [col1#x, col2#x]
+- GlobalLimit 30
   +- LocalLimit 30
      +- Project [n#x]
         +- SubqueryAlias t
            +- CTERelationRef xxxx, true, [n#x], false, false


-- !query
RESET spark.sql.cteRecursionRowLimit
-- !query analysis
ResetCommand spark.sql.cteRecursionRowLimit


-- !query
DROP VIEW ZeroAndOne
-- !query analysis
DropTempViewCommand ZeroAndOne


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT * FROM r LIMIT 10
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r
:     +- Project [col1#x AS level#x]
:        +- UnionLoop xxxx
:           :- LocalRelation [col1#x]
:           +- Project [(level#x + 1) AS (level + 1)#x]
:              +- SubqueryAlias r
:                 +- Project [col1#x AS level#x]
:                    +- UnionLoopRef xxxx, [col1#x], false
+- GlobalLimit 10
   +- LocalLimit 10
      +- Project [level#x]
         +- SubqueryAlias r
            +- CTERelationRef xxxx, true, [level#x], false, false


-- !query
WITH RECURSIVE r AS (
  SELECT 0 as level
  UNION
  SELECT (level + 1) % 10 FROM r
)
SELECT * FROM r
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "UNION_NOT_SUPPORTED_IN_RECURSIVE_CTE",
  "sqlState" : "42836",
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 100,
    "fragment" : "WITH RECURSIVE r AS (\n  SELECT 0 as level\n  UNION\n  SELECT (level + 1) % 10 FROM r\n)\nSELECT * FROM r"
  } ]
}


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION
  SELECT (level + 1) % 10 FROM r
)
SELECT * FROM r
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "UNION_NOT_SUPPORTED_IN_RECURSIVE_CTE",
  "sqlState" : "42836",
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 98,
    "fragment" : "WITH RECURSIVE r(level) AS (\n  VALUES 0\n  UNION\n  SELECT (level + 1) % 10 FROM r\n)\nSELECT * FROM r"
  } ]
}


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT level, level FROM r ORDER BY 1 LIMIT 10
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r
:     +- Project [col1#x AS level#x]
:        +- UnionLoop xxxx
:           :- LocalRelation [col1#x]
:           +- Project [(level#x + 1) AS (level + 1)#x]
:              +- SubqueryAlias r
:                 +- Project [col1#x AS level#x]
:                    +- UnionLoopRef xxxx, [col1#x], false
+- GlobalLimit 10
   +- LocalLimit 10
      +- Sort [level#x ASC NULLS FIRST], true
         +- Project [level#x, level#x]
            +- SubqueryAlias r
               +- CTERelationRef xxxx, true, [level#x], false, false


-- !query
WITH RECURSIVE r(level) AS (
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_CTE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level) AS (
  SELECT level + 1 FROM r WHERE level < 9
  UNION ALL
  VALUES 0
)
SELECT * FROM r
-- !query analysis
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "UNRESOLVED_COLUMN.WITHOUT_SUGGESTION",
  "sqlState" : "42703",
  "messageParameters" : {
    "objectName" : "`level`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 62,
    "stopIndex" : 66,
    "fragment" : "level"
  } ]
}


-- !query
WITH RECURSIVE t(n) AS (
    SELECT 1
    UNION ALL
    SELECT 2
)
SELECT * FROM t
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t
:     +- Project [1#x AS n#x]
:        +- Union false, false
:           :- Project [1 AS 1#x]
:           :  +- OneRowRelation
:           +- Project [2 AS 2#x]
:              +- OneRowRelation
+- Project [n#x]
   +- SubqueryAlias t
      +- CTERelationRef xxxx, true, [n#x], false, false, 2


-- !query
WITH RECURSIVE r(level) AS (
  VALUES 0
  INTERSECT
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_CTE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE t(col) (
  SELECT 1
  UNION ALL
  SELECT (SELECT max(col) FROM t)
)
SELECT * FROM t LIMIT 5
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t
:     +- Project [1#x AS col#x]
:        +- UnionLoop xxxx
:           :- Project [1 AS 1#x]
:           :  +- OneRowRelation
:           +- Project [scalar-subquery#x [] AS scalarsubquery()#x]
:              :  +- Aggregate [max(col#x) AS max(col)#x]
:              :     +- SubqueryAlias t
:              :        +- Project [1#x AS col#x]
:              :           +- UnionLoopRef xxxx, [1#x], false
:              +- OneRowRelation
+- GlobalLimit 5
   +- LocalLimit 5
      +- Project [col#x]
         +- SubqueryAlias t
            +- CTERelationRef xxxx, true, [col#x], false, false


-- !query
WITH
  t1 AS (SELECT 1 as n),
  t2(n) AS (
    WITH RECURSIVE t3(n) AS (
      SELECT 1
      UNION ALL
      SELECT n+1 FROM (SELECT MAX(n) FROM t3)
    )
    SELECT * FROM t3
  )
SELECT * FROM t2
-- !query analysis
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE
  t1 AS (
    SELECT 1 AS level
    UNION ALL (
      WITH t2 AS (SELECT level + 1 FROM t1 WHERE level < 10)
      SELECT * FROM t2
    )
  )
SELECT * FROM t1
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t1
:     +- UnionLoop xxxx
:        :- Project [1 AS level#x]
:        :  +- OneRowRelation
:        +- WithCTE
:           :- CTERelationDef xxxx, false
:           :  +- SubqueryAlias t2
:           :     +- Project [(level#x + 1) AS (level + 1)#x]
:           :        +- Filter (level#x < 10)
:           :           +- SubqueryAlias t1
:           :              +- UnionLoopRef xxxx, [level#x], false
:           +- Project [(level + 1)#x]
:              +- SubqueryAlias t2
:                 +- CTERelationRef xxxx, true, [(level + 1)#x], false, false
+- Project [level#x]
   +- SubqueryAlias t1
      +- CTERelationRef xxxx, true, [level#x], false, false


-- !query
SET spark.sql.legacy.ctePrecedencePolicy=CORRECTED
-- !query analysis
SetCommand (spark.sql.legacy.ctePrecedencePolicy,Some(CORRECTED))


-- !query
WITH
  t1 AS (SELECT 1),
  t2 AS (
    WITH RECURSIVE
      t1 AS (
        SELECT 1 AS level
        UNION ALL (
          WITH t3 AS (SELECT level + 1 FROM t1 WHERE level < 10)
          SELECT * FROM t3
        )
      )
    SELECT * FROM t1
  )
SELECT * FROM t2
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t1
:     +- Project [1 AS 1#x]
:        +- OneRowRelation
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t1
:     +- UnionLoop xxxx
:        :- Project [1 AS level#x]
:        :  +- OneRowRelation
:        +- WithCTE
:           :- CTERelationDef xxxx, false
:           :  +- SubqueryAlias t3
:           :     +- Project [(level#x + 1) AS (level + 1)#x]
:           :        +- Filter (level#x < 10)
:           :           +- SubqueryAlias t1
:           :              +- UnionLoopRef xxxx, [level#x], false
:           +- Project [(level + 1)#x]
:              +- SubqueryAlias t3
:                 +- CTERelationRef xxxx, true, [(level + 1)#x], false, false
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t2
:     +- Project [level#x]
:        +- SubqueryAlias t1
:           +- CTERelationRef xxxx, true, [level#x], false, false
+- Project [level#x]
   +- SubqueryAlias t2
      +- CTERelationRef xxxx, true, [level#x], false, false


-- !query
SET spark.sql.legacy.ctePrecedencePolicy=EXCEPTION
-- !query analysis
SetCommand (spark.sql.legacy.ctePrecedencePolicy,Some(EXCEPTION))


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT r1.level + 1, r1.data
  FROM r AS r1
  JOIN r AS r2 ON r2.data = r1.data
  WHERE r1.level < 9
)
SELECT * FROM r
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r
:     +- Project [col1#x AS level#x, col2#x AS data#x]
:        +- UnionLoop xxxx
:           :- LocalRelation [col1#x, col2#x]
:           +- Project [(level#x + 1) AS (level + 1)#x, data#x]
:              +- Filter (level#x < 9)
:                 +- Join Inner, (data#x = data#x)
:                    :- SubqueryAlias r1
:                    :  +- SubqueryAlias r
:                    :     +- Project [col1#x AS level#x, col2#x AS data#x]
:                    :        +- UnionLoopRef xxxx, [col1#x, col2#x], false
:                    +- SubqueryAlias r2
:                       +- SubqueryAlias r
:                          +- Project [col1#x AS level#x, col2#x AS data#x]
:                             +- UnionLoopRef xxxx, [col1#x, col2#x], false
+- Project [level#x, data#x]
   +- SubqueryAlias r
      +- CTERelationRef xxxx, true, [level#x, data#x], false, false


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  LEFT OUTER JOIN (
    SELECT 0 AS data
  ) AS t ON t.data = r.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r
:     +- Project [col1#x AS level#x, col2#x AS data#x]
:        +- UnionLoop xxxx
:           :- LocalRelation [col1#x, col2#x]
:           +- Project [(level#x + 1) AS (level + 1)#x, data#x]
:              +- Filter (level#x < 9)
:                 +- Join LeftOuter, (data#x = data#x)
:                    :- SubqueryAlias r
:                    :  +- Project [col1#x AS level#x, col2#x AS data#x]
:                    :     +- UnionLoopRef xxxx, [col1#x, col2#x], false
:                    +- SubqueryAlias t
:                       +- Project [0 AS data#x]
:                          +- OneRowRelation
+- Project [level#x, data#x]
   +- SubqueryAlias r
      +- CTERelationRef xxxx, true, [level#x, data#x], false, false


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM (
    SELECT 0 AS data
  ) AS t
  LEFT OUTER JOIN r ON r.data = t.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query analysis
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM (
    SELECT 0 AS data
  ) AS t
  RIGHT OUTER JOIN r ON r.data = t.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r
:     +- Project [col1#x AS level#x, col2#x AS data#x]
:        +- UnionLoop xxxx
:           :- LocalRelation [col1#x, col2#x]
:           +- Project [(level#x + 1) AS (level + 1)#x, data#x]
:              +- Filter (level#x < 9)
:                 +- Join RightOuter, (data#x = data#x)
:                    :- SubqueryAlias t
:                    :  +- Project [0 AS data#x]
:                    :     +- OneRowRelation
:                    +- SubqueryAlias r
:                       +- Project [col1#x AS level#x, col2#x AS data#x]
:                          +- UnionLoopRef xxxx, [col1#x, col2#x], false
+- Project [level#x, data#x]
   +- SubqueryAlias r
      +- CTERelationRef xxxx, true, [level#x, data#x], false, false


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  RIGHT OUTER JOIN (
    SELECT 0 AS data
  ) AS t ON t.data = r.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query analysis
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  FULL OUTER JOIN (
    SELECT 0 AS data
  ) AS t ON t.data = r.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query analysis
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  LEFT SEMI JOIN (
    SELECT 0 AS data
  ) AS t ON t.data = r.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r
:     +- Project [col1#x AS level#x, col2#x AS data#x]
:        +- UnionLoop xxxx
:           :- LocalRelation [col1#x, col2#x]
:           +- Project [(level#x + 1) AS (level + 1)#x, data#x]
:              +- Filter (level#x < 9)
:                 +- Join LeftSemi, (data#x = data#x)
:                    :- SubqueryAlias r
:                    :  +- Project [col1#x AS level#x, col2#x AS data#x]
:                    :     +- UnionLoopRef xxxx, [col1#x, col2#x], false
:                    +- SubqueryAlias t
:                       +- Project [0 AS data#x]
:                          +- OneRowRelation
+- Project [level#x, data#x]
   +- SubqueryAlias r
      +- CTERelationRef xxxx, true, [level#x, data#x], false, false


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, data
  FROM (
    SELECT 0 AS level, 0 AS data
  ) AS t
  LEFT SEMI JOIN r ON r.data = t.data AND r.level < 9
)
SELECT * FROM r
-- !query analysis
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  LEFT ANTI JOIN (
    SELECT -1 AS data
  ) AS t ON t.data = r.data
  WHERE r.level < 9
)
SELECT * FROM r
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r
:     +- Project [col1#x AS level#x, col2#x AS data#x]
:        +- UnionLoop xxxx
:           :- LocalRelation [col1#x, col2#x]
:           +- Project [(level#x + 1) AS (level + 1)#x, data#x]
:              +- Filter (level#x < 9)
:                 +- Join LeftAnti, (data#x = data#x)
:                    :- SubqueryAlias r
:                    :  +- Project [col1#x AS level#x, col2#x AS data#x]
:                    :     +- UnionLoopRef xxxx, [col1#x, col2#x], false
:                    +- SubqueryAlias t
:                       +- Project [-1 AS data#x]
:                          +- OneRowRelation
+- Project [level#x, data#x]
   +- SubqueryAlias r
      +- CTERelationRef xxxx, true, [level#x, data#x], false, false


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 0)
  UNION ALL
  SELECT level + 1, data
  FROM (
    SELECT 0 AS level, 0 AS data
  ) AS t
  LEFT ANTI JOIN r ON r.data = t.data AND r.level < 9
)
SELECT * FROM r
-- !query analysis
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 1L)
  UNION ALL
  SELECT MAX(level) + 1, SUM(data) FROM r WHERE level < 9
)
SELECT * FROM r
-- !query analysis
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
WITH RECURSIVE r(n) AS (
    SELECT 1
    UNION ALL
    SELECT n+1 FROM r GROUP BY n)
SELECT * FROM r
-- !query analysis
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "INVALID_RECURSIVE_REFERENCE.PLACE",
  "sqlState" : "42836"
}


-- !query
CREATE TEMPORARY VIEW rv AS
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r
-- !query analysis
CreateViewCommand `rv`, WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT * FROM r, false, false, LocalTempView, UNSUPPORTED, true
   +- WithCTE
      :- CTERelationDef xxxx, false
      :  +- SubqueryAlias r
      :     +- Project [col1#x AS level#x]
      :        +- UnionLoop xxxx
      :           :- LocalRelation [col1#x]
      :           +- Project [(level#x + 1) AS (level + 1)#x]
      :              +- Filter (level#x < 9)
      :                 +- SubqueryAlias r
      :                    +- Project [col1#x AS level#x]
      :                       +- UnionLoopRef xxxx, [col1#x], false
      +- Project [level#x]
         +- SubqueryAlias r
            +- CTERelationRef xxxx, true, [level#x], false, false


-- !query
SELECT * FROM rv
-- !query analysis
Project [level#x]
+- SubqueryAlias rv
   +- View (`rv`, [level#x])
      +- Project [cast(level#x as int) AS level#x]
         +- WithCTE
            :- CTERelationDef xxxx, false
            :  +- SubqueryAlias r
            :     +- Project [col1#x AS level#x]
            :        +- UnionLoop xxxx
            :           :- LocalRelation [col1#x]
            :           +- Project [(level#x + 1) AS (level + 1)#x]
            :              +- Filter (level#x < 9)
            :                 +- SubqueryAlias r
            :                    +- Project [col1#x AS level#x]
            :                       +- UnionLoopRef xxxx, [col1#x], false
            +- Project [level#x]
               +- SubqueryAlias r
                  +- CTERelationRef xxxx, true, [level#x], false, false


-- !query
DROP VIEW rv
-- !query analysis
DropTempViewCommand rv


-- !query
CREATE TABLE rt(level INT) USING csv
-- !query analysis
CreateDataSourceTableCommand `spark_catalog`.`default`.`rt`, false


-- !query
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
INSERT INTO rt SELECT * FROM r
-- !query analysis
InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/rt, false, CSV, [path=file:[not included in comparison]/{warehouse_dir}/rt], Append, `spark_catalog`.`default`.`rt`, org.apache.spark.sql.execution.datasources.InMemoryFileIndex(file:[not included in comparison]/{warehouse_dir}/rt), [level]
+- WithCTE
   :- CTERelationDef xxxx, false
   :  +- SubqueryAlias r
   :     +- Project [col1#x AS level#x]
   :        +- UnionLoop xxxx
   :           :- LocalRelation [col1#x]
   :           +- Project [(level#x + 1) AS (level + 1)#x]
   :              +- Filter (level#x < 9)
   :                 +- SubqueryAlias r
   :                    +- Project [col1#x AS level#x]
   :                       +- UnionLoopRef xxxx, [col1#x], false
   +- Project [level#x]
      +- SubqueryAlias r
         +- CTERelationRef xxxx, true, [level#x], false, false


-- !query
SELECT * from rt
-- !query analysis
Project [level#x]
+- SubqueryAlias spark_catalog.default.rt
   +- Relation spark_catalog.default.rt[level#x] csv


-- !query
DROP TABLE rt
-- !query analysis
DropTable false, false
+- ResolvedIdentifier V2SessionCatalog(spark_catalog), default.rt


-- !query
CREATE TABLE rt2(level INT) USING csv
-- !query analysis
CreateDataSourceTableCommand `spark_catalog`.`default`.`rt2`, false


-- !query
WITH RECURSIVE r(level) AS (
    VALUES (0)
    UNION ALL
    SELECT level + 1 FROM r WHERE level < 9
)
FROM r
INSERT INTO rt2 SELECT *
INSERT INTO rt2 SELECT *
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "RECURSIVE_CTE_WHEN_INLINING_IS_FORCED",
  "sqlState" : "42836",
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 160,
    "fragment" : "WITH RECURSIVE r(level) AS (\n    VALUES (0)\n    UNION ALL\n    SELECT level + 1 FROM r WHERE level < 9\n)\nFROM r\nINSERT INTO rt2 SELECT *\nINSERT INTO rt2 SELECT *"
  } ]
}


-- !query
DROP TABLE rt2
-- !query analysis
DropTable false, false
+- ResolvedIdentifier V2SessionCatalog(spark_catalog), default.rt2


-- !query
WITH RECURSIVE
  r1 AS (
    SELECT 0 AS level
    UNION ALL
    SELECT level + 1 FROM r1 WHERE level < 9
  ),
  r2 AS (
    SELECT 10 AS level
    UNION ALL
    SELECT level + 1 FROM r2 WHERE level < 19
  )
SELECT *
FROM r1
JOIN r2 ON r2.level = r1.level + 10
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r1
:     +- UnionLoop xxxx
:        :- Project [0 AS level#x]
:        :  +- OneRowRelation
:        +- Project [(level#x + 1) AS (level + 1)#x]
:           +- Filter (level#x < 9)
:              +- SubqueryAlias r1
:                 +- UnionLoopRef xxxx, [level#x], false
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r2
:     +- UnionLoop xxxx
:        :- Project [10 AS level#x]
:        :  +- OneRowRelation
:        +- Project [(level#x + 1) AS (level + 1)#x]
:           +- Filter (level#x < 19)
:              +- SubqueryAlias r2
:                 +- UnionLoopRef xxxx, [level#x], false
+- Project [level#x, level#x]
   +- Join Inner, (level#x = (level#x + 10))
      :- SubqueryAlias r1
      :  +- CTERelationRef xxxx, true, [level#x], false, false
      +- SubqueryAlias r2
         +- CTERelationRef xxxx, true, [level#x], false, false


-- !query
WITH RECURSIVE r AS (
  SELECT 0 AS level
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 9
)
SELECT *
FROM r AS r1
JOIN r AS r2 ON r2.level = r1.level
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r
:     +- UnionLoop xxxx
:        :- Project [0 AS level#x]
:        :  +- OneRowRelation
:        +- Project [(level#x + 1) AS (level + 1)#x]
:           +- Filter (level#x < 9)
:              +- SubqueryAlias r
:                 +- UnionLoopRef xxxx, [level#x], false
+- Project [level#x, level#x]
   +- Join Inner, (level#x = level#x)
      :- SubqueryAlias r1
      :  +- SubqueryAlias r
      :     +- CTERelationRef xxxx, true, [level#x], false, false
      +- SubqueryAlias r2
         +- SubqueryAlias r
            +- CTERelationRef xxxx, true, [level#x], false, false


-- !query
WITH RECURSIVE r2 AS (
  WITH RECURSIVE r1 AS (
    SELECT 0 AS innerlevel
    UNION ALL
    SELECT innerlevel + 1 FROM r1 WHERE innerlevel < 3
  )
  SELECT 0 AS outerlevel, innerlevel FROM r1
  UNION ALL
  SELECT outerlevel + 1, innerlevel FROM r2 WHERE outerlevel < 3
)
SELECT * FROM r2
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r2
:     +- WithCTE
:        :- CTERelationDef xxxx, false
:        :  +- SubqueryAlias r1
:        :     +- UnionLoop xxxx
:        :        :- Project [0 AS innerlevel#x]
:        :        :  +- OneRowRelation
:        :        +- Project [(innerlevel#x + 1) AS (innerlevel + 1)#x]
:        :           +- Filter (innerlevel#x < 3)
:        :              +- SubqueryAlias r1
:        :                 +- UnionLoopRef xxxx, [innerlevel#x], false
:        +- UnionLoop xxxx
:           :- Project [0 AS outerlevel#x, innerlevel#x]
:           :  +- SubqueryAlias r1
:           :     +- CTERelationRef xxxx, true, [innerlevel#x], false, false
:           +- Project [(outerlevel#x + 1) AS (outerlevel + 1)#x, innerlevel#x]
:              +- Filter (outerlevel#x < 3)
:                 +- SubqueryAlias r2
:                    +- UnionLoopRef xxxx, [outerlevel#x, innerlevel#x], false
+- Project [outerlevel#x, innerlevel#x]
   +- SubqueryAlias r2
      +- CTERelationRef xxxx, true, [outerlevel#x, innerlevel#x], false, false


-- !query
WITH RECURSIVE r(level) AS (
  WITH RECURSIVE r(level) AS (
    VALUES 0
    UNION ALL
    SELECT level + 1 FROM r WHERE level < 3
  )
  SELECT * FROM r
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 3
)
SELECT * FROM r
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r
:     +- Project [level#x AS level#x]
:        +- WithCTE
:           :- CTERelationDef xxxx, false
:           :  +- SubqueryAlias r
:           :     +- Project [col1#x AS level#x]
:           :        +- UnionLoop xxxx
:           :           :- LocalRelation [col1#x]
:           :           +- Project [(level#x + 1) AS (level + 1)#x]
:           :              +- Filter (level#x < 3)
:           :                 +- SubqueryAlias r
:           :                    +- Project [col1#x AS level#x]
:           :                       +- UnionLoopRef xxxx, [col1#x], false
:           +- Union false, false
:              :- Project [level#x]
:              :  +- SubqueryAlias r
:              :     +- CTERelationRef xxxx, true, [level#x], false, false
:              +- Project [(level#x + 1) AS (level + 1)#x]
:                 +- Filter (level#x < 3)
:                    +- SubqueryAlias r
:                       +- CTERelationRef xxxx, true, [level#x], false, false
+- Project [level#x]
   +- SubqueryAlias r
      +- CTERelationRef xxxx, true, [level#x], false, false


-- !query
WITH RECURSIVE r(level) AS (
  (WITH RECURSIVE r(level) AS (
    VALUES 0
    UNION ALL
    SELECT level + 1 FROM r WHERE level < 3
  )
  SELECT * FROM r)
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 3
)
SELECT * FROM r
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r
:     +- Project [level#x AS level#x]
:        +- UnionLoop xxxx
:           :- WithCTE
:           :  :- CTERelationDef xxxx, false
:           :  :  +- SubqueryAlias r
:           :  :     +- Project [col1#x AS level#x]
:           :  :        +- UnionLoop xxxx
:           :  :           :- LocalRelation [col1#x]
:           :  :           +- Project [(level#x + 1) AS (level + 1)#x]
:           :  :              +- Filter (level#x < 3)
:           :  :                 +- SubqueryAlias r
:           :  :                    +- Project [col1#x AS level#x]
:           :  :                       +- UnionLoopRef xxxx, [col1#x], false
:           :  +- Project [level#x]
:           :     +- SubqueryAlias r
:           :        +- CTERelationRef xxxx, true, [level#x], false, false
:           +- Project [(level#x + 1) AS (level + 1)#x]
:              +- Filter (level#x < 3)
:                 +- SubqueryAlias r
:                    +- Project [level#x AS level#x]
:                       +- UnionLoopRef xxxx, [level#x], false
+- Project [level#x]
   +- SubqueryAlias r
      +- CTERelationRef xxxx, true, [level#x], false, false


-- !query
CREATE TEMPORARY VIEW routes(origin, destination) AS VALUES
  ('New York', 'Washington'),
  ('New York', 'Boston'),
  ('Boston', 'New York'),
  ('Washington', 'Boston'),
  ('Washington', 'Raleigh')
-- !query analysis
CreateViewCommand `routes`, [(origin,None), (destination,None)], VALUES
  ('New York', 'Washington'),
  ('New York', 'Boston'),
  ('Boston', 'New York'),
  ('Washington', 'Boston'),
  ('Washington', 'Raleigh'), false, false, LocalTempView, UNSUPPORTED, true
   +- LocalRelation [col1#x, col2#x]


-- !query
WITH RECURSIVE destinations_from_new_york AS (
  SELECT 'New York' AS destination, ARRAY('New York') AS path, 0 AS length
  UNION ALL
  SELECT r.destination, CONCAT(d.path, ARRAY(r.destination)), d.length + 1
  FROM routes AS r
  JOIN destinations_from_new_york AS d ON d.destination = r.origin AND NOT ARRAY_CONTAINS(d.path, r.destination)
)
SELECT * FROM destinations_from_new_york
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias destinations_from_new_york
:     +- UnionLoop xxxx
:        :- Project [New York AS destination#x, array(New York) AS path#x, 0 AS length#x]
:        :  +- OneRowRelation
:        +- Project [destination#x, concat(path#x, array(destination#x)) AS concat(path, array(destination))#x, (length#x + 1) AS (length + 1)#x]
:           +- Join Inner, ((destination#x = origin#x) AND NOT array_contains(path#x, destination#x))
:              :- SubqueryAlias r
:              :  +- SubqueryAlias routes
:              :     +- View (`routes`, [origin#x, destination#x])
:              :        +- Project [cast(col1#x as string) AS origin#x, cast(col2#x as string) AS destination#x]
:              :           +- LocalRelation [col1#x, col2#x]
:              +- SubqueryAlias d
:                 +- SubqueryAlias destinations_from_new_york
:                    +- UnionLoopRef xxxx, [destination#x, path#x, length#x], false
+- Project [destination#x, path#x, length#x]
   +- SubqueryAlias destinations_from_new_york
      +- CTERelationRef xxxx, true, [destination#x, path#x, length#x], false, false


-- !query
DROP VIEW routes
-- !query analysis
DropTempViewCommand routes


-- !query
WITH RECURSIVE fibonacci AS (
  VALUES (0, 1) AS t(a, b)
  UNION ALL
  SELECT b, a + b FROM fibonacci WHERE a < 10
)
SELECT a FROM fibonacci ORDER BY a
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias fibonacci
:     +- UnionLoop xxxx
:        :- SubqueryAlias t
:        :  +- LocalRelation [a#x, b#x]
:        +- Project [b#x, (a#x + b#x) AS (a + b)#x]
:           +- Filter (a#x < 10)
:              +- SubqueryAlias fibonacci
:                 +- UnionLoopRef xxxx, [a#x, b#x], false
+- Sort [a#x ASC NULLS FIRST], true
   +- Project [a#x]
      +- SubqueryAlias fibonacci
         +- CTERelationRef xxxx, true, [a#x, b#x], false, false


-- !query
WITH RECURSIVE t1(a,b,c) AS (
    SELECT 1,1,1
    UNION ALL
    SELECT a+1,a+1,a+1 FROM t1)
SELECT a FROM t1 LIMIT 5
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t1
:     +- Project [1#x AS a#x, 1#x AS b#x, 1#x AS c#x]
:        +- UnionLoop xxxx
:           :- Project [1 AS 1#x, 1 AS 1#x, 1 AS 1#x]
:           :  +- OneRowRelation
:           +- Project [(a#x + 1) AS (a + 1)#x, (a#x + 1) AS (a + 1)#x, (a#x + 1) AS (a + 1)#x]
:              +- SubqueryAlias t1
:                 +- Project [1#x AS a#x, 1#x AS b#x, 1#x AS c#x]
:                    +- UnionLoopRef xxxx, [1#x, 1#x, 1#x], false
+- GlobalLimit 5
   +- LocalLimit 5
      +- Project [a#x]
         +- SubqueryAlias t1
            +- CTERelationRef xxxx, true, [a#x, b#x, c#x], false, false


-- !query
CREATE TABLE tb (next INT)
-- !query analysis
CreateDataSourceTableCommand `spark_catalog`.`default`.`tb`, false


-- !query
INSERT INTO tb VALUES (0), (1)
-- !query analysis
InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/tb, false, Parquet, [path=file:[not included in comparison]/{warehouse_dir}/tb], Append, `spark_catalog`.`default`.`tb`, org.apache.spark.sql.execution.datasources.InMemoryFileIndex(file:[not included in comparison]/{warehouse_dir}/tb), [next]
+- Project [cast(col1#x as int) AS next#x]
   +- LocalRelation [col1#x]


-- !query
WITH RECURSIVE t(n) AS (
    SELECT 1
    UNION ALL
    SELECT next FROM t CROSS JOIN tb
    )
SELECT * FROM t LIMIT 63
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t
:     +- Project [1#x AS n#x]
:        +- UnionLoop xxxx
:           :- Project [1 AS 1#x]
:           :  +- OneRowRelation
:           +- Project [next#x]
:              +- Join Cross
:                 :- SubqueryAlias t
:                 :  +- Project [1#x AS n#x]
:                 :     +- UnionLoopRef xxxx, [1#x], false
:                 +- SubqueryAlias spark_catalog.default.tb
:                    +- Relation spark_catalog.default.tb[next#x] parquet
+- GlobalLimit 63
   +- LocalLimit 63
      +- Project [n#x]
         +- SubqueryAlias t
            +- CTERelationRef xxxx, true, [n#x], false, false


-- !query
DROP TABLE tb
-- !query analysis
DropTable false, false
+- ResolvedIdentifier V2SessionCatalog(spark_catalog), default.tb


-- !query
WITH RECURSIVE
    x(id) AS (SELECT 1 UNION SELECT 2),
    t(id, xid) AS (
        SELECT 0 AS id, 0 AS xid
        UNION ALL
        SELECT t.id + 1, xid * 10 + x.id FROM t CROSS JOIN x WHERE t.id < 3
    )
SELECT * FROM t
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias x
:     +- Project [1#x AS id#x]
:        +- Distinct
:           +- Union false, false
:              :- Project [1 AS 1#x]
:              :  +- OneRowRelation
:              +- Project [2 AS 2#x]
:                 +- OneRowRelation
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t
:     +- Project [id#x AS id#x, xid#x AS xid#x]
:        +- UnionLoop xxxx
:           :- Project [0 AS id#x, 0 AS xid#x]
:           :  +- OneRowRelation
:           +- Project [(id#x + 1) AS (id + 1)#x, ((xid#x * 10) + id#x) AS ((xid * 10) + id)#x]
:              +- Filter (id#x < 3)
:                 +- Join Cross
:                    :- SubqueryAlias t
:                    :  +- Project [id#x AS id#x, xid#x AS xid#x]
:                    :     +- UnionLoopRef xxxx, [id#x, xid#x], false
:                    +- SubqueryAlias x
:                       +- CTERelationRef xxxx, true, [id#x], false, false, 2
+- Project [id#x, xid#x]
   +- SubqueryAlias t
      +- CTERelationRef xxxx, true, [id#x, xid#x], false, false


-- !query
WITH RECURSIVE t1(a, b) AS (
    SELECT 1, 1
    UNION ALL
    SELECT a + b, a FROM t1 WHERE a < 20
),
t2(n) AS (
    SELECT 1
    UNION ALL
    SELECT n + 1 FROM t2, t1 WHERE n + 1 = a
)
SELECT * FROM t2
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t1
:     +- Project [1#x AS a#x, 1#x AS b#x]
:        +- UnionLoop xxxx
:           :- Project [1 AS 1#x, 1 AS 1#x]
:           :  +- OneRowRelation
:           +- Project [(a#x + b#x) AS (a + b)#x, a#x]
:              +- Filter (a#x < 20)
:                 +- SubqueryAlias t1
:                    +- Project [1#x AS a#x, 1#x AS b#x]
:                       +- UnionLoopRef xxxx, [1#x, 1#x], false
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t2
:     +- Project [1#x AS n#x]
:        +- UnionLoop xxxx
:           :- Project [1 AS 1#x]
:           :  +- OneRowRelation
:           +- Project [(n#x + 1) AS (n + 1)#x]
:              +- Filter ((n#x + 1) = a#x)
:                 +- Join Inner
:                    :- SubqueryAlias t2
:                    :  +- Project [1#x AS n#x]
:                    :     +- UnionLoopRef xxxx, [1#x], false
:                    +- SubqueryAlias t1
:                       +- CTERelationRef xxxx, true, [a#x, b#x], false, false
+- Project [n#x]
   +- SubqueryAlias t2
      +- CTERelationRef xxxx, true, [n#x], false, false


-- !query
WITH RECURSIVE t1 (n) AS (
    VALUES(1)
    UNION ALL
    (
    WITH t2(j) AS (
            SELECT n + 1 FROM t1
        ),
        t3(k) AS (
            SELECT j FROM t2
        )
        SELECT k FROM t3 WHERE k <= 5
    )
)
SELECT n FROM t1
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t1
:     +- Project [col1#x AS n#x]
:        +- UnionLoop xxxx
:           :- LocalRelation [col1#x]
:           +- WithCTE
:              :- CTERelationDef xxxx, false
:              :  +- SubqueryAlias t2
:              :     +- Project [(n + 1)#x AS j#x]
:              :        +- Project [(n#x + 1) AS (n + 1)#x]
:              :           +- SubqueryAlias t1
:              :              +- Project [col1#x AS n#x]
:              :                 +- UnionLoopRef xxxx, [col1#x], false
:              :- CTERelationDef xxxx, false
:              :  +- SubqueryAlias t3
:              :     +- Project [j#x AS k#x]
:              :        +- Project [j#x]
:              :           +- SubqueryAlias t2
:              :              +- CTERelationRef xxxx, true, [j#x], false, false
:              +- Project [k#x]
:                 +- Filter (k#x <= 5)
:                    +- SubqueryAlias t3
:                       +- CTERelationRef xxxx, true, [k#x], false, false
+- Project [n#x]
   +- SubqueryAlias t1
      +- CTERelationRef xxxx, true, [n#x], false, false


-- !query
WITH RECURSIVE r2(outerlevel1, innerlevel1) AS (
    WITH RECURSIVE r1 AS (
        SELECT 0 AS innerlevel
        UNION ALL
        SELECT innerlevel + 1 FROM r1 WHERE innerlevel < 3
    )
    SELECT 0 AS outerlevel, innerlevel FROM r1
    UNION ALL
    SELECT outerlevel1 + 1, innerlevel1 FROM r2 WHERE outerlevel1 < 3
)
SELECT * FROM r2
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias r2
:     +- Project [outerlevel#x AS outerlevel1#x, innerlevel#x AS innerlevel1#x]
:        +- WithCTE
:           :- CTERelationDef xxxx, false
:           :  +- SubqueryAlias r1
:           :     +- UnionLoop xxxx
:           :        :- Project [0 AS innerlevel#x]
:           :        :  +- OneRowRelation
:           :        +- Project [(innerlevel#x + 1) AS (innerlevel + 1)#x]
:           :           +- Filter (innerlevel#x < 3)
:           :              +- SubqueryAlias r1
:           :                 +- UnionLoopRef xxxx, [innerlevel#x], false
:           +- UnionLoop xxxx
:              :- Project [0 AS outerlevel#x, innerlevel#x]
:              :  +- SubqueryAlias r1
:              :     +- CTERelationRef xxxx, true, [innerlevel#x], false, false
:              +- Project [(outerlevel1#x + 1) AS (outerlevel1 + 1)#x, innerlevel1#x]
:                 +- Filter (outerlevel1#x < 3)
:                    +- SubqueryAlias r2
:                       +- Project [outerlevel#x AS outerlevel1#x, innerlevel#x AS innerlevel1#x]
:                          +- UnionLoopRef xxxx, [outerlevel#x, innerlevel#x], false
+- Project [outerlevel1#x, innerlevel1#x]
   +- SubqueryAlias r2
      +- CTERelationRef xxxx, true, [outerlevel1#x, innerlevel1#x], false, false


-- !query
WITH RECURSIVE t1(n) AS (
    WITH t2(n) AS (SELECT * FROM t1)
    SELECT 1
    UNION ALL
    SELECT n+1 FROM t2 WHERE n < 5)
SELECT * FROM t1
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t1
:     +- Project [1#x AS n#x]
:        +- WithCTE
:           :- CTERelationDef xxxx, false
:           :  +- SubqueryAlias t2
:           :     +- Project [n#x AS n#x]
:           :        +- Project [n#x]
:           :           +- SubqueryAlias t1
:           :              +- Project [1#x AS n#x]
:           :                 +- UnionLoopRef xxxx, [1#x], false
:           +- UnionLoop xxxx
:              :- Project [1 AS 1#x]
:              :  +- OneRowRelation
:              +- Project [(n#x + 1) AS (n + 1)#x]
:                 +- Filter (n#x < 5)
:                    +- SubqueryAlias t2
:                       +- CTERelationRef xxxx, true, [n#x], false, false
+- Project [n#x]
   +- SubqueryAlias t1
      +- CTERelationRef xxxx, true, [n#x], false, false


-- !query
WITH RECURSIVE t1 AS (
    WITH t2(n) AS (SELECT * FROM t1)
    SELECT 1 AS n
    UNION ALL
    SELECT n+1 FROM t2 WHERE n < 5)
SELECT * FROM t1
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias t1
:     +- WithCTE
:        :- CTERelationDef xxxx, false
:        :  +- SubqueryAlias t2
:        :     +- Project [n#x AS n#x]
:        :        +- Project [n#x]
:        :           +- SubqueryAlias t1
:        :              +- UnionLoopRef xxxx, [n#x], false
:        +- UnionLoop xxxx
:           :- Project [1 AS n#x]
:           :  +- OneRowRelation
:           +- Project [(n#x + 1) AS (n + 1)#x]
:              +- Filter (n#x < 5)
:                 +- SubqueryAlias t2
:                    +- CTERelationRef xxxx, true, [n#x], false, false
+- Project [n#x]
   +- SubqueryAlias t1
      +- CTERelationRef xxxx, true, [n#x], false, false
