-- Automatically generated by SQLQueryTestSuite
-- !query
SET hivevar:colname = 'c'
-- !query analysis
SetCommand (hivevar:colname,Some('c'))


-- !query
SELECT IDENTIFIER(${colname} || '_1') FROM VALUES(1) AS T(c_1)
-- !query analysis
Project [c_1#x]
+- SubqueryAlias T
   +- LocalRelation [c_1#x]


-- !query
SELECT IDENTIFIER('c1') FROM VALUES(1) AS T(c1)
-- !query analysis
Project [c1#x]
+- SubqueryAlias T
   +- LocalRelation [c1#x]


-- !query
SELECT IDENTIFIER('t.c1') FROM VALUES(1) AS T(c1)
-- !query analysis
Project [c1#x]
+- SubqueryAlias T
   +- LocalRelation [c1#x]


-- !query
SELECT IDENTIFIER('`t`.c1') FROM VALUES(1) AS T(c1)
-- !query analysis
Project [c1#x]
+- SubqueryAlias T
   +- LocalRelation [c1#x]


-- !query
SELECT IDENTIFIER('`c 1`') FROM VALUES(1) AS T(`c 1`)
-- !query analysis
Project [c 1#x]
+- SubqueryAlias T
   +- LocalRelation [c 1#x]


-- !query
SELECT IDENTIFIER('``') FROM VALUES(1) AS T(``)
-- !query analysis
Project [#x]
+- SubqueryAlias T
   +- LocalRelation [#x]


-- !query
SELECT IDENTIFIER('c' || '1') FROM VALUES(1) AS T(c1)
-- !query analysis
Project [c1#x]
+- SubqueryAlias T
   +- LocalRelation [c1#x]


-- !query
CREATE SCHEMA IF NOT EXISTS s
-- !query analysis
CreateNamespace true
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [s]


-- !query
CREATE TABLE s.tab(c1 INT) USING CSV
-- !query analysis
CreateDataSourceTableCommand `spark_catalog`.`s`.`tab`, false


-- !query
USE SCHEMA s
-- !query analysis
SetNamespaceCommand [s]


-- !query
INSERT INTO IDENTIFIER('ta' || 'b') VALUES(1)
-- !query analysis
InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/s.db/tab, false, CSV, [path=file:[not included in comparison]/{warehouse_dir}/s.db/tab], Append, `spark_catalog`.`s`.`tab`, org.apache.spark.sql.execution.datasources.InMemoryFileIndex(file:[not included in comparison]/{warehouse_dir}/s.db/tab), [c1]
+- Project [cast(col1#x as int) AS c1#x]
   +- LocalRelation [col1#x]


-- !query
DELETE FROM IDENTIFIER('ta' || 'b') WHERE 1=0
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "UNSUPPORTED_FEATURE.TABLE_OPERATION",
  "sqlState" : "0A000",
  "messageParameters" : {
    "operation" : "DELETE",
    "tableName" : "`spark_catalog`.`s`.`tab`"
  }
}


-- !query
UPDATE IDENTIFIER('ta' || 'b') SET c1 = 2
-- !query analysis
org.apache.spark.SparkUnsupportedOperationException
{
  "errorClass" : "_LEGACY_ERROR_TEMP_2096",
  "messageParameters" : {
    "ddl" : "UPDATE TABLE"
  }
}


-- !query
MERGE INTO IDENTIFIER('ta' || 'b') AS t USING IDENTIFIER('ta' || 'b') AS s ON s.c1 = t.c1
  WHEN MATCHED THEN UPDATE SET c1 = 3
-- !query analysis
org.apache.spark.SparkUnsupportedOperationException
{
  "errorClass" : "_LEGACY_ERROR_TEMP_2096",
  "messageParameters" : {
    "ddl" : "MERGE INTO TABLE"
  }
}


-- !query
SELECT * FROM IDENTIFIER('tab')
-- !query analysis
Project [c1#x]
+- SubqueryAlias spark_catalog.s.tab
   +- Relation spark_catalog.s.tab[c1#x] csv


-- !query
SELECT * FROM IDENTIFIER('s.tab')
-- !query analysis
Project [c1#x]
+- SubqueryAlias spark_catalog.s.tab
   +- Relation spark_catalog.s.tab[c1#x] csv


-- !query
SELECT * FROM IDENTIFIER('`s`.`tab`')
-- !query analysis
Project [c1#x]
+- SubqueryAlias spark_catalog.s.tab
   +- Relation spark_catalog.s.tab[c1#x] csv


-- !query
SELECT * FROM IDENTIFIER('t' || 'a' || 'b')
-- !query analysis
Project [c1#x]
+- SubqueryAlias spark_catalog.s.tab
   +- Relation spark_catalog.s.tab[c1#x] csv


-- !query
USE SCHEMA default
-- !query analysis
SetNamespaceCommand [default]


-- !query
DROP TABLE s.tab
-- !query analysis
DropTable false, false
+- ResolvedIdentifier V2SessionCatalog(spark_catalog), s.tab


-- !query
DROP SCHEMA s
-- !query analysis
DropNamespace false, false
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [s]


-- !query
SELECT IDENTIFIER('COAL' || 'ESCE')(NULL, 1)
-- !query analysis
Project [coalesce(cast(null as int), 1) AS coalesce(NULL, 1)#x]
+- OneRowRelation


-- !query
SELECT IDENTIFIER('abs')(c1) FROM VALUES(-1) AS T(c1)
-- !query analysis
Project [abs(c1#x) AS abs(c1)#x]
+- SubqueryAlias T
   +- LocalRelation [c1#x]


-- !query
SELECT * FROM IDENTIFIER('ra' || 'nge')(0, 1)
-- !query analysis
Project [id#xL]
+- Range (0, 1, step=1)


-- !query
CREATE TABLE IDENTIFIER('tab')(c1 INT) USING CSV
-- !query analysis
CreateDataSourceTableCommand `spark_catalog`.`default`.`tab`, false


-- !query
DROP TABLE IF EXISTS IDENTIFIER('ta' || 'b')
-- !query analysis
DropTable true, false
+- ResolvedIdentifier V2SessionCatalog(spark_catalog), default.tab


-- !query
CREATE SCHEMA identifier_clauses
-- !query analysis
CreateNamespace false
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [identifier_clauses]


-- !query
USE identifier_clauses
-- !query analysis
SetCatalogAndNamespace
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [identifier_clauses]


-- !query
CREATE TABLE IDENTIFIER('ta' || 'b')(c1 INT) USING CSV
-- !query analysis
CreateDataSourceTableCommand `spark_catalog`.`identifier_clauses`.`tab`, false


-- !query
DROP TABLE IF EXISTS IDENTIFIER('identifier_clauses.' || 'tab')
-- !query analysis
DropTable true, false
+- ResolvedIdentifier V2SessionCatalog(spark_catalog), identifier_clauses.tab


-- !query
CREATE TABLE IDENTIFIER('identifier_clauses.' || 'tab')(c1 INT) USING CSV
-- !query analysis
CreateDataSourceTableCommand `spark_catalog`.`identifier_clauses`.`tab`, false


-- !query
REPLACE TABLE IDENTIFIER('identifier_clauses.' || 'tab')(c1 INT) USING CSV
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "UNSUPPORTED_FEATURE.TABLE_OPERATION",
  "sqlState" : "0A000",
  "messageParameters" : {
    "operation" : "REPLACE TABLE",
    "tableName" : "`spark_catalog`.`identifier_clauses`.`tab`"
  }
}


-- !query
CACHE TABLE IDENTIFIER('ta' || 'b')
-- !query analysis
CacheTable [tab], false, true
   +- SubqueryAlias spark_catalog.identifier_clauses.tab
      +- Relation spark_catalog.identifier_clauses.tab[c1#x] csv


-- !query
UNCACHE TABLE IDENTIFIER('ta' || 'b')
-- !query analysis
UncacheTable false, true
   +- SubqueryAlias spark_catalog.identifier_clauses.tab
      +- Relation spark_catalog.identifier_clauses.tab[c1#x] csv


-- !query
DROP TABLE IF EXISTS IDENTIFIER('ta' || 'b')
-- !query analysis
DropTable true, false
+- ResolvedIdentifier V2SessionCatalog(spark_catalog), identifier_clauses.tab


-- !query
USE default
-- !query analysis
SetCatalogAndNamespace
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [default]


-- !query
DROP SCHEMA identifier_clauses
-- !query analysis
DropNamespace false, false
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [identifier_clauses]


-- !query
CREATE TABLE tab(c1 INT) USING CSV
-- !query analysis
CreateDataSourceTableCommand `spark_catalog`.`default`.`tab`, false


-- !query
INSERT INTO tab VALUES (1)
-- !query analysis
InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/tab, false, CSV, [path=file:[not included in comparison]/{warehouse_dir}/tab], Append, `spark_catalog`.`default`.`tab`, org.apache.spark.sql.execution.datasources.InMemoryFileIndex(file:[not included in comparison]/{warehouse_dir}/tab), [c1]
+- Project [cast(col1#x as int) AS c1#x]
   +- LocalRelation [col1#x]


-- !query
SELECT c1 FROM tab
-- !query analysis
Project [c1#x]
+- SubqueryAlias spark_catalog.default.tab
   +- Relation spark_catalog.default.tab[c1#x] csv


-- !query
DESCRIBE IDENTIFIER('ta' || 'b')
-- !query analysis
DescribeTableCommand `spark_catalog`.`default`.`tab`, false, [col_name#x, data_type#x, comment#x]


-- !query
ANALYZE TABLE IDENTIFIER('ta' || 'b') COMPUTE STATISTICS
-- !query analysis
AnalyzeTableCommand `spark_catalog`.`default`.`tab`, false


-- !query
ALTER TABLE IDENTIFIER('ta' || 'b') ADD COLUMN c2 INT
-- !query analysis
AlterTableAddColumnsCommand `spark_catalog`.`default`.`tab`, [StructField(c2,IntegerType,true)]


-- !query
SHOW TBLPROPERTIES IDENTIFIER('ta' || 'b')
-- !query analysis
ShowTableProperties [key#x, value#x]
+- ResolvedTable V2SessionCatalog(spark_catalog), default.tab, V1Table(default.tab), [c1#x, c2#x]


-- !query
SHOW COLUMNS FROM IDENTIFIER('ta' || 'b')
-- !query analysis
ShowColumnsCommand `spark_catalog`.`default`.`tab`, [col_name#x]


-- !query
COMMENT ON TABLE IDENTIFIER('ta' || 'b') IS 'hello'
-- !query analysis
CommentOnTable hello
+- ResolvedTable V2SessionCatalog(spark_catalog), default.tab, V1Table(default.tab), [c1#x, c2#x]


-- !query
REFRESH TABLE IDENTIFIER('ta' || 'b')
-- !query analysis
RefreshTableCommand `spark_catalog`.`default`.`tab`


-- !query
REPAIR TABLE IDENTIFIER('ta' || 'b')
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "NOT_A_PARTITIONED_TABLE",
  "sqlState" : "42809",
  "messageParameters" : {
    "operation" : "MSCK REPAIR TABLE",
    "tableIdentWithDB" : "`spark_catalog`.`default`.`tab`"
  }
}


-- !query
TRUNCATE TABLE IDENTIFIER('ta' || 'b')
-- !query analysis
TruncateTableCommand `spark_catalog`.`default`.`tab`


-- !query
DROP TABLE IF EXISTS tab
-- !query analysis
DropTable true, false
+- ResolvedIdentifier V2SessionCatalog(spark_catalog), default.tab


-- !query
CREATE OR REPLACE VIEW IDENTIFIER('v')(c1) AS VALUES(1)
-- !query analysis
CreateViewCommand `spark_catalog`.`default`.`v`, [(c1,None)], VALUES(1), false, true, PersistedView, COMPENSATION, true
   +- LocalRelation [col1#x]


-- !query
SELECT * FROM v
-- !query analysis
Project [c1#x]
+- SubqueryAlias spark_catalog.default.v
   +- View (`spark_catalog`.`default`.`v`, [c1#x])
      +- Project [cast(col1#x as int) AS c1#x]
         +- LocalRelation [col1#x]


-- !query
ALTER VIEW IDENTIFIER('v') AS VALUES(2)
-- !query analysis
AlterViewAsCommand `spark_catalog`.`default`.`v`, VALUES(2), true
   +- LocalRelation [col1#x]


-- !query
DROP VIEW IDENTIFIER('v')
-- !query analysis
DropTableCommand `spark_catalog`.`default`.`v`, false, true, false


-- !query
CREATE TEMPORARY VIEW IDENTIFIER('v')(c1) AS VALUES(1)
-- !query analysis
CreateViewCommand `v`, [(c1,None)], VALUES(1), false, false, LocalTempView, UNSUPPORTED, true
   +- LocalRelation [col1#x]


-- !query
DROP VIEW IDENTIFIER('v')
-- !query analysis
DropTempViewCommand v


-- !query
CREATE SCHEMA IDENTIFIER('id' || 'ent')
-- !query analysis
CreateNamespace false
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [ident]


-- !query
ALTER SCHEMA IDENTIFIER('id' || 'ent') SET PROPERTIES (somekey = 'somevalue')
-- !query analysis
SetNamespaceProperties [somekey=somevalue]
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [ident]


-- !query
ALTER SCHEMA IDENTIFIER('id' || 'ent') SET LOCATION 'someloc'
-- !query analysis
SetNamespaceLocation someloc
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [ident]


-- !query
COMMENT ON SCHEMA IDENTIFIER('id' || 'ent') IS 'some comment'
-- !query analysis
CommentOnNamespace some comment
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [ident]


-- !query
DESCRIBE SCHEMA IDENTIFIER('id' || 'ent')
-- !query analysis
DescribeNamespace false, [info_name#x, info_value#x]
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [ident]


-- !query
SHOW TABLES IN IDENTIFIER('id' || 'ent')
-- !query analysis
ShowTables [namespace#x, tableName#x, isTemporary#x]
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [ident]


-- !query
SHOW TABLE EXTENDED IN IDENTIFIER('id' || 'ent') LIKE 'hello'
-- !query analysis
ShowTablesCommand ident, hello, [namespace#x, tableName#x, isTemporary#x, information#x], true


-- !query
USE IDENTIFIER('id' || 'ent')
-- !query analysis
SetCatalogAndNamespace
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [ident]


-- !query
SHOW CURRENT SCHEMA
-- !query analysis
ShowCurrentNamespaceCommand


-- !query
USE SCHEMA IDENTIFIER('id' || 'ent')
-- !query analysis
SetNamespaceCommand [ident]


-- !query
USE SCHEMA default
-- !query analysis
SetNamespaceCommand [default]


-- !query
DROP SCHEMA IDENTIFIER('id' || 'ent')
-- !query analysis
DropNamespace false, false
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [ident]


-- !query
CREATE SCHEMA ident
-- !query analysis
CreateNamespace false
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [ident]


-- !query
CREATE FUNCTION IDENTIFIER('ident.' || 'myDoubleAvg') AS 'test.org.apache.spark.sql.MyDoubleAvg'
-- !query analysis
CreateFunctionCommand spark_catalog.ident.myDoubleAvg, test.org.apache.spark.sql.MyDoubleAvg, false, false, false


-- !query
DESCRIBE FUNCTION IDENTIFIER('ident.' || 'myDoubleAvg')
-- !query analysis
DescribeFunctionCommand org.apache.spark.sql.catalyst.expressions.ExpressionInfo@xxxxxxxx, false


-- !query
REFRESH FUNCTION IDENTIFIER('ident.' || 'myDoubleAvg')
-- !query analysis
RefreshFunctionCommand ident, mydoubleavg


-- !query
DROP FUNCTION IDENTIFIER('ident.' || 'myDoubleAvg')
-- !query analysis
DropFunctionCommand spark_catalog.ident.mydoubleavg, false, false


-- !query
DROP SCHEMA ident
-- !query analysis
DropNamespace false, false
+- ResolvedNamespace V2SessionCatalog(spark_catalog), [ident]


-- !query
CREATE TEMPORARY FUNCTION IDENTIFIER('my' || 'DoubleAvg') AS 'test.org.apache.spark.sql.MyDoubleAvg'
-- !query analysis
CreateFunctionCommand myDoubleAvg, test.org.apache.spark.sql.MyDoubleAvg, true, false, false


-- !query
DROP TEMPORARY FUNCTION IDENTIFIER('my' || 'DoubleAvg')
-- !query analysis
DropFunctionCommand myDoubleAvg, false, true


-- !query
DECLARE var = 'sometable'
-- !query analysis
CreateVariable defaultvalueexpression(sometable, 'sometable'), false
+- ResolvedIdentifier org.apache.spark.sql.catalyst.analysis.FakeSystemCatalog$@xxxxxxxx, session.var


-- !query
CREATE TABLE IDENTIFIER(var)(c1 INT) USING CSV
-- !query analysis
CreateDataSourceTableCommand `spark_catalog`.`default`.`sometable`, false


-- !query
SET VAR var = 'c1'
-- !query analysis
SetVariable [variablereference(system.session.var='sometable')]
+- Project [c1 AS var#x]
   +- OneRowRelation


-- !query
SELECT IDENTIFIER(var) FROM VALUES(1) AS T(c1)
-- !query analysis
Project [c1#x]
+- SubqueryAlias T
   +- LocalRelation [c1#x]


-- !query
SET VAR var = 'some'
-- !query analysis
SetVariable [variablereference(system.session.var='c1')]
+- Project [some AS var#x]
   +- OneRowRelation


-- !query
DROP TABLE IDENTIFIER(var || 'table')
-- !query analysis
DropTable false, false
+- ResolvedIdentifier V2SessionCatalog(spark_catalog), default.sometable


-- !query
SELECT IDENTIFIER('c 1') FROM VALUES(1) AS T(`c 1`)
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'1'",
    "hint" : ": extra input '1'"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 8,
    "stopIndex" : 24,
    "fragment" : "IDENTIFIER('c 1')"
  } ]
}


-- !query
SELECT IDENTIFIER('') FROM VALUES(1) AS T(``)
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_EMPTY_STATEMENT",
  "sqlState" : "42617",
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 8,
    "stopIndex" : 21,
    "fragment" : "IDENTIFIER('')"
  } ]
}


-- !query
VALUES(IDENTIFIER(CAST(NULL AS STRING)))
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "NOT_A_CONSTANT_STRING.NULL",
  "sqlState" : "42601",
  "messageParameters" : {
    "expr" : "CAST(NULL AS STRING)",
    "name" : "IDENTIFIER"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 19,
    "stopIndex" : 38,
    "fragment" : "CAST(NULL AS STRING)"
  } ]
}


-- !query
VALUES(IDENTIFIER(1))
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "NOT_A_CONSTANT_STRING.WRONG_TYPE",
  "sqlState" : "42601",
  "messageParameters" : {
    "dataType" : "int",
    "expr" : "1",
    "name" : "IDENTIFIER"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 19,
    "stopIndex" : 19,
    "fragment" : "1"
  } ]
}


-- !query
VALUES(IDENTIFIER(SUBSTR('HELLO', 1, RAND() + 1)))
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "NOT_A_CONSTANT_STRING.NOT_CONSTANT",
  "sqlState" : "42601",
  "messageParameters" : {
    "expr" : "substr('HELLO', 1, CAST((rand() + CAST(1 AS DOUBLE)) AS INT))",
    "name" : "IDENTIFIER"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 19,
    "stopIndex" : 48,
    "fragment" : "SUBSTR('HELLO', 1, RAND() + 1)"
  } ]
}


-- !query
SELECT `IDENTIFIER`('abs')(c1) FROM VALUES(-1) AS T(c1)
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "UNRESOLVED_ROUTINE",
  "sqlState" : "42883",
  "messageParameters" : {
    "routineName" : "`IDENTIFIER`",
    "searchPath" : "[`system`.`builtin`, `system`.`session`, `spark_catalog`.`default`]"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 8,
    "stopIndex" : 26,
    "fragment" : "`IDENTIFIER`('abs')"
  } ]
}


-- !query
CREATE TABLE IDENTIFIER(1)(c1 INT) USING csv
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "NOT_A_CONSTANT_STRING.WRONG_TYPE",
  "sqlState" : "42601",
  "messageParameters" : {
    "dataType" : "int",
    "expr" : "1",
    "name" : "IDENTIFIER"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 25,
    "stopIndex" : 25,
    "fragment" : "1"
  } ]
}


-- !query
CREATE TABLE IDENTIFIER('a.b.c')(c1 INT) USING csv
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "REQUIRES_SINGLE_PART_NAMESPACE",
  "sqlState" : "42K05",
  "messageParameters" : {
    "namespace" : "`a`.`b`",
    "sessionCatalog" : "spark_catalog"
  }
}


-- !query
CREATE VIEW IDENTIFIER('a.b.c')(c1) AS VALUES(1)
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "REQUIRES_SINGLE_PART_NAMESPACE",
  "sqlState" : "42K05",
  "messageParameters" : {
    "namespace" : "`a`.`b`",
    "sessionCatalog" : "spark_catalog"
  }
}


-- !query
DROP TABLE IDENTIFIER('a.b.c')
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "REQUIRES_SINGLE_PART_NAMESPACE",
  "sqlState" : "42K05",
  "messageParameters" : {
    "namespace" : "`a`.`b`",
    "sessionCatalog" : "spark_catalog"
  }
}


-- !query
DROP VIEW IDENTIFIER('a.b.c')
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "REQUIRES_SINGLE_PART_NAMESPACE",
  "sqlState" : "42K05",
  "messageParameters" : {
    "namespace" : "`a`.`b`",
    "sessionCatalog" : "spark_catalog"
  }
}


-- !query
COMMENT ON TABLE IDENTIFIER('a.b.c.d') IS 'hello'
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "REQUIRES_SINGLE_PART_NAMESPACE",
  "sqlState" : "42K05",
  "messageParameters" : {
    "namespace" : "`a`.`b`.`c`",
    "sessionCatalog" : "spark_catalog"
  }
}


-- !query
VALUES(IDENTIFIER(1)())
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "NOT_A_CONSTANT_STRING.WRONG_TYPE",
  "sqlState" : "42601",
  "messageParameters" : {
    "dataType" : "int",
    "expr" : "1",
    "name" : "IDENTIFIER"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 19,
    "stopIndex" : 19,
    "fragment" : "1"
  } ]
}


-- !query
VALUES(IDENTIFIER('a.b.c.d')())
-- !query analysis
org.apache.spark.sql.AnalysisException
{
  "errorClass" : "IDENTIFIER_TOO_MANY_NAME_PARTS",
  "sqlState" : "42601",
  "messageParameters" : {
    "identifier" : "`a`.`b`.`c`.`d`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 8,
    "stopIndex" : 30,
    "fragment" : "IDENTIFIER('a.b.c.d')()"
  } ]
}


-- !query
CREATE TEMPORARY FUNCTION IDENTIFIER('default.my' || 'DoubleAvg') AS 'test.org.apache.spark.sql.MyDoubleAvg'
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "INVALID_SQL_SYNTAX.CREATE_TEMP_FUNC_WITH_DATABASE",
  "sqlState" : "42000",
  "messageParameters" : {
    "database" : "`default`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 108,
    "fragment" : "CREATE TEMPORARY FUNCTION IDENTIFIER('default.my' || 'DoubleAvg') AS 'test.org.apache.spark.sql.MyDoubleAvg'"
  } ]
}


-- !query
DROP TEMPORARY FUNCTION IDENTIFIER('default.my' || 'DoubleAvg')
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "INVALID_SQL_SYNTAX.MULTI_PART_NAME",
  "sqlState" : "42000",
  "messageParameters" : {
    "name" : "`default`.`myDoubleAvg`",
    "statement" : "DROP TEMPORARY FUNCTION"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 63,
    "fragment" : "DROP TEMPORARY FUNCTION IDENTIFIER('default.my' || 'DoubleAvg')"
  } ]
}


-- !query
CREATE TEMPORARY VIEW IDENTIFIER('default.v')(c1) AS VALUES(1)
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "TEMP_VIEW_NAME_TOO_MANY_NAME_PARTS",
  "sqlState" : "428EK",
  "messageParameters" : {
    "actualName" : "`default`.`v`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 1,
    "stopIndex" : 62,
    "fragment" : "CREATE TEMPORARY VIEW IDENTIFIER('default.v')(c1) AS VALUES(1)"
  } ]
}


-- !query
create temporary view identifier('v1') as (select my_col from (values (1), (2), (1) as (my_col)) group by 1)
-- !query analysis
CreateViewCommand `v1`, (select my_col from (values (1), (2), (1) as (my_col)) group by 1), false, false, LocalTempView, UNSUPPORTED, true
   +- Aggregate [my_col#x], [my_col#x]
      +- SubqueryAlias __auto_generated_subquery_name
         +- SubqueryAlias as
            +- LocalRelation [my_col#x]


-- !query
cache table identifier('t1') as (select my_col from (values (1), (2), (1) as (my_col)) group by 1)
-- !query analysis
CacheTableAsSelect t1, (select my_col from (values (1), (2), (1) as (my_col)) group by 1), false, true
   +- Aggregate [my_col#x], [my_col#x]
      +- SubqueryAlias __auto_generated_subquery_name
         +- SubqueryAlias as
            +- LocalRelation [my_col#x]


-- !query
create table identifier('t2') using csv as (select my_col from (values (1), (2), (1) as (my_col)) group by 1)
-- !query analysis
CreateDataSourceTableAsSelectCommand `spark_catalog`.`default`.`t2`, ErrorIfExists, [my_col]
   +- Aggregate [my_col#x], [my_col#x]
      +- SubqueryAlias __auto_generated_subquery_name
         +- SubqueryAlias as
            +- LocalRelation [my_col#x]


-- !query
insert into identifier('t2') select my_col from (values (3) as (my_col)) group by 1
-- !query analysis
InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/t2, false, CSV, [path=file:[not included in comparison]/{warehouse_dir}/t2], Append, `spark_catalog`.`default`.`t2`, org.apache.spark.sql.execution.datasources.InMemoryFileIndex(file:[not included in comparison]/{warehouse_dir}/t2), [my_col]
+- Aggregate [my_col#x], [my_col#x]
   +- SubqueryAlias __auto_generated_subquery_name
      +- SubqueryAlias as
         +- LocalRelation [my_col#x]


-- !query
drop view v1
-- !query analysis
DropTempViewCommand v1


-- !query
drop table t1
-- !query analysis
DropTempViewCommand t1


-- !query
drop table t2
-- !query analysis
DropTable false, false
+- ResolvedIdentifier V2SessionCatalog(spark_catalog), default.t2


-- !query
DECLARE agg = 'max'
-- !query analysis
CreateVariable defaultvalueexpression(max, 'max'), false
+- ResolvedIdentifier org.apache.spark.sql.catalyst.analysis.FakeSystemCatalog$@xxxxxxxx, session.agg


-- !query
DECLARE col = 'c1'
-- !query analysis
CreateVariable defaultvalueexpression(c1, 'c1'), false
+- ResolvedIdentifier org.apache.spark.sql.catalyst.analysis.FakeSystemCatalog$@xxxxxxxx, session.col


-- !query
DECLARE tab = 'T'
-- !query analysis
CreateVariable defaultvalueexpression(T, 'T'), false
+- ResolvedIdentifier org.apache.spark.sql.catalyst.analysis.FakeSystemCatalog$@xxxxxxxx, session.tab


-- !query
WITH S(c1, c2) AS (VALUES(1, 2), (2, 3)),
     T(c1, c2) AS (VALUES ('a', 'b'), ('c', 'd'))
SELECT IDENTIFIER(agg)(IDENTIFIER(col)) FROM IDENTIFIER(tab)
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias S
:     +- Project [col1#x AS c1#x, col2#x AS c2#x]
:        +- LocalRelation [col1#x, col2#x]
:- CTERelationDef xxxx, false
:  +- SubqueryAlias T
:     +- Project [col1#x AS c1#x, col2#x AS c2#x]
:        +- LocalRelation [col1#x, col2#x]
+- Aggregate [max(c1#x) AS max(c1)#x]
   +- SubqueryAlias T
      +- CTERelationRef xxxx, true, [c1#x, c2#x], false


-- !query
WITH S(c1, c2) AS (VALUES(1, 2), (2, 3)),
     T(c1, c2) AS (VALUES ('a', 'b'), ('c', 'd'))
SELECT IDENTIFIER('max')(IDENTIFIER('c1')) FROM IDENTIFIER('T')
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias S
:     +- Project [col1#x AS c1#x, col2#x AS c2#x]
:        +- LocalRelation [col1#x, col2#x]
:- CTERelationDef xxxx, false
:  +- SubqueryAlias T
:     +- Project [col1#x AS c1#x, col2#x AS c2#x]
:        +- LocalRelation [col1#x, col2#x]
+- Aggregate [max(c1#x) AS max(c1)#x]
   +- SubqueryAlias T
      +- CTERelationRef xxxx, true, [c1#x, c2#x], false


-- !query
WITH ABC(c1, c2) AS (VALUES(1, 2), (2, 3))
SELECT IDENTIFIER('max')(IDENTIFIER('c1')) FROM IDENTIFIER('A' || 'BC')
-- !query analysis
WithCTE
:- CTERelationDef xxxx, false
:  +- SubqueryAlias ABC
:     +- Project [col1#x AS c1#x, col2#x AS c2#x]
:        +- LocalRelation [col1#x, col2#x]
+- Aggregate [max(c1#x) AS max(c1)#x]
   +- SubqueryAlias ABC
      +- CTERelationRef xxxx, true, [c1#x, c2#x], false


-- !query
SELECT row_number() OVER IDENTIFIER('x.win') FROM VALUES(1) AS T(c1) WINDOW win AS (ORDER BY c1)
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "''x.win''",
    "hint" : ""
  }
}


-- !query
SELECT T1.c1 FROM VALUES(1) AS T1(c1) JOIN VALUES(1) AS T2(c1) USING (IDENTIFIER('c1'))
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'('",
    "hint" : ""
  }
}


-- !query
SELECT IDENTIFIER('t').c1 FROM VALUES(1) AS T(c1)
-- !query analysis
org.apache.spark.sql.catalyst.ExtendedAnalysisException
{
  "errorClass" : "UNRESOLVED_COLUMN.WITH_SUGGESTION",
  "sqlState" : "42703",
  "messageParameters" : {
    "objectName" : "`t`",
    "proposal" : "`c1`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 8,
    "stopIndex" : 22,
    "fragment" : "IDENTIFIER('t')"
  } ]
}


-- !query
SELECT map('a', 1).IDENTIFIER('a') FROM VALUES(1) AS T(c1)
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "''a''",
    "hint" : ""
  }
}


-- !query
SELECT named_struct('a', 1).IDENTIFIER('a') FROM VALUES(1) AS T(c1)
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "''a''",
    "hint" : ""
  }
}


-- !query
SELECT * FROM s.IDENTIFIER('tab')
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "INVALID_SQL_SYNTAX.INVALID_TABLE_VALUED_FUNC_NAME",
  "sqlState" : "42000",
  "messageParameters" : {
    "funcName" : "`s`.`IDENTIFIER`"
  },
  "queryContext" : [ {
    "objectType" : "",
    "objectName" : "",
    "startIndex" : 15,
    "stopIndex" : 33,
    "fragment" : "s.IDENTIFIER('tab')"
  } ]
}


-- !query
SELECT * FROM IDENTIFIER('s').IDENTIFIER('tab')
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'.'",
    "hint" : ""
  }
}


-- !query
SELECT * FROM IDENTIFIER('s').tab
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'.'",
    "hint" : ""
  }
}


-- !query
SELECT row_number() OVER IDENTIFIER('win') FROM VALUES(1) AS T(c1) WINDOW win AS (ORDER BY c1)
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "''win''",
    "hint" : ""
  }
}


-- !query
SELECT row_number() OVER win FROM VALUES(1) AS T(c1) WINDOW IDENTIFIER('win') AS (ORDER BY c1)
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'WINDOW'",
    "hint" : ""
  }
}


-- !query
WITH identifier('v')(identifier('c1')) AS (VALUES(1)) (SELECT c1 FROM v)
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "''v''",
    "hint" : ""
  }
}


-- !query
INSERT INTO tab(IDENTIFIER('c1')) VALUES(1)
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'('",
    "hint" : ": missing ')'"
  }
}


-- !query
CREATE OR REPLACE VIEW v(IDENTIFIER('c1')) AS VALUES(1)
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'('",
    "hint" : ""
  }
}


-- !query
CREATE TABLE tab(IDENTIFIER('c1') INT) USING CSV
-- !query analysis
org.apache.spark.sql.catalyst.parser.ParseException
{
  "errorClass" : "PARSE_SYNTAX_ERROR",
  "sqlState" : "42601",
  "messageParameters" : {
    "error" : "'('",
    "hint" : ""
  }
}
