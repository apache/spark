#
# Autogenerated by Thrift Compiler (0.12.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'

module TProtocolVersion
  HIVE_CLI_SERVICE_PROTOCOL_V1 = 0
  HIVE_CLI_SERVICE_PROTOCOL_V2 = 1
  HIVE_CLI_SERVICE_PROTOCOL_V3 = 2
  HIVE_CLI_SERVICE_PROTOCOL_V4 = 3
  HIVE_CLI_SERVICE_PROTOCOL_V5 = 4
  HIVE_CLI_SERVICE_PROTOCOL_V6 = 5
  HIVE_CLI_SERVICE_PROTOCOL_V7 = 6
  HIVE_CLI_SERVICE_PROTOCOL_V8 = 7
  HIVE_CLI_SERVICE_PROTOCOL_V9 = 8
  HIVE_CLI_SERVICE_PROTOCOL_V10 = 9
  HIVE_CLI_SERVICE_PROTOCOL_V11 = 10
  VALUE_MAP = {0 => "HIVE_CLI_SERVICE_PROTOCOL_V1", 1 => "HIVE_CLI_SERVICE_PROTOCOL_V2", 2 => "HIVE_CLI_SERVICE_PROTOCOL_V3", 3 => "HIVE_CLI_SERVICE_PROTOCOL_V4", 4 => "HIVE_CLI_SERVICE_PROTOCOL_V5", 5 => "HIVE_CLI_SERVICE_PROTOCOL_V6", 6 => "HIVE_CLI_SERVICE_PROTOCOL_V7", 7 => "HIVE_CLI_SERVICE_PROTOCOL_V8", 8 => "HIVE_CLI_SERVICE_PROTOCOL_V9", 9 => "HIVE_CLI_SERVICE_PROTOCOL_V10", 10 => "HIVE_CLI_SERVICE_PROTOCOL_V11"}
  VALID_VALUES = Set.new([HIVE_CLI_SERVICE_PROTOCOL_V1, HIVE_CLI_SERVICE_PROTOCOL_V2, HIVE_CLI_SERVICE_PROTOCOL_V3, HIVE_CLI_SERVICE_PROTOCOL_V4, HIVE_CLI_SERVICE_PROTOCOL_V5, HIVE_CLI_SERVICE_PROTOCOL_V6, HIVE_CLI_SERVICE_PROTOCOL_V7, HIVE_CLI_SERVICE_PROTOCOL_V8, HIVE_CLI_SERVICE_PROTOCOL_V9, HIVE_CLI_SERVICE_PROTOCOL_V10, HIVE_CLI_SERVICE_PROTOCOL_V11]).freeze
end

module TTypeId
  BOOLEAN_TYPE = 0
  TINYINT_TYPE = 1
  SMALLINT_TYPE = 2
  INT_TYPE = 3
  BIGINT_TYPE = 4
  FLOAT_TYPE = 5
  DOUBLE_TYPE = 6
  STRING_TYPE = 7
  TIMESTAMP_TYPE = 8
  BINARY_TYPE = 9
  ARRAY_TYPE = 10
  MAP_TYPE = 11
  STRUCT_TYPE = 12
  UNION_TYPE = 13
  USER_DEFINED_TYPE = 14
  DECIMAL_TYPE = 15
  NULL_TYPE = 16
  DATE_TYPE = 17
  VARCHAR_TYPE = 18
  CHAR_TYPE = 19
  INTERVAL_YEAR_MONTH_TYPE = 20
  INTERVAL_DAY_TIME_TYPE = 21
  TIMESTAMPLOCALTZ_TYPE = 22
  VALUE_MAP = {0 => "BOOLEAN_TYPE", 1 => "TINYINT_TYPE", 2 => "SMALLINT_TYPE", 3 => "INT_TYPE", 4 => "BIGINT_TYPE", 5 => "FLOAT_TYPE", 6 => "DOUBLE_TYPE", 7 => "STRING_TYPE", 8 => "TIMESTAMP_TYPE", 9 => "BINARY_TYPE", 10 => "ARRAY_TYPE", 11 => "MAP_TYPE", 12 => "STRUCT_TYPE", 13 => "UNION_TYPE", 14 => "USER_DEFINED_TYPE", 15 => "DECIMAL_TYPE", 16 => "NULL_TYPE", 17 => "DATE_TYPE", 18 => "VARCHAR_TYPE", 19 => "CHAR_TYPE", 20 => "INTERVAL_YEAR_MONTH_TYPE", 21 => "INTERVAL_DAY_TIME_TYPE", 22 => "TIMESTAMPLOCALTZ_TYPE"}
  VALID_VALUES = Set.new([BOOLEAN_TYPE, TINYINT_TYPE, SMALLINT_TYPE, INT_TYPE, BIGINT_TYPE, FLOAT_TYPE, DOUBLE_TYPE, STRING_TYPE, TIMESTAMP_TYPE, BINARY_TYPE, ARRAY_TYPE, MAP_TYPE, STRUCT_TYPE, UNION_TYPE, USER_DEFINED_TYPE, DECIMAL_TYPE, NULL_TYPE, DATE_TYPE, VARCHAR_TYPE, CHAR_TYPE, INTERVAL_YEAR_MONTH_TYPE, INTERVAL_DAY_TIME_TYPE, TIMESTAMPLOCALTZ_TYPE]).freeze
end

module TStatusCode
  SUCCESS_STATUS = 0
  SUCCESS_WITH_INFO_STATUS = 1
  STILL_EXECUTING_STATUS = 2
  ERROR_STATUS = 3
  INVALID_HANDLE_STATUS = 4
  VALUE_MAP = {0 => "SUCCESS_STATUS", 1 => "SUCCESS_WITH_INFO_STATUS", 2 => "STILL_EXECUTING_STATUS", 3 => "ERROR_STATUS", 4 => "INVALID_HANDLE_STATUS"}
  VALID_VALUES = Set.new([SUCCESS_STATUS, SUCCESS_WITH_INFO_STATUS, STILL_EXECUTING_STATUS, ERROR_STATUS, INVALID_HANDLE_STATUS]).freeze
end

module TOperationState
  INITIALIZED_STATE = 0
  RUNNING_STATE = 1
  FINISHED_STATE = 2
  CANCELED_STATE = 3
  CLOSED_STATE = 4
  ERROR_STATE = 5
  UKNOWN_STATE = 6
  PENDING_STATE = 7
  TIMEDOUT_STATE = 8
  VALUE_MAP = {0 => "INITIALIZED_STATE", 1 => "RUNNING_STATE", 2 => "FINISHED_STATE", 3 => "CANCELED_STATE", 4 => "CLOSED_STATE", 5 => "ERROR_STATE", 6 => "UKNOWN_STATE", 7 => "PENDING_STATE", 8 => "TIMEDOUT_STATE"}
  VALID_VALUES = Set.new([INITIALIZED_STATE, RUNNING_STATE, FINISHED_STATE, CANCELED_STATE, CLOSED_STATE, ERROR_STATE, UKNOWN_STATE, PENDING_STATE, TIMEDOUT_STATE]).freeze
end

module TOperationType
  EXECUTE_STATEMENT = 0
  GET_TYPE_INFO = 1
  GET_CATALOGS = 2
  GET_SCHEMAS = 3
  GET_TABLES = 4
  GET_TABLE_TYPES = 5
  GET_COLUMNS = 6
  GET_FUNCTIONS = 7
  UNKNOWN = 8
  VALUE_MAP = {0 => "EXECUTE_STATEMENT", 1 => "GET_TYPE_INFO", 2 => "GET_CATALOGS", 3 => "GET_SCHEMAS", 4 => "GET_TABLES", 5 => "GET_TABLE_TYPES", 6 => "GET_COLUMNS", 7 => "GET_FUNCTIONS", 8 => "UNKNOWN"}
  VALID_VALUES = Set.new([EXECUTE_STATEMENT, GET_TYPE_INFO, GET_CATALOGS, GET_SCHEMAS, GET_TABLES, GET_TABLE_TYPES, GET_COLUMNS, GET_FUNCTIONS, UNKNOWN]).freeze
end

module TGetInfoType
  CLI_MAX_DRIVER_CONNECTIONS = 0
  CLI_MAX_CONCURRENT_ACTIVITIES = 1
  CLI_DATA_SOURCE_NAME = 2
  CLI_FETCH_DIRECTION = 8
  CLI_SERVER_NAME = 13
  CLI_SEARCH_PATTERN_ESCAPE = 14
  CLI_DBMS_NAME = 17
  CLI_DBMS_VER = 18
  CLI_ACCESSIBLE_TABLES = 19
  CLI_ACCESSIBLE_PROCEDURES = 20
  CLI_CURSOR_COMMIT_BEHAVIOR = 23
  CLI_DATA_SOURCE_READ_ONLY = 25
  CLI_DEFAULT_TXN_ISOLATION = 26
  CLI_IDENTIFIER_CASE = 28
  CLI_IDENTIFIER_QUOTE_CHAR = 29
  CLI_MAX_COLUMN_NAME_LEN = 30
  CLI_MAX_CURSOR_NAME_LEN = 31
  CLI_MAX_SCHEMA_NAME_LEN = 32
  CLI_MAX_CATALOG_NAME_LEN = 34
  CLI_MAX_TABLE_NAME_LEN = 35
  CLI_SCROLL_CONCURRENCY = 43
  CLI_TXN_CAPABLE = 46
  CLI_USER_NAME = 47
  CLI_TXN_ISOLATION_OPTION = 72
  CLI_INTEGRITY = 73
  CLI_GETDATA_EXTENSIONS = 81
  CLI_NULL_COLLATION = 85
  CLI_ALTER_TABLE = 86
  CLI_ORDER_BY_COLUMNS_IN_SELECT = 90
  CLI_SPECIAL_CHARACTERS = 94
  CLI_MAX_COLUMNS_IN_GROUP_BY = 97
  CLI_MAX_COLUMNS_IN_INDEX = 98
  CLI_MAX_COLUMNS_IN_ORDER_BY = 99
  CLI_MAX_COLUMNS_IN_SELECT = 100
  CLI_MAX_COLUMNS_IN_TABLE = 101
  CLI_MAX_INDEX_SIZE = 102
  CLI_MAX_ROW_SIZE = 104
  CLI_MAX_STATEMENT_LEN = 105
  CLI_MAX_TABLES_IN_SELECT = 106
  CLI_MAX_USER_NAME_LEN = 107
  CLI_OJ_CAPABILITIES = 115
  CLI_XOPEN_CLI_YEAR = 10000
  CLI_CURSOR_SENSITIVITY = 10001
  CLI_DESCRIBE_PARAMETER = 10002
  CLI_CATALOG_NAME = 10003
  CLI_COLLATION_SEQ = 10004
  CLI_MAX_IDENTIFIER_LEN = 10005
  CLI_ODBC_KEYWORDS = 10006
  VALUE_MAP = {0 => "CLI_MAX_DRIVER_CONNECTIONS", 1 => "CLI_MAX_CONCURRENT_ACTIVITIES", 2 => "CLI_DATA_SOURCE_NAME", 8 => "CLI_FETCH_DIRECTION", 13 => "CLI_SERVER_NAME", 14 => "CLI_SEARCH_PATTERN_ESCAPE", 17 => "CLI_DBMS_NAME", 18 => "CLI_DBMS_VER", 19 => "CLI_ACCESSIBLE_TABLES", 20 => "CLI_ACCESSIBLE_PROCEDURES", 23 => "CLI_CURSOR_COMMIT_BEHAVIOR", 25 => "CLI_DATA_SOURCE_READ_ONLY", 26 => "CLI_DEFAULT_TXN_ISOLATION", 28 => "CLI_IDENTIFIER_CASE", 29 => "CLI_IDENTIFIER_QUOTE_CHAR", 30 => "CLI_MAX_COLUMN_NAME_LEN", 31 => "CLI_MAX_CURSOR_NAME_LEN", 32 => "CLI_MAX_SCHEMA_NAME_LEN", 34 => "CLI_MAX_CATALOG_NAME_LEN", 35 => "CLI_MAX_TABLE_NAME_LEN", 43 => "CLI_SCROLL_CONCURRENCY", 46 => "CLI_TXN_CAPABLE", 47 => "CLI_USER_NAME", 72 => "CLI_TXN_ISOLATION_OPTION", 73 => "CLI_INTEGRITY", 81 => "CLI_GETDATA_EXTENSIONS", 85 => "CLI_NULL_COLLATION", 86 => "CLI_ALTER_TABLE", 90 => "CLI_ORDER_BY_COLUMNS_IN_SELECT", 94 => "CLI_SPECIAL_CHARACTERS", 97 => "CLI_MAX_COLUMNS_IN_GROUP_BY", 98 => "CLI_MAX_COLUMNS_IN_INDEX", 99 => "CLI_MAX_COLUMNS_IN_ORDER_BY", 100 => "CLI_MAX_COLUMNS_IN_SELECT", 101 => "CLI_MAX_COLUMNS_IN_TABLE", 102 => "CLI_MAX_INDEX_SIZE", 104 => "CLI_MAX_ROW_SIZE", 105 => "CLI_MAX_STATEMENT_LEN", 106 => "CLI_MAX_TABLES_IN_SELECT", 107 => "CLI_MAX_USER_NAME_LEN", 115 => "CLI_OJ_CAPABILITIES", 10000 => "CLI_XOPEN_CLI_YEAR", 10001 => "CLI_CURSOR_SENSITIVITY", 10002 => "CLI_DESCRIBE_PARAMETER", 10003 => "CLI_CATALOG_NAME", 10004 => "CLI_COLLATION_SEQ", 10005 => "CLI_MAX_IDENTIFIER_LEN", 10006 => "CLI_ODBC_KEYWORDS"}
  VALID_VALUES = Set.new([CLI_MAX_DRIVER_CONNECTIONS, CLI_MAX_CONCURRENT_ACTIVITIES, CLI_DATA_SOURCE_NAME, CLI_FETCH_DIRECTION, CLI_SERVER_NAME, CLI_SEARCH_PATTERN_ESCAPE, CLI_DBMS_NAME, CLI_DBMS_VER, CLI_ACCESSIBLE_TABLES, CLI_ACCESSIBLE_PROCEDURES, CLI_CURSOR_COMMIT_BEHAVIOR, CLI_DATA_SOURCE_READ_ONLY, CLI_DEFAULT_TXN_ISOLATION, CLI_IDENTIFIER_CASE, CLI_IDENTIFIER_QUOTE_CHAR, CLI_MAX_COLUMN_NAME_LEN, CLI_MAX_CURSOR_NAME_LEN, CLI_MAX_SCHEMA_NAME_LEN, CLI_MAX_CATALOG_NAME_LEN, CLI_MAX_TABLE_NAME_LEN, CLI_SCROLL_CONCURRENCY, CLI_TXN_CAPABLE, CLI_USER_NAME, CLI_TXN_ISOLATION_OPTION, CLI_INTEGRITY, CLI_GETDATA_EXTENSIONS, CLI_NULL_COLLATION, CLI_ALTER_TABLE, CLI_ORDER_BY_COLUMNS_IN_SELECT, CLI_SPECIAL_CHARACTERS, CLI_MAX_COLUMNS_IN_GROUP_BY, CLI_MAX_COLUMNS_IN_INDEX, CLI_MAX_COLUMNS_IN_ORDER_BY, CLI_MAX_COLUMNS_IN_SELECT, CLI_MAX_COLUMNS_IN_TABLE, CLI_MAX_INDEX_SIZE, CLI_MAX_ROW_SIZE, CLI_MAX_STATEMENT_LEN, CLI_MAX_TABLES_IN_SELECT, CLI_MAX_USER_NAME_LEN, CLI_OJ_CAPABILITIES, CLI_XOPEN_CLI_YEAR, CLI_CURSOR_SENSITIVITY, CLI_DESCRIBE_PARAMETER, CLI_CATALOG_NAME, CLI_COLLATION_SEQ, CLI_MAX_IDENTIFIER_LEN, CLI_ODBC_KEYWORDS]).freeze
end

module TFetchOrientation
  FETCH_NEXT = 0
  FETCH_PRIOR = 1
  FETCH_RELATIVE = 2
  FETCH_ABSOLUTE = 3
  FETCH_FIRST = 4
  FETCH_LAST = 5
  VALUE_MAP = {0 => "FETCH_NEXT", 1 => "FETCH_PRIOR", 2 => "FETCH_RELATIVE", 3 => "FETCH_ABSOLUTE", 4 => "FETCH_FIRST", 5 => "FETCH_LAST"}
  VALID_VALUES = Set.new([FETCH_NEXT, FETCH_PRIOR, FETCH_RELATIVE, FETCH_ABSOLUTE, FETCH_FIRST, FETCH_LAST]).freeze
end

module TJobExecutionStatus
  IN_PROGRESS = 0
  COMPLETE = 1
  NOT_AVAILABLE = 2
  VALUE_MAP = {0 => "IN_PROGRESS", 1 => "COMPLETE", 2 => "NOT_AVAILABLE"}
  VALID_VALUES = Set.new([IN_PROGRESS, COMPLETE, NOT_AVAILABLE]).freeze
end

class TTypeQualifierValue < ::Thrift::Union; end

class TTypeQualifiers; end

class TPrimitiveTypeEntry; end

class TArrayTypeEntry; end

class TMapTypeEntry; end

class TStructTypeEntry; end

class TUnionTypeEntry; end

class TUserDefinedTypeEntry; end

class TTypeEntry < ::Thrift::Union; end

class TTypeDesc; end

class TColumnDesc; end

class TTableSchema; end

class TBoolValue; end

class TByteValue; end

class TI16Value; end

class TI32Value; end

class TI64Value; end

class TDoubleValue; end

class TStringValue; end

class TColumnValue < ::Thrift::Union; end

class TRow; end

class TBoolColumn; end

class TByteColumn; end

class TI16Column; end

class TI32Column; end

class TI64Column; end

class TDoubleColumn; end

class TStringColumn; end

class TBinaryColumn; end

class TColumn < ::Thrift::Union; end

class TRowSet; end

class TStatus; end

class THandleIdentifier; end

class TSessionHandle; end

class TOperationHandle; end

class TOpenSessionReq; end

class TOpenSessionResp; end

class TSetClientInfoReq; end

class TSetClientInfoResp; end

class TCloseSessionReq; end

class TCloseSessionResp; end

class TGetInfoValue < ::Thrift::Union; end

class TGetInfoReq; end

class TGetInfoResp; end

class TExecuteStatementReq; end

class TExecuteStatementResp; end

class TGetTypeInfoReq; end

class TGetTypeInfoResp; end

class TGetCatalogsReq; end

class TGetCatalogsResp; end

class TGetSchemasReq; end

class TGetSchemasResp; end

class TGetTablesReq; end

class TGetTablesResp; end

class TGetTableTypesReq; end

class TGetTableTypesResp; end

class TGetColumnsReq; end

class TGetColumnsResp; end

class TGetFunctionsReq; end

class TGetFunctionsResp; end

class TGetPrimaryKeysReq; end

class TGetPrimaryKeysResp; end

class TGetCrossReferenceReq; end

class TGetCrossReferenceResp; end

class TGetOperationStatusReq; end

class TGetOperationStatusResp; end

class TCancelOperationReq; end

class TCancelOperationResp; end

class TCloseOperationReq; end

class TCloseOperationResp; end

class TGetResultSetMetadataReq; end

class TGetResultSetMetadataResp; end

class TFetchResultsReq; end

class TFetchResultsResp; end

class TGetDelegationTokenReq; end

class TGetDelegationTokenResp; end

class TCancelDelegationTokenReq; end

class TCancelDelegationTokenResp; end

class TRenewDelegationTokenReq; end

class TRenewDelegationTokenResp; end

class TProgressUpdateResp; end

class TGetQueryIdReq; end

class TGetQueryIdResp; end

class TTypeQualifierValue < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def i32Value(val)
      TTypeQualifierValue.new(:i32Value, val)
    end

    def stringValue(val)
      TTypeQualifierValue.new(:stringValue, val)
    end
  end

  I32VALUE = 1
  STRINGVALUE = 2

  FIELDS = {
    I32VALUE => {:type => ::Thrift::Types::I32, :name => 'i32Value', :optional => true},
    STRINGVALUE => {:type => ::Thrift::Types::STRING, :name => 'stringValue', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

class TTypeQualifiers
  include ::Thrift::Struct, ::Thrift::Struct_Union
  QUALIFIERS = 1

  FIELDS = {
    QUALIFIERS => {:type => ::Thrift::Types::MAP, :name => 'qualifiers', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::TTypeQualifierValue}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field qualifiers is unset!') unless @qualifiers
  end

  ::Thrift::Struct.generate_accessors self
end

class TPrimitiveTypeEntry
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TYPE = 1
  TYPEQUALIFIERS = 2

  FIELDS = {
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::TTypeId},
    TYPEQUALIFIERS => {:type => ::Thrift::Types::STRUCT, :name => 'typeQualifiers', :class => ::TTypeQualifiers, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
    unless @type.nil? || ::TTypeId::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TArrayTypeEntry
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OBJECTTYPEPTR = 1

  FIELDS = {
    OBJECTTYPEPTR => {:type => ::Thrift::Types::I32, :name => 'objectTypePtr'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field objectTypePtr is unset!') unless @objectTypePtr
  end

  ::Thrift::Struct.generate_accessors self
end

class TMapTypeEntry
  include ::Thrift::Struct, ::Thrift::Struct_Union
  KEYTYPEPTR = 1
  VALUETYPEPTR = 2

  FIELDS = {
    KEYTYPEPTR => {:type => ::Thrift::Types::I32, :name => 'keyTypePtr'},
    VALUETYPEPTR => {:type => ::Thrift::Types::I32, :name => 'valueTypePtr'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field keyTypePtr is unset!') unless @keyTypePtr
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field valueTypePtr is unset!') unless @valueTypePtr
  end

  ::Thrift::Struct.generate_accessors self
end

class TStructTypeEntry
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAMETOTYPEPTR = 1

  FIELDS = {
    NAMETOTYPEPTR => {:type => ::Thrift::Types::MAP, :name => 'nameToTypePtr', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I32}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nameToTypePtr is unset!') unless @nameToTypePtr
  end

  ::Thrift::Struct.generate_accessors self
end

class TUnionTypeEntry
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAMETOTYPEPTR = 1

  FIELDS = {
    NAMETOTYPEPTR => {:type => ::Thrift::Types::MAP, :name => 'nameToTypePtr', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I32}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nameToTypePtr is unset!') unless @nameToTypePtr
  end

  ::Thrift::Struct.generate_accessors self
end

class TUserDefinedTypeEntry
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TYPECLASSNAME = 1

  FIELDS = {
    TYPECLASSNAME => {:type => ::Thrift::Types::STRING, :name => 'typeClassName'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field typeClassName is unset!') unless @typeClassName
  end

  ::Thrift::Struct.generate_accessors self
end

class TTypeEntry < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def primitiveEntry(val)
      TTypeEntry.new(:primitiveEntry, val)
    end

    def arrayEntry(val)
      TTypeEntry.new(:arrayEntry, val)
    end

    def mapEntry(val)
      TTypeEntry.new(:mapEntry, val)
    end

    def structEntry(val)
      TTypeEntry.new(:structEntry, val)
    end

    def unionEntry(val)
      TTypeEntry.new(:unionEntry, val)
    end

    def userDefinedTypeEntry(val)
      TTypeEntry.new(:userDefinedTypeEntry, val)
    end
  end

  PRIMITIVEENTRY = 1
  ARRAYENTRY = 2
  MAPENTRY = 3
  STRUCTENTRY = 4
  UNIONENTRY = 5
  USERDEFINEDTYPEENTRY = 6

  FIELDS = {
    PRIMITIVEENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'primitiveEntry', :class => ::TPrimitiveTypeEntry, :optional => true},
    ARRAYENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'arrayEntry', :class => ::TArrayTypeEntry, :optional => true},
    MAPENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'mapEntry', :class => ::TMapTypeEntry, :optional => true},
    STRUCTENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'structEntry', :class => ::TStructTypeEntry, :optional => true},
    UNIONENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'unionEntry', :class => ::TUnionTypeEntry, :optional => true},
    USERDEFINEDTYPEENTRY => {:type => ::Thrift::Types::STRUCT, :name => 'userDefinedTypeEntry', :class => ::TUserDefinedTypeEntry, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

class TTypeDesc
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TYPES = 1

  FIELDS = {
    TYPES => {:type => ::Thrift::Types::LIST, :name => 'types', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TTypeEntry}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field types is unset!') unless @types
  end

  ::Thrift::Struct.generate_accessors self
end

class TColumnDesc
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COLUMNNAME = 1
  TYPEDESC = 2
  POSITION = 3
  COMMENT = 4

  FIELDS = {
    COLUMNNAME => {:type => ::Thrift::Types::STRING, :name => 'columnName'},
    TYPEDESC => {:type => ::Thrift::Types::STRUCT, :name => 'typeDesc', :class => ::TTypeDesc},
    POSITION => {:type => ::Thrift::Types::I32, :name => 'position'},
    COMMENT => {:type => ::Thrift::Types::STRING, :name => 'comment', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field columnName is unset!') unless @columnName
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field typeDesc is unset!') unless @typeDesc
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field position is unset!') unless @position
  end

  ::Thrift::Struct.generate_accessors self
end

class TTableSchema
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COLUMNS = 1

  FIELDS = {
    COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TColumnDesc}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field columns is unset!') unless @columns
  end

  ::Thrift::Struct.generate_accessors self
end

class TBoolValue
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUE = 1

  FIELDS = {
    VALUE => {:type => ::Thrift::Types::BOOL, :name => 'value', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TByteValue
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUE = 1

  FIELDS = {
    VALUE => {:type => ::Thrift::Types::BYTE, :name => 'value', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TI16Value
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUE = 1

  FIELDS = {
    VALUE => {:type => ::Thrift::Types::I16, :name => 'value', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TI32Value
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUE = 1

  FIELDS = {
    VALUE => {:type => ::Thrift::Types::I32, :name => 'value', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TI64Value
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUE = 1

  FIELDS = {
    VALUE => {:type => ::Thrift::Types::I64, :name => 'value', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TDoubleValue
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUE = 1

  FIELDS = {
    VALUE => {:type => ::Thrift::Types::DOUBLE, :name => 'value', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TStringValue
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUE = 1

  FIELDS = {
    VALUE => {:type => ::Thrift::Types::STRING, :name => 'value', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TColumnValue < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def boolVal(val)
      TColumnValue.new(:boolVal, val)
    end

    def byteVal(val)
      TColumnValue.new(:byteVal, val)
    end

    def i16Val(val)
      TColumnValue.new(:i16Val, val)
    end

    def i32Val(val)
      TColumnValue.new(:i32Val, val)
    end

    def i64Val(val)
      TColumnValue.new(:i64Val, val)
    end

    def doubleVal(val)
      TColumnValue.new(:doubleVal, val)
    end

    def stringVal(val)
      TColumnValue.new(:stringVal, val)
    end
  end

  BOOLVAL = 1
  BYTEVAL = 2
  I16VAL = 3
  I32VAL = 4
  I64VAL = 5
  DOUBLEVAL = 6
  STRINGVAL = 7

  FIELDS = {
    BOOLVAL => {:type => ::Thrift::Types::STRUCT, :name => 'boolVal', :class => ::TBoolValue, :optional => true},
    BYTEVAL => {:type => ::Thrift::Types::STRUCT, :name => 'byteVal', :class => ::TByteValue, :optional => true},
    I16VAL => {:type => ::Thrift::Types::STRUCT, :name => 'i16Val', :class => ::TI16Value, :optional => true},
    I32VAL => {:type => ::Thrift::Types::STRUCT, :name => 'i32Val', :class => ::TI32Value, :optional => true},
    I64VAL => {:type => ::Thrift::Types::STRUCT, :name => 'i64Val', :class => ::TI64Value, :optional => true},
    DOUBLEVAL => {:type => ::Thrift::Types::STRUCT, :name => 'doubleVal', :class => ::TDoubleValue, :optional => true},
    STRINGVAL => {:type => ::Thrift::Types::STRUCT, :name => 'stringVal', :class => ::TStringValue, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

class TRow
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COLVALS = 1

  FIELDS = {
    COLVALS => {:type => ::Thrift::Types::LIST, :name => 'colVals', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TColumnValue}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field colVals is unset!') unless @colVals
  end

  ::Thrift::Struct.generate_accessors self
end

class TBoolColumn
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUES = 1
  NULLS = 2

  FIELDS = {
    VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::BOOL}},
    NULLS => {:type => ::Thrift::Types::STRING, :name => 'nulls', :binary => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nulls is unset!') unless @nulls
  end

  ::Thrift::Struct.generate_accessors self
end

class TByteColumn
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUES = 1
  NULLS = 2

  FIELDS = {
    VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::BYTE}},
    NULLS => {:type => ::Thrift::Types::STRING, :name => 'nulls', :binary => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nulls is unset!') unless @nulls
  end

  ::Thrift::Struct.generate_accessors self
end

class TI16Column
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUES = 1
  NULLS = 2

  FIELDS = {
    VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::I16}},
    NULLS => {:type => ::Thrift::Types::STRING, :name => 'nulls', :binary => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nulls is unset!') unless @nulls
  end

  ::Thrift::Struct.generate_accessors self
end

class TI32Column
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUES = 1
  NULLS = 2

  FIELDS = {
    VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::I32}},
    NULLS => {:type => ::Thrift::Types::STRING, :name => 'nulls', :binary => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nulls is unset!') unless @nulls
  end

  ::Thrift::Struct.generate_accessors self
end

class TI64Column
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUES = 1
  NULLS = 2

  FIELDS = {
    VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::I64}},
    NULLS => {:type => ::Thrift::Types::STRING, :name => 'nulls', :binary => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nulls is unset!') unless @nulls
  end

  ::Thrift::Struct.generate_accessors self
end

class TDoubleColumn
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUES = 1
  NULLS = 2

  FIELDS = {
    VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::DOUBLE}},
    NULLS => {:type => ::Thrift::Types::STRING, :name => 'nulls', :binary => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nulls is unset!') unless @nulls
  end

  ::Thrift::Struct.generate_accessors self
end

class TStringColumn
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUES = 1
  NULLS = 2

  FIELDS = {
    VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::STRING}},
    NULLS => {:type => ::Thrift::Types::STRING, :name => 'nulls', :binary => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nulls is unset!') unless @nulls
  end

  ::Thrift::Struct.generate_accessors self
end

class TBinaryColumn
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUES = 1
  NULLS = 2

  FIELDS = {
    VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
    NULLS => {:type => ::Thrift::Types::STRING, :name => 'nulls', :binary => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field values is unset!') unless @values
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nulls is unset!') unless @nulls
  end

  ::Thrift::Struct.generate_accessors self
end

class TColumn < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def boolVal(val)
      TColumn.new(:boolVal, val)
    end

    def byteVal(val)
      TColumn.new(:byteVal, val)
    end

    def i16Val(val)
      TColumn.new(:i16Val, val)
    end

    def i32Val(val)
      TColumn.new(:i32Val, val)
    end

    def i64Val(val)
      TColumn.new(:i64Val, val)
    end

    def doubleVal(val)
      TColumn.new(:doubleVal, val)
    end

    def stringVal(val)
      TColumn.new(:stringVal, val)
    end

    def binaryVal(val)
      TColumn.new(:binaryVal, val)
    end
  end

  BOOLVAL = 1
  BYTEVAL = 2
  I16VAL = 3
  I32VAL = 4
  I64VAL = 5
  DOUBLEVAL = 6
  STRINGVAL = 7
  BINARYVAL = 8

  FIELDS = {
    BOOLVAL => {:type => ::Thrift::Types::STRUCT, :name => 'boolVal', :class => ::TBoolColumn, :optional => true},
    BYTEVAL => {:type => ::Thrift::Types::STRUCT, :name => 'byteVal', :class => ::TByteColumn, :optional => true},
    I16VAL => {:type => ::Thrift::Types::STRUCT, :name => 'i16Val', :class => ::TI16Column, :optional => true},
    I32VAL => {:type => ::Thrift::Types::STRUCT, :name => 'i32Val', :class => ::TI32Column, :optional => true},
    I64VAL => {:type => ::Thrift::Types::STRUCT, :name => 'i64Val', :class => ::TI64Column, :optional => true},
    DOUBLEVAL => {:type => ::Thrift::Types::STRUCT, :name => 'doubleVal', :class => ::TDoubleColumn, :optional => true},
    STRINGVAL => {:type => ::Thrift::Types::STRUCT, :name => 'stringVal', :class => ::TStringColumn, :optional => true},
    BINARYVAL => {:type => ::Thrift::Types::STRUCT, :name => 'binaryVal', :class => ::TBinaryColumn, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

class TRowSet
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STARTROWOFFSET = 1
  ROWS = 2
  COLUMNS = 3
  BINARYCOLUMNS = 4
  COLUMNCOUNT = 5

  FIELDS = {
    STARTROWOFFSET => {:type => ::Thrift::Types::I64, :name => 'startRowOffset'},
    ROWS => {:type => ::Thrift::Types::LIST, :name => 'rows', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TRow}},
    COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRUCT, :class => ::TColumn}, :optional => true},
    BINARYCOLUMNS => {:type => ::Thrift::Types::STRING, :name => 'binaryColumns', :binary => true, :optional => true},
    COLUMNCOUNT => {:type => ::Thrift::Types::I32, :name => 'columnCount', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field startRowOffset is unset!') unless @startRowOffset
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field rows is unset!') unless @rows
  end

  ::Thrift::Struct.generate_accessors self
end

class TStatus
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUSCODE = 1
  INFOMESSAGES = 2
  SQLSTATE = 3
  ERRORCODE = 4
  ERRORMESSAGE = 5

  FIELDS = {
    STATUSCODE => {:type => ::Thrift::Types::I32, :name => 'statusCode', :enum_class => ::TStatusCode},
    INFOMESSAGES => {:type => ::Thrift::Types::LIST, :name => 'infoMessages', :element => {:type => ::Thrift::Types::STRING}, :optional => true},
    SQLSTATE => {:type => ::Thrift::Types::STRING, :name => 'sqlState', :optional => true},
    ERRORCODE => {:type => ::Thrift::Types::I32, :name => 'errorCode', :optional => true},
    ERRORMESSAGE => {:type => ::Thrift::Types::STRING, :name => 'errorMessage', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field statusCode is unset!') unless @statusCode
    unless @statusCode.nil? || ::TStatusCode::VALID_VALUES.include?(@statusCode)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field statusCode!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class THandleIdentifier
  include ::Thrift::Struct, ::Thrift::Struct_Union
  GUID = 1
  SECRET = 2

  FIELDS = {
    GUID => {:type => ::Thrift::Types::STRING, :name => 'guid', :binary => true},
    SECRET => {:type => ::Thrift::Types::STRING, :name => 'secret', :binary => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field guid is unset!') unless @guid
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field secret is unset!') unless @secret
  end

  ::Thrift::Struct.generate_accessors self
end

class TSessionHandle
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONID = 1

  FIELDS = {
    SESSIONID => {:type => ::Thrift::Types::STRUCT, :name => 'sessionId', :class => ::THandleIdentifier}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionId is unset!') unless @sessionId
  end

  ::Thrift::Struct.generate_accessors self
end

class TOperationHandle
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OPERATIONID = 1
  OPERATIONTYPE = 2
  HASRESULTSET = 3
  MODIFIEDROWCOUNT = 4

  FIELDS = {
    OPERATIONID => {:type => ::Thrift::Types::STRUCT, :name => 'operationId', :class => ::THandleIdentifier},
    OPERATIONTYPE => {:type => ::Thrift::Types::I32, :name => 'operationType', :enum_class => ::TOperationType},
    HASRESULTSET => {:type => ::Thrift::Types::BOOL, :name => 'hasResultSet'},
    MODIFIEDROWCOUNT => {:type => ::Thrift::Types::DOUBLE, :name => 'modifiedRowCount', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationId is unset!') unless @operationId
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationType is unset!') unless @operationType
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field hasResultSet is unset!') if @hasResultSet.nil?
    unless @operationType.nil? || ::TOperationType::VALID_VALUES.include?(@operationType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field operationType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TOpenSessionReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CLIENT_PROTOCOL = 1
  USERNAME = 2
  PASSWORD = 3
  CONFIGURATION = 4

  FIELDS = {
    CLIENT_PROTOCOL => {:type => ::Thrift::Types::I32, :name => 'client_protocol', :default =>     9, :enum_class => ::TProtocolVersion},
    USERNAME => {:type => ::Thrift::Types::STRING, :name => 'username', :optional => true},
    PASSWORD => {:type => ::Thrift::Types::STRING, :name => 'password', :optional => true},
    CONFIGURATION => {:type => ::Thrift::Types::MAP, :name => 'configuration', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field client_protocol is unset!') unless @client_protocol
    unless @client_protocol.nil? || ::TProtocolVersion::VALID_VALUES.include?(@client_protocol)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field client_protocol!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TOpenSessionResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  SERVERPROTOCOLVERSION = 2
  SESSIONHANDLE = 3
  CONFIGURATION = 4

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    SERVERPROTOCOLVERSION => {:type => ::Thrift::Types::I32, :name => 'serverProtocolVersion', :default =>     9, :enum_class => ::TProtocolVersion},
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle, :optional => true},
    CONFIGURATION => {:type => ::Thrift::Types::MAP, :name => 'configuration', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field serverProtocolVersion is unset!') unless @serverProtocolVersion
    unless @serverProtocolVersion.nil? || ::TProtocolVersion::VALID_VALUES.include?(@serverProtocolVersion)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field serverProtocolVersion!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TSetClientInfoReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  CONFIGURATION = 2

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    CONFIGURATION => {:type => ::Thrift::Types::MAP, :name => 'configuration', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TSetClientInfoResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TCloseSessionReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TCloseSessionResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetInfoValue < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def stringValue(val)
      TGetInfoValue.new(:stringValue, val)
    end

    def smallIntValue(val)
      TGetInfoValue.new(:smallIntValue, val)
    end

    def integerBitmask(val)
      TGetInfoValue.new(:integerBitmask, val)
    end

    def integerFlag(val)
      TGetInfoValue.new(:integerFlag, val)
    end

    def binaryValue(val)
      TGetInfoValue.new(:binaryValue, val)
    end

    def lenValue(val)
      TGetInfoValue.new(:lenValue, val)
    end
  end

  STRINGVALUE = 1
  SMALLINTVALUE = 2
  INTEGERBITMASK = 3
  INTEGERFLAG = 4
  BINARYVALUE = 5
  LENVALUE = 6

  FIELDS = {
    STRINGVALUE => {:type => ::Thrift::Types::STRING, :name => 'stringValue', :optional => true},
    SMALLINTVALUE => {:type => ::Thrift::Types::I16, :name => 'smallIntValue', :optional => true},
    INTEGERBITMASK => {:type => ::Thrift::Types::I32, :name => 'integerBitmask', :optional => true},
    INTEGERFLAG => {:type => ::Thrift::Types::I32, :name => 'integerFlag', :optional => true},
    BINARYVALUE => {:type => ::Thrift::Types::I32, :name => 'binaryValue', :optional => true},
    LENVALUE => {:type => ::Thrift::Types::I64, :name => 'lenValue', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

class TGetInfoReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  INFOTYPE = 2

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    INFOTYPE => {:type => ::Thrift::Types::I32, :name => 'infoType', :enum_class => ::TGetInfoType}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field infoType is unset!') unless @infoType
    unless @infoType.nil? || ::TGetInfoType::VALID_VALUES.include?(@infoType)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field infoType!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetInfoResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  INFOVALUE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    INFOVALUE => {:type => ::Thrift::Types::STRUCT, :name => 'infoValue', :class => ::TGetInfoValue}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field infoValue is unset!') unless @infoValue
  end

  ::Thrift::Struct.generate_accessors self
end

class TExecuteStatementReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  STATEMENT = 2
  CONFOVERLAY = 3
  RUNASYNC = 4
  QUERYTIMEOUT = 5

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    STATEMENT => {:type => ::Thrift::Types::STRING, :name => 'statement'},
    CONFOVERLAY => {:type => ::Thrift::Types::MAP, :name => 'confOverlay', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}, :optional => true},
    RUNASYNC => {:type => ::Thrift::Types::BOOL, :name => 'runAsync', :default => false, :optional => true},
    QUERYTIMEOUT => {:type => ::Thrift::Types::I64, :name => 'queryTimeout', :default => 0, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field statement is unset!') unless @statement
  end

  ::Thrift::Struct.generate_accessors self
end

class TExecuteStatementResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetTypeInfoReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetTypeInfoResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetCatalogsReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetCatalogsResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetSchemasReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  CATALOGNAME = 2
  SCHEMANAME = 3

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    CATALOGNAME => {:type => ::Thrift::Types::STRING, :name => 'catalogName', :optional => true},
    SCHEMANAME => {:type => ::Thrift::Types::STRING, :name => 'schemaName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetSchemasResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetTablesReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  CATALOGNAME = 2
  SCHEMANAME = 3
  TABLENAME = 4
  TABLETYPES = 5

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    CATALOGNAME => {:type => ::Thrift::Types::STRING, :name => 'catalogName', :optional => true},
    SCHEMANAME => {:type => ::Thrift::Types::STRING, :name => 'schemaName', :optional => true},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :optional => true},
    TABLETYPES => {:type => ::Thrift::Types::LIST, :name => 'tableTypes', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetTablesResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetTableTypesReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetTableTypesResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetColumnsReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  CATALOGNAME = 2
  SCHEMANAME = 3
  TABLENAME = 4
  COLUMNNAME = 5

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    CATALOGNAME => {:type => ::Thrift::Types::STRING, :name => 'catalogName', :optional => true},
    SCHEMANAME => {:type => ::Thrift::Types::STRING, :name => 'schemaName', :optional => true},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :optional => true},
    COLUMNNAME => {:type => ::Thrift::Types::STRING, :name => 'columnName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetColumnsResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetFunctionsReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  CATALOGNAME = 2
  SCHEMANAME = 3
  FUNCTIONNAME = 4

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    CATALOGNAME => {:type => ::Thrift::Types::STRING, :name => 'catalogName', :optional => true},
    SCHEMANAME => {:type => ::Thrift::Types::STRING, :name => 'schemaName', :optional => true},
    FUNCTIONNAME => {:type => ::Thrift::Types::STRING, :name => 'functionName'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field functionName is unset!') unless @functionName
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetFunctionsResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetPrimaryKeysReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  CATALOGNAME = 2
  SCHEMANAME = 3
  TABLENAME = 4

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    CATALOGNAME => {:type => ::Thrift::Types::STRING, :name => 'catalogName', :optional => true},
    SCHEMANAME => {:type => ::Thrift::Types::STRING, :name => 'schemaName', :optional => true},
    TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetPrimaryKeysResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetCrossReferenceReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  PARENTCATALOGNAME = 2
  PARENTSCHEMANAME = 3
  PARENTTABLENAME = 4
  FOREIGNCATALOGNAME = 5
  FOREIGNSCHEMANAME = 6
  FOREIGNTABLENAME = 7

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    PARENTCATALOGNAME => {:type => ::Thrift::Types::STRING, :name => 'parentCatalogName', :optional => true},
    PARENTSCHEMANAME => {:type => ::Thrift::Types::STRING, :name => 'parentSchemaName', :optional => true},
    PARENTTABLENAME => {:type => ::Thrift::Types::STRING, :name => 'parentTableName', :optional => true},
    FOREIGNCATALOGNAME => {:type => ::Thrift::Types::STRING, :name => 'foreignCatalogName', :optional => true},
    FOREIGNSCHEMANAME => {:type => ::Thrift::Types::STRING, :name => 'foreignSchemaName', :optional => true},
    FOREIGNTABLENAME => {:type => ::Thrift::Types::STRING, :name => 'foreignTableName', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetCrossReferenceResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONHANDLE = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetOperationStatusReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OPERATIONHANDLE = 1
  GETPROGRESSUPDATE = 2

  FIELDS = {
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle},
    GETPROGRESSUPDATE => {:type => ::Thrift::Types::BOOL, :name => 'getProgressUpdate', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationHandle is unset!') unless @operationHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetOperationStatusResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  OPERATIONSTATE = 2
  SQLSTATE = 3
  ERRORCODE = 4
  ERRORMESSAGE = 5
  TASKSTATUS = 6
  OPERATIONSTARTED = 7
  OPERATIONCOMPLETED = 8
  HASRESULTSET = 9
  PROGRESSUPDATERESPONSE = 10

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    OPERATIONSTATE => {:type => ::Thrift::Types::I32, :name => 'operationState', :optional => true, :enum_class => ::TOperationState},
    SQLSTATE => {:type => ::Thrift::Types::STRING, :name => 'sqlState', :optional => true},
    ERRORCODE => {:type => ::Thrift::Types::I32, :name => 'errorCode', :optional => true},
    ERRORMESSAGE => {:type => ::Thrift::Types::STRING, :name => 'errorMessage', :optional => true},
    TASKSTATUS => {:type => ::Thrift::Types::STRING, :name => 'taskStatus', :optional => true},
    OPERATIONSTARTED => {:type => ::Thrift::Types::I64, :name => 'operationStarted', :optional => true},
    OPERATIONCOMPLETED => {:type => ::Thrift::Types::I64, :name => 'operationCompleted', :optional => true},
    HASRESULTSET => {:type => ::Thrift::Types::BOOL, :name => 'hasResultSet', :optional => true},
    PROGRESSUPDATERESPONSE => {:type => ::Thrift::Types::STRUCT, :name => 'progressUpdateResponse', :class => ::TProgressUpdateResp, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
    unless @operationState.nil? || ::TOperationState::VALID_VALUES.include?(@operationState)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field operationState!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TCancelOperationReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OPERATIONHANDLE = 1

  FIELDS = {
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationHandle is unset!') unless @operationHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TCancelOperationResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TCloseOperationReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OPERATIONHANDLE = 1

  FIELDS = {
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationHandle is unset!') unless @operationHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TCloseOperationResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetResultSetMetadataReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OPERATIONHANDLE = 1

  FIELDS = {
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationHandle is unset!') unless @operationHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetResultSetMetadataResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  SCHEMA = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    SCHEMA => {:type => ::Thrift::Types::STRUCT, :name => 'schema', :class => ::TTableSchema, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TFetchResultsReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OPERATIONHANDLE = 1
  ORIENTATION = 2
  MAXROWS = 3
  FETCHTYPE = 4

  FIELDS = {
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle},
    ORIENTATION => {:type => ::Thrift::Types::I32, :name => 'orientation', :default =>     0, :enum_class => ::TFetchOrientation},
    MAXROWS => {:type => ::Thrift::Types::I64, :name => 'maxRows'},
    FETCHTYPE => {:type => ::Thrift::Types::I16, :name => 'fetchType', :default => 0, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationHandle is unset!') unless @operationHandle
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field orientation is unset!') unless @orientation
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field maxRows is unset!') unless @maxRows
    unless @orientation.nil? || ::TFetchOrientation::VALID_VALUES.include?(@orientation)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field orientation!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TFetchResultsResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  HASMOREROWS = 2
  RESULTS = 3

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    HASMOREROWS => {:type => ::Thrift::Types::BOOL, :name => 'hasMoreRows', :optional => true},
    RESULTS => {:type => ::Thrift::Types::STRUCT, :name => 'results', :class => ::TRowSet, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetDelegationTokenReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  OWNER = 2
  RENEWER = 3

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    OWNER => {:type => ::Thrift::Types::STRING, :name => 'owner'},
    RENEWER => {:type => ::Thrift::Types::STRING, :name => 'renewer'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field owner is unset!') unless @owner
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field renewer is unset!') unless @renewer
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetDelegationTokenResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1
  DELEGATIONTOKEN = 2

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
    DELEGATIONTOKEN => {:type => ::Thrift::Types::STRING, :name => 'delegationToken', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TCancelDelegationTokenReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  DELEGATIONTOKEN = 2

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    DELEGATIONTOKEN => {:type => ::Thrift::Types::STRING, :name => 'delegationToken'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field delegationToken is unset!') unless @delegationToken
  end

  ::Thrift::Struct.generate_accessors self
end

class TCancelDelegationTokenResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TRenewDelegationTokenReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SESSIONHANDLE = 1
  DELEGATIONTOKEN = 2

  FIELDS = {
    SESSIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'sessionHandle', :class => ::TSessionHandle},
    DELEGATIONTOKEN => {:type => ::Thrift::Types::STRING, :name => 'delegationToken'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field sessionHandle is unset!') unless @sessionHandle
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field delegationToken is unset!') unless @delegationToken
  end

  ::Thrift::Struct.generate_accessors self
end

class TRenewDelegationTokenResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STATUS = 1

  FIELDS = {
    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
  end

  ::Thrift::Struct.generate_accessors self
end

class TProgressUpdateResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  HEADERNAMES = 1
  ROWS = 2
  PROGRESSEDPERCENTAGE = 3
  STATUS = 4
  FOOTERSUMMARY = 5
  STARTTIME = 6

  FIELDS = {
    HEADERNAMES => {:type => ::Thrift::Types::LIST, :name => 'headerNames', :element => {:type => ::Thrift::Types::STRING}},
    ROWS => {:type => ::Thrift::Types::LIST, :name => 'rows', :element => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRING}}},
    PROGRESSEDPERCENTAGE => {:type => ::Thrift::Types::DOUBLE, :name => 'progressedPercentage'},
    STATUS => {:type => ::Thrift::Types::I32, :name => 'status', :enum_class => ::TJobExecutionStatus},
    FOOTERSUMMARY => {:type => ::Thrift::Types::STRING, :name => 'footerSummary'},
    STARTTIME => {:type => ::Thrift::Types::I64, :name => 'startTime'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field headerNames is unset!') unless @headerNames
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field rows is unset!') unless @rows
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field progressedPercentage is unset!') unless @progressedPercentage
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field footerSummary is unset!') unless @footerSummary
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field startTime is unset!') unless @startTime
    unless @status.nil? || ::TJobExecutionStatus::VALID_VALUES.include?(@status)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field status!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetQueryIdReq
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OPERATIONHANDLE = 1

  FIELDS = {
    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationHandle is unset!') unless @operationHandle
  end

  ::Thrift::Struct.generate_accessors self
end

class TGetQueryIdResp
  include ::Thrift::Struct, ::Thrift::Struct_Union
  QUERYID = 1

  FIELDS = {
    QUERYID => {:type => ::Thrift::Types::STRING, :name => 'queryId'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field queryId is unset!') unless @queryId
  end

  ::Thrift::Struct.generate_accessors self
end

