From d5f0c77a6c81e9e56da81976645614280247f7a2 Mon Sep 17 00:00:00 2001
From: Aaron Kimball <aaron@cloudera.com>
Date: Fri, 12 Mar 2010 17:22:18 -0800
Subject: [PATCH 0140/1179] HADOOP-5640. Allow ServicePlugins to hook callbacks into key service events

Description: <a href="http://issues.apache.org/jira/browse/HADOOP-5257" title="Export namenode/datanode functionality through a pluggable RPC layer"><del>HADOOP-5257</del></a> added the ability for NameNode and DataNode to start and stop ServicePlugin implementations at NN/DN start/stop. However, this is insufficient integration for some common use cases.

<p>We should add some functionality for Plugins to subscribe to events generated by the service they're plugging into. Some potential hook points are:</p>

<p>NameNode:</p>
<ul class="alternate" type="square">
	<li>new datanode registered</li>
	<li>datanode has died</li>
	<li>exception caught</li>
	<li>etc?</li>
</ul>

<p>DataNode:</p>
<ul class="alternate" type="square">
	<li>startup</li>
	<li>initial registration with NN complete (this is important for HADOOP-4707 to sync up datanode.dnRegistration.name with the NN-side registration)</li>
	<li>namenode reconnect</li>
	<li>some block transfer hooks?</li>
	<li>exception caught</li>
</ul>

<p>I see two potential routes for implementation:</p>

<p>1) We make an enum for the types of hookpoints and have a general function in the ServicePlugin interface. Something like:</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-java"><span class="code-keyword">enum</span> HookPoint {
  DN_STARTUP,
  DN_RECEIVED_NEW_BLOCK,
  DN_CAUGHT_EXCEPTION,
 ...
}

void runHook(HookPoint hp, <span class="code-object">Object</span> value);</pre>
</div></div>

<p>2) We make classes specific to each "pluggable" as was originally suggested in HADDOP-5257. Something like:</p>

<div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
<pre class="code-java">class DataNodePlugin {
  void datanodeStarted() {}
  void receivedNewBlock(block info, etc) {}
  void caughtException(Exception e) {}
  ...
}</pre>
</div></div>

<p>I personally prefer option (2) since we can ensure plugin API compatibility at compile-time, and we avoid an ugly switch statement in a runHook() function.</p>

<p>Interested to hear what people's thoughts are here.</p>

HADOOP-5640 puts this in the new test dir. It needs to be in the old one.

Reason: Improvement
Author: Todd Lipcon
Ref: UNKNOWN
---
 .../apache/hadoop/util/TestPluginDispatcher.java   |  124 --------------------
 .../apache/hadoop/util/TestPluginDispatcher.java   |  124 ++++++++++++++++++++
 2 files changed, 124 insertions(+), 124 deletions(-)
 delete mode 100644 src/test/core/org/apache/hadoop/util/TestPluginDispatcher.java
 create mode 100644 src/test/org/apache/hadoop/util/TestPluginDispatcher.java

diff --git a/src/test/core/org/apache/hadoop/util/TestPluginDispatcher.java b/src/test/core/org/apache/hadoop/util/TestPluginDispatcher.java
deleted file mode 100644
index 474c9af..0000000
--- a/src/test/core/org/apache/hadoop/util/TestPluginDispatcher.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.hadoop.util;
-
-
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.Executor;
-
-import junit.framework.TestCase;
-
-public class TestPluginDispatcher extends TestCase {
-
-  /**
-   * Ensure that dispatch works in general
-   */
-  public void testDispatch() {
-    AtomicInteger runCount = new AtomicInteger(0);
-
-    List<TestPlugin> plugins = Arrays.asList(
-      new TestPlugin[] {
-        new TestPlugin(runCount)
-      });
-
-    PluginDispatcher<TestPlugin> dispatcher =
-      new PluginDispatcher<TestPlugin>(plugins, new SameThreadExecutor());
-
-    dispatcher.dispatchCall(new RunMethodRunner());
-    assertEquals(runCount.get(), 1);
-  }
-
-  /**
-   * Ensure that, if a plugin is faulty during startup, it is removed
-   * from the plugin dispatcher.
-   */
-  public void testRemovalOnStartError() {
-    AtomicInteger runCount = new AtomicInteger(0);
-
-    List<TestPlugin> plugins = Arrays.asList(
-      new TestPlugin[] {
-        new TestPlugin(runCount),
-        new FaultyPlugin(runCount),
-        new TestPlugin(runCount)
-      });
-
-    PluginDispatcher<TestPlugin> dispatcher =
-      new PluginDispatcher<TestPlugin>(plugins, new SameThreadExecutor());
-
-    // Before we start the plugins, we can dispatch a call
-    // and it goes to all 3 plugins
-    dispatcher.dispatchCall(new RunMethodRunner());
-    assertEquals(runCount.get(), 3);
-
-    // When we dispatch the start, it should kill the faulty plugin
-    runCount.set(0);
-    dispatcher.dispatchStart(this);
-    dispatcher.dispatchCall(new RunMethodRunner());
-    assertEquals(runCount.get(), 2);
-  }
-
-  /**
-   * SingleArgumentRunnable that just calls plugin.run()
-   */
-  static class RunMethodRunner implements SingleArgumentRunnable<TestPlugin> {
-    public void run(TestPlugin p) {
-      p.run();
-    }
-  }
-
-  /**
-   * Plugin which increments a counter when its run method is called.
-   */
-  public static class TestPlugin implements ServicePlugin {
-    final AtomicInteger ai;
-
-    public TestPlugin(AtomicInteger ai) {
-      this.ai = ai;
-    }
-    public void start(Object service) {}
-    public void stop() {}
-    public void close() {}
-    public void run() {
-      ai.getAndIncrement();
-    }
-  }
-
-  /**
-   * Plugin which throws a RuntimeException on start.
-   */
-  public static class FaultyPlugin extends TestPlugin {
-    public FaultyPlugin(AtomicInteger ai) {
-      super(ai);
-    }
-    public void start(Object service) {
-      throw new RuntimeException("Kaboom!");
-    }
-  }
-
-  /**
-   * Executor which runs Runnables in the same thread that submits them.
-   */
-  public static class SameThreadExecutor implements Executor {
-    public void execute(Runnable r) {
-      r.run();
-    }
-  }
-}
\ No newline at end of file
diff --git a/src/test/org/apache/hadoop/util/TestPluginDispatcher.java b/src/test/org/apache/hadoop/util/TestPluginDispatcher.java
new file mode 100644
index 0000000..474c9af
--- /dev/null
+++ b/src/test/org/apache/hadoop/util/TestPluginDispatcher.java
@@ -0,0 +1,124 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.util;
+
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.Executor;
+
+import junit.framework.TestCase;
+
+public class TestPluginDispatcher extends TestCase {
+
+  /**
+   * Ensure that dispatch works in general
+   */
+  public void testDispatch() {
+    AtomicInteger runCount = new AtomicInteger(0);
+
+    List<TestPlugin> plugins = Arrays.asList(
+      new TestPlugin[] {
+        new TestPlugin(runCount)
+      });
+
+    PluginDispatcher<TestPlugin> dispatcher =
+      new PluginDispatcher<TestPlugin>(plugins, new SameThreadExecutor());
+
+    dispatcher.dispatchCall(new RunMethodRunner());
+    assertEquals(runCount.get(), 1);
+  }
+
+  /**
+   * Ensure that, if a plugin is faulty during startup, it is removed
+   * from the plugin dispatcher.
+   */
+  public void testRemovalOnStartError() {
+    AtomicInteger runCount = new AtomicInteger(0);
+
+    List<TestPlugin> plugins = Arrays.asList(
+      new TestPlugin[] {
+        new TestPlugin(runCount),
+        new FaultyPlugin(runCount),
+        new TestPlugin(runCount)
+      });
+
+    PluginDispatcher<TestPlugin> dispatcher =
+      new PluginDispatcher<TestPlugin>(plugins, new SameThreadExecutor());
+
+    // Before we start the plugins, we can dispatch a call
+    // and it goes to all 3 plugins
+    dispatcher.dispatchCall(new RunMethodRunner());
+    assertEquals(runCount.get(), 3);
+
+    // When we dispatch the start, it should kill the faulty plugin
+    runCount.set(0);
+    dispatcher.dispatchStart(this);
+    dispatcher.dispatchCall(new RunMethodRunner());
+    assertEquals(runCount.get(), 2);
+  }
+
+  /**
+   * SingleArgumentRunnable that just calls plugin.run()
+   */
+  static class RunMethodRunner implements SingleArgumentRunnable<TestPlugin> {
+    public void run(TestPlugin p) {
+      p.run();
+    }
+  }
+
+  /**
+   * Plugin which increments a counter when its run method is called.
+   */
+  public static class TestPlugin implements ServicePlugin {
+    final AtomicInteger ai;
+
+    public TestPlugin(AtomicInteger ai) {
+      this.ai = ai;
+    }
+    public void start(Object service) {}
+    public void stop() {}
+    public void close() {}
+    public void run() {
+      ai.getAndIncrement();
+    }
+  }
+
+  /**
+   * Plugin which throws a RuntimeException on start.
+   */
+  public static class FaultyPlugin extends TestPlugin {
+    public FaultyPlugin(AtomicInteger ai) {
+      super(ai);
+    }
+    public void start(Object service) {
+      throw new RuntimeException("Kaboom!");
+    }
+  }
+
+  /**
+   * Executor which runs Runnables in the same thread that submits them.
+   */
+  public static class SameThreadExecutor implements Executor {
+    public void execute(Runnable r) {
+      r.run();
+    }
+  }
+}
\ No newline at end of file
-- 
1.7.0.4

