#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

# Intentionally has a general name.
# because the test status check created in GitHub Actions
# currently randomly picks any associated workflow.
# So, the name was changed to make sense in that context too.
# See also https://github.community/t/specify-check-suite-when-creating-a-checkrun/118380/10

name: "On pull requests"
on:
  pull_request_target:
    types: [opened, edited, reopened]

jobs:
  label:
    name: Label pull requests
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
    - uses: actions/labeler@v5
      with:
        repo-token: "${{ secrets.GITHUB_TOKEN }}"
        sync-labels: true

  jira-info:
    name: Comment JIRA information
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
    - name: Extract JIRA IDs and comment
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const prTitle = context.payload.pull_request.title;
          const prNumber = context.payload.pull_request.number;

          // Extract JIRA IDs from PR title
          const jiraIdRegex = /SPARK-\d+/g;
          const jiraIds = prTitle.match(jiraIdRegex);

          // If no JIRA IDs found, check for [MINOR] tag
          if (!jiraIds || jiraIds.length === 0) {
            const minorRegex = /^\[MINOR\]/i;
            if (minorRegex.test(prTitle)) {
              console.log('PR title has [MINOR] tag, skipping');
              return;
            }

            // Post reminder comment
            const reminderComment = `## ⚠️ Pull Request Title Validation\n\nThis pull request title does not contain a JIRA issue ID.\n\nPlease update the title to either:\n- Include a JIRA ID: \`[SPARK-12345] Your description\`\n- Mark as minor change: \`[MINOR] Your description\`\n\nFor minor changes that don't require a JIRA ticket (e.g., typo fixes), please prefix the title with \`[MINOR]\`.\n\n---\n*This comment was automatically generated by GitHub Actions*`;

            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const botComment = comments.data.find(comment =>
              comment.user.type === 'Bot' &&
              (comment.body.includes('## JIRA Issue Information') || comment.body.includes('## ⚠️ Pull Request Title Validation'))
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: reminderComment
              });
              console.log('Updated reminder comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: reminderComment
              });
              console.log('Created reminder comment');
            }
            return;
          }

          // Remove duplicates
          const uniqueJiraIds = [...new Set(jiraIds)];
          console.log(`Found JIRA IDs: ${uniqueJiraIds.join(', ')}`);

          // Fetch JIRA information for each ID
          const jiraBaseUrl = 'https://issues.apache.org/jira';
          const jiraInfos = [];

          for (const jiraId of uniqueJiraIds) {
            try {
              const response = await fetch(`${jiraBaseUrl}/rest/api/2/issue/${jiraId}`);

              if (!response.ok) {
                jiraInfos.push({
                  id: jiraId,
                  type: 'Unknown',
                  error: `Failed to fetch (HTTP ${response.status})`
                });
                continue;
              }

              const data = await response.json();
              const fields = data.fields;

              jiraInfos.push({
                id: jiraId,
                type: fields.issuetype?.name || 'Unknown',
                summary: fields.summary || 'N/A',
                assignee: fields.assignee ? fields.assignee.displayName : 'None',
                status: fields.status ? fields.status.name : 'Unknown',
                affected: fields.versions ? fields.versions.map(v => v.name) : []
              });
            } catch (error) {
              console.error(`Error fetching ${jiraId}:`, error);
              jiraInfos.push({
                id: jiraId,
                type: 'Unknown',
                error: error.message
              });
            }
          }

          // Format comment
          let commentBody = '## JIRA Issue Information\n\n';

          for (const info of jiraInfos) {
            if (info.error) {
              commentBody += `=== ${info.type} ${info.id} ===\n`;
              commentBody += `Error: ${info.error}\n\n`;
            } else {
              commentBody += `=== ${info.type} ${info.id} ===\n`;
              commentBody += `Summary ${info.summary}\n`;
              commentBody += `Assignee ${info.assignee}\n`;
              commentBody += `Status ${info.status}\n`;
              commentBody += `Affected ${JSON.stringify(info.affected)}\n\n`;
            }
          }

          commentBody += '---\n*This comment was automatically generated by GitHub Actions*';

          // Check if there's an existing comment from this action
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: prNumber
          });

          const botComment = comments.data.find(comment =>
            comment.user.type === 'Bot' &&
            (comment.body.includes('## JIRA Issue Information') || comment.body.includes('## ⚠️ Pull Request Title Validation'))
          );

          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: commentBody
            });
            console.log('Updated existing comment');
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: commentBody
            });
            console.log('Created new comment');
          }
