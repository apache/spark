Feature "WithAcceptance": Scenario "A simple pattern with one bound endpoint"
Feature "VarLengthAcceptance2": Scenario "Handling relationships that are already bound in variable length paths"
Feature "VarLengthAcceptance": Scenario "Handling unbounded variable length match"
Feature "VarLengthAcceptance": Scenario "Handling explicitly unbounded variable length match"
Feature "VarLengthAcceptance": Scenario "Handling lower bounded variable length match 1"
Feature "VarLengthAcceptance": Scenario "Handling lower bounded variable length match 2"
Feature "VarLengthAcceptance": Scenario "Handling lower bounded variable length match 3"
Feature "VarLengthAcceptance": Scenario "Handling a variable length relationship and a standard relationship in chain, zero length 1"
Feature "VarLengthAcceptance": Scenario "Handling a variable length relationship and a standard relationship in chain, zero length 2"
Feature "VarLengthAcceptance": Scenario "Handling a variable length relationship and a standard relationship in chain, single length 1"
Feature "VarLengthAcceptance": Scenario "Handling a variable length relationship and a standard relationship in chain, single length 2"
Feature "VarLengthAcceptance": Scenario "Handling a variable length relationship and a standard relationship in chain, longer 1"
Feature "VarLengthAcceptance": Scenario "Handling a variable length relationship and a standard relationship in chain, longer 2"
Feature "VarLengthAcceptance": Scenario "Handling a variable length relationship and a standard relationship in chain, longer 3"
Feature "VarLengthAcceptance": Scenario "Handling mixed relationship patterns and directions 1"
Feature "VarLengthAcceptance": Scenario "Handling mixed relationship patterns and directions 2"
Feature "VarLengthAcceptance": Scenario "Handling mixed relationship patterns 1"
Feature "VarLengthAcceptance": Scenario "Handling mixed relationship patterns 2"
Feature "UnwindAcceptance": Scenario "Unwinding a concatenation of lists"
Feature "UnwindAcceptance": Scenario "Unwinding a collected expression"
Feature "UnwindAcceptance": Scenario "Unwind does not remove variables from scope"
Feature "TypeConversionFunctions": Scenario "`toInteger()` handling mixed number types"
Feature "TypeConversionFunctions": Scenario "`toInteger()` handling Any type"
Feature "TypeConversionFunctions": Scenario "`toInteger()` on a list of strings"
Feature "TypeConversionFunctions": Scenario "`toFloat()` on mixed number types"
Feature "TypeConversionFunctions": Scenario "`toFloat()` handling Any type"
Feature "TypeConversionFunctions": Scenario "`toFloat()` on a list of strings"
Feature "TypeConversionFunctions": Scenario "`toString()` should work on Any type"
Feature "TypeConversionFunctions": Scenario "`toString()` on a list of integers"
Feature "TypeConversionFunctions": Scenario "`toBoolean()` on invalid types #1"
Feature "TypeConversionFunctions": Scenario "`toBoolean()` on invalid types #2"
Feature "TypeConversionFunctions": Scenario "`toBoolean()` on invalid types #3"
Feature "TypeConversionFunctions": Scenario "`toBoolean()` on invalid types #4"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in AND #1"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in AND #2"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in AND #3"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in AND #4"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in AND #5"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in OR #1"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in OR #2"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in OR #3"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in OR #4"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in OR #5"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in XOR #1"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in XOR #2"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in XOR #3"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in XOR #4"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in XOR #5"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in IN #4"
Feature "StartsWithAcceptance": Scenario "Handling non-string operands for STARTS WITH"
Feature "StartsWithAcceptance": Scenario "Handling non-string operands for CONTAINS"
Feature "StartsWithAcceptance": Scenario "Handling non-string operands for ENDS WITH"
Feature "SkipLimitAcceptanceTest": Scenario "SKIP with an expression that does not depend on variables"
Feature "SkipLimitAcceptanceTest": Scenario "LIMIT with an expression that does not depend on variables"
Feature "ReturnAcceptance2": Scenario "Return all variables"
Feature "ReturnAcceptance2": Scenario "Setting and returning the size of a list property"
Feature "ReturnAcceptance2": Scenario "Concatenating and returning the size of literal lists"
Feature "ReturnAcceptance2": Scenario "Returning nested expressions based on list property"
Feature "ReturnAcceptance2": Scenario "Arithmetic expressions should propagate null values"
Feature "ReturnAcceptance2": Scenario "Projecting an arithmetic expression with aggregation"
Feature "ReturnAcceptance2": Scenario "Multiple aliasing and backreferencing"
Feature "ReturnAcceptance2": Scenario "Reusing variable names"
Feature "ReturnAcceptance2": Scenario "Concatenating lists of same type"
Feature "ReturnAcceptance2": Scenario "Appending lists of same type"
Feature "ReturnAcceptance2": Scenario "DISTINCT inside aggregation should work with nested lists of maps in maps"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure that takes no arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure that takes no arguments"
Feature "ProcedureCallAcceptance": Scenario "Calling the same procedure twice using the same outputs in each call"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to VOID procedure that takes no arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query call to VOID procedure that takes no arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query call to VOID procedure does not consume rows"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to VOID procedure that takes no arguments, called with implicit arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure that takes no arguments and yields no results"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure that takes no arguments and yields no results"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with explicit arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with explicit arguments that drops all result fields"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with explicit arguments"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with implicit arguments"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type NUMBER accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type NUMBER accepts value of type FLOAT"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type FLOAT accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type INTEGER accepts value of type FLOAT"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with null argument"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with null argument"
Feature "PatternComprehension": Scenario "Pattern comprehension and ORDER BY"
Feature "PatternComprehension": Scenario "Returning a pattern comprehension"
Feature "PatternComprehension": Scenario "Returning a pattern comprehension with label predicate"
Feature "PatternComprehension": Scenario "Returning a pattern comprehension with bound nodes"
Feature "PatternComprehension": Scenario "Using a pattern comprehension in a WITH"
Feature "PatternComprehension": Scenario "Using a variable-length pattern comprehension in a WITH"
Feature "PatternComprehension": Scenario "Using pattern comprehension in RETURN"
Feature "PatternComprehension": Scenario "Aggregating on pattern comprehension"
Feature "PatternComprehension": Scenario "Using pattern comprehension to test existence"
Feature "PatternComprehension": Scenario "Pattern comprehension inside list comprehension"
Feature "PatternComprehension": Scenario "Get node degree via size of pattern comprehension"
Feature "PatternComprehension": Scenario "Get node degree via size of pattern comprehension that specifies a relationship type"
Feature "PatternComprehension": Scenario "Get node degree via size of pattern comprehension that specifies multiple relationship types"
Feature "PatternComprehension": Scenario "Introducing new node variable in pattern comprehension"
Feature "PatternComprehension": Scenario "Introducing new relationship variable in pattern comprehension"
Feature "PathEquality": Scenario "Direction of traversed relationship is not significant for path equality, simple"
Feature "OrderByAcceptance": Scenario "ORDER BY with negative parameter for LIMIT should not generate errors"
Feature "OptionalMatchAcceptance": Scenario "Named paths in optional matches"
Feature "OptionalMatchAcceptance": Scenario "Named paths inside optional matches with node predicates"
Feature "OptionalMatchAcceptance": Scenario "Variable length optional relationships"
Feature "OptionalMatchAcceptance": Scenario "Variable length optional relationships with length predicates"
Feature "OptionalMatchAcceptance": Scenario "Variable length optional relationships with bound nodes"
Feature "OptionalMatchAcceptance": Scenario "Variable length optional relationships with bound nodes, no matches"
Feature "OptionalMatchAcceptance": Scenario "Handling optional matches between optionally matched entities"
Feature "OptionalMatchAcceptance": Scenario "Handling optional matches between nulls"
Feature "MatchAcceptance2": Scenario "Aggregation with named paths"
Feature "MatchAcceptance2": Scenario "Simple variable length pattern"
Feature "MatchAcceptance2": Scenario "Variable length relationship without lower bound"
Feature "MatchAcceptance2": Scenario "Variable length relationship without bounds"
Feature "MatchAcceptance2": Scenario "Optionally matching named paths"
Feature "MatchAcceptance2": Scenario "Optionally matching named paths with single and variable length patterns"
Feature "MatchAcceptance2": Scenario "Optionally matching named paths with variable length patterns"
Feature "MatchAcceptance2": Scenario "Matching variable length patterns from a bound node"
Feature "MatchAcceptance2": Scenario "Variable length relationship in OPTIONAL MATCH"
Feature "MatchAcceptance2": Scenario "Handling direction of named paths"
Feature "MatchAcceptance2": Scenario "Simple OPTIONAL MATCH on empty graph"
Feature "MatchAcceptance2": Scenario "Handling fixed-length variable length pattern"
Feature "MatchAcceptance2": Scenario "Optionally matching from null nodes should return null"
Feature "MatchAcceptance2": Scenario "OPTIONAL MATCH returns null"
Feature "MatchAcceptance2": Scenario "Zero-length named path"
Feature "MatchAcceptance2": Scenario "Variable-length named path"
Feature "MatchAcceptance2": Scenario "Matching using a relationship that is already bound"
Feature "MatchAcceptance2": Scenario "Matching using a relationship that is already bound, in conjunction with aggregation"
Feature "MatchAcceptance2": Scenario "Matching using a relationship that is already bound, in conjunction with aggregation and ORDER BY"
Feature "MatchAcceptance2": Scenario "Matching with LIMIT and optionally matching using a relationship that is already bound"
Feature "MatchAcceptance2": Scenario "Matching with LIMIT and optionally matching using a relationship and node that are both already bound"
Feature "MatchAcceptance2": Scenario "Matching with LIMIT, then matching again using a relationship and node that are both already bound along with an additional predicate"
Feature "MatchAcceptance2": Scenario "Matching with LIMIT and predicates, then matching again using a relationship and node that are both already bound along with a duplicate predicate"
Feature "MatchAcceptance2": Scenario "Matching twice with conflicting relationship types on same relationship"
Feature "MatchAcceptance2": Scenario "Matching twice with duplicate relationship types on same relationship"
Feature "MatchAcceptance2": Scenario "Matching relationships into a list and matching variable length using the list"
Feature "MatchAcceptance2": Scenario "Matching relationships into a list and matching variable length using the list, with bound nodes"
Feature "MatchAcceptance2": Scenario "Matching relationships into a list and matching variable length using the list, with bound nodes, wrong direction"
Feature "MatchAcceptance2": Scenario "Matching and optionally matching with bound nodes in reverse direction"
Feature "MatchAcceptance2": Scenario "Matching and optionally matching with unbound nodes and equality predicate in reverse direction"
Feature "MatchAcceptance2": Scenario "Matching variable length pattern with property predicate"
Feature "MatchAcceptance2": Scenario "Variable length pattern checking labels on endnodes"
Feature "MatchAcceptance2": Scenario "Variable length pattern with label predicate on both sides"
Feature "MatchAcceptance2": Scenario "Undirected named path"
Feature "MatchAcceptance2": Scenario "Named path with WITH"
Feature "MatchAcceptance2": Scenario "Named path with alternating directed/undirected relationships"
Feature "MatchAcceptance2": Scenario "Named path with multiple alternating directed/undirected relationships"
Feature "MatchAcceptance2": Scenario "Named path with undirected fixed variable length pattern"
Feature "MatchAcceptance2": Scenario "Adding list properties in projection"
Feature "MatchAcceptance2": Scenario "Variable length relationship variables are lists of relationships"
Feature "MatchAcceptance2": Scenario "Variable length patterns and nulls"
Feature "MatchAcceptance2": Scenario "Projecting a list of nodes and relationships"
Feature "MatchAcceptance2": Scenario "Projecting a map of nodes and relationships"
Feature "MatchAcceptance2": Scenario "Respecting direction when matching existing path"
Feature "MatchAcceptance2": Scenario "Respecting direction when matching non-existent path"
Feature "MatchAcceptance2": Scenario "Respecting direction when matching non-existent path with multiple directions"
Feature "MatchAcceptance2": Scenario "Matching path with both directions should respect other directions"
Feature "MatchAcceptance2": Scenario "Matching path with multiple bidirectional relationships"
Feature "MatchAcceptance2": Scenario "Matching longer variable length paths"
Feature "MatchAcceptance2": Scenario "Counting rows after MATCH, MERGE, OPTIONAL MATCH"
Feature "MatchAcceptance": Scenario "Path query should return results in written order"
Feature "MatchAcceptance": Scenario "Longer path query should return results in written order"
Feature "MatchAcceptance": Scenario "Return a simple path"
Feature "MatchAcceptance": Scenario "Return a three node path"
Feature "MatchAcceptance": Scenario "Do not return anything because path length does not match"
Feature "MatchAcceptance": Scenario "Pass the path length test"
Feature "MatchAcceptance": Scenario "Return relationships by fetching them from the path - starting from the end"
Feature "MatchAcceptance": Scenario "Return relationships by fetching them from the path"
Feature "MatchAcceptance": Scenario "Return relationships by collecting them as a list - wrong way"
Feature "MatchAcceptance": Scenario "Return relationships by collecting them as a list - undirected"
Feature "MatchAcceptance": Scenario "Return relationships by collecting them as a list"
Feature "MatchAcceptance": Scenario "Return a var length path"
Feature "MatchAcceptance": Scenario "Return a var length path of length zero"
Feature "MatchAcceptance": Scenario "Return a named var length path of length zero"
Feature "MatchAcceptance": Scenario "Accept skip zero"
Feature "ListComprehension": Scenario "Returning a list comprehension"
Feature "ListComprehension": Scenario "Using a list comprehension in a WITH"
Feature "ListComprehension": Scenario "Using a list comprehension in a WHERE"
Feature "FunctionsAcceptance": Scenario "Functions should return null if they get path containing unbound"
Feature "FunctionsAcceptance": Scenario "`split()`"
Feature "FunctionsAcceptance": Scenario "`properties()` on null"
Feature "FunctionsAcceptance": Scenario "`reverse()`"
Feature "FunctionsAcceptance": Scenario "`percentileDisc()` #1"
Feature "FunctionsAcceptance": Scenario "`percentileDisc()` #2"
Feature "FunctionsAcceptance": Scenario "`percentileDisc()` #3"
Feature "FunctionsAcceptance": Scenario "`percentileCont()` #1"
Feature "FunctionsAcceptance": Scenario "`percentileCont()` #2"
Feature "FunctionsAcceptance": Scenario "`percentileCont()` #3"
Feature "FunctionsAcceptance": Scenario "`type()` handling Any type"
Feature "FunctionsAcceptance": Scenario "`labels()` should accept type Any"
Feature "ExpressionAcceptance": Scenario "IN should work with list slices"
Feature "ExpressionAcceptance": Scenario "IN should work with literal list slices"
Feature "ExpressionAcceptance": Scenario "Execute n['name'] in read queries"
Feature "ExpressionAcceptance": Scenario "Execute n['name'] in update queries"
Feature "ExpressionAcceptance": Scenario "Use dynamic property lookup based on parameters when there is no type information"
Feature "ExpressionAcceptance": Scenario "Use dynamic property lookup based on parameters when there is lhs type information"
Feature "ExpressionAcceptance": Scenario "Use dynamic property lookup based on parameters when there is rhs type information"
Feature "EqualsAcceptance": Scenario "Any-typed string comparison"
Feature "Comparability": Scenario "Comparing strings and integers using > in an AND'd predicate"
Feature "Comparability": Scenario "Comparing strings and integers using > in a OR'd predicate"
Feature "Comparability": Scenario "Comparing across types yields null, except numbers #1"
Feature "Comparability": Scenario "Comparing across types yields null, except numbers #2"
Feature "Comparability": Scenario "Comparing across types yields null, except numbers #3"
Feature "Comparability": Scenario "Comparing across types yields null, except numbers #4"
Feature "ColumnNameAcceptance": Scenario "Keeping used expression 2"
Feature "ColumnNameAcceptance": Scenario "Keeping used expression 3"
Feature "ColumnNameAcceptance": Scenario "Keeping used expression 4"
Feature "AggregationAcceptance": Scenario "Handle aggregation on functions"
Feature "AggregationAcceptance": Scenario "Aggregates in aggregates"
Feature "AggregationAcceptance": Scenario "Multiple aggregates on same variable"
Feature "AggregationAcceptance": Scenario "Aggregation of named paths"
Feature "AggregationAcceptance": Scenario "Aggregation with `min()`"
Feature "AggregationAcceptance": Scenario "Handle subexpression in aggregation also occurring as standalone expression with nested aggregation in a literal map"
Feature "AggregationAcceptance": Scenario "Projection during aggregation in WITH before MERGE and after WITH with predicate"
Feature "AggregationAcceptance": Scenario "`max()` should aggregate strings"
Feature "AggregationAcceptance": Scenario "`min()` should aggregate strings"
Feature "Aggregation": Scenario "`min()` over mixed values"
Feature "Aggregation": Scenario "`min()` over list values"
Feature "Aggregation": Scenario "`max()` over mixed values"
Feature "Aggregation": Scenario "`max()` over strings"
Feature "Aggregation": Scenario "`max()` over mixed numeric values"
Feature "Aggregation": Scenario "`min()` over strings"
Feature "Aggregation": Scenario "`max()` over list values"
Feature "ListOperations": Scenario "Size of list comprehension"
Feature "ListOperations": Scenario "IN should return null when LHS and RHS both ultimately contain null, even if LHS and RHS are of different types (nested list and flat list)"
Feature "ListOperations": Scenario "IN should return false when matching a number with a string - list version"
Feature "ListOperations": Scenario "IN should work with an empty list"
Feature "ListOperations": Scenario "IN should return false when types of LHS and RHS don't match - singleton list"
Feature "ListOperations": Scenario "IN should return false when matching a number with a string"
Feature "ListOperations": Scenario "IN should return true when LHS and RHS contain a nested list - singleton version"
Feature "ListOperations": Scenario "IN should return null if comparison with null is required for empty list"
Feature "ListOperations": Scenario "IN should work with an empty list in the presence of other list elements: not matching"
Feature "ListOperations": Scenario "IN should work with list slices"
Feature "ListOperations": Scenario "Equality between different nested lists with null should return false"
Feature "ListOperations": Scenario "IN should return null if comparison with null is required, list version 2"
Feature "ListOperations": Scenario "IN should work with an empty list when comparing nested lists"
Feature "ListOperations": Scenario "IN should return null if LHS and RHS are null - list version"
Feature "ListOperations": Scenario "IN should return false for the empty list if the LHS and RHS types differ"
Feature "ListOperations": Scenario "IN should return false when LHS contains a nested list and type mismatch on RHS - singleton version"
Feature "ListOperations": Scenario "Equality between list and literal should return false"
Feature "ListOperations": Scenario "IN should return false when matching a list with a nested list with same elements"
Feature "ListOperations": Scenario "IN should return false when LHS contains a nested list and type mismatch on RHS"
Feature "ListOperations": Scenario "IN should work with an empty list in the presence of other list elements: matching"
Feature "ListOperations": Scenario "IN should return false if no match can be found, despite nulls"
Feature "ListOperations": Scenario "Setting and returning the size of a list property"
Feature "MatchAcceptance": Scenario "Return relationships by collecting them as a list - undirected, starting from one extreme"
Feature "ListOperations": Scenario "Collect and extract using a list comprehension"
Feature "ListOperations": Scenario "IN with different length lists should return false"
Feature "ListOperations": Scenario "IN should return true when both LHS and RHS contain nested lists"
Feature "ListOperations": Scenario "IN should return true when LHS and RHS contain nested list with multiple empty lists"
Feature "ListOperations": Scenario "IN should return true when types of LHS and RHS match - list"
Feature "ListOperations": Scenario "IN should return true when LHS and RHS contain a nested list"
Feature "ListOperations": Scenario "IN should return true when types of LHS and RHS match - singleton list"
Feature "ListOperations": Scenario "IN should return false when types of LHS and RHS don't match - list"
Feature "MatchAcceptance": Scenario "Return relationships by collecting them as a list - directed, one way"
Feature "ListOperations": Scenario "Concatenating lists of same type #2"
Feature "ListOperations": Scenario "IN should return null when comparing two so-called identical lists where one element is null"
Feature "ListOperations": Scenario "IN should return null if comparison with null is required, list version"
Feature "ListOperations": Scenario "IN should return false if different length lists with nested elements compared, even if the extra element is null"
Feature "ListOperations": Scenario "Equality between different lists with null should return false"
Feature "ListOperations": Scenario "Returning nested expressions based on list property"
Feature "ListOperations": Scenario "IN should work with literal list slices"
Feature "MatchAcceptance": Scenario "Return relationships by collecting them as a list - undirected, starting from two extremes"
Feature "ListOperations": Scenario "Equality between almost equal nested lists with null should return null"
Feature "ListOperations": Scenario "Equality of nested lists of different length should return false despite nulls"
Feature "ListOperations": Scenario "IN should return false if different length lists compared, even if the extra element is null"
Feature "ListOperations": Scenario "Equality between almost equal lists with null should return null"
Feature "ListOperations": Scenario "IN should return true when both LHS and RHS contain a nested list alongside a scalar element"
Feature "ListOperations": Scenario "IN should return true if correct list found despite null being another element within containing list"
Feature "ListOperations": Scenario "IN should return false when order of elements in LHS list and RHS list don't match"
Feature "ListOperations": Scenario "IN should return true with previous null match, list version"
Feature "ListOperations": Scenario "Collect and filter using a list comprehension"
Feature "ListOperations": Scenario "Concatenating and returning the size of literal lists"
Feature "ListOperations": Scenario "Concatenating lists of same type #1"