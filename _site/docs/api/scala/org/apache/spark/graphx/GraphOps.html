<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>GraphOps - org.apache.spark.graphx.GraphOps</title>
          <meta name="description" content="GraphOps - org.apache.spark.graphx.GraphOps" />
          <meta name="keywords" content="GraphOps org.apache.spark.graphx.GraphOps" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../../index.html';
            var hash = 'org.apache.spark.graphx.GraphOps';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img src="../../../../lib/class_big.png" />
        <p id="owner"><a href="../../../package.html" class="extype" name="org">org</a>.<a href="../../package.html" class="extype" name="org.apache">apache</a>.<a href="../package.html" class="extype" name="org.apache.spark">spark</a>.<a href="package.html" class="extype" name="org.apache.spark.graphx">graphx</a></p>
        <h1>GraphOps</h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">GraphOps</span><span class="tparams">[<span name="VD">VD</span>, <span name="ED">ED</span>]</span><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Contains additional functionality for <a href="Graph.html" class="extype" name="org.apache.spark.graphx.Graph">Graph</a>. All operations are expressed in terms of the
efficient GraphX API. This class is implicitly constructed for each Graph object.
</p></div><dl class="paramcmts block"><dt class="tparam">VD</dt><dd class="cmt"><p>the vertex attribute type</p></dd><dt class="tparam">ED</dt><dd class="cmt"><p>the edge attribute type
</p></dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><span class="extype" name="scala.Serializable">Serializable</span>, <span class="extype" name="java.io.Serializable">Serializable</span>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="org.apache.spark.graphx.GraphOps"><span>GraphOps</span></li><li class="in" name="scala.Serializable"><span>Serializable</span></li><li class="in" name="java.io.Serializable"><span>Serializable</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div id="constructors" class="members">
              <h3>Instance Constructors</h3>
              <ol><li name="org.apache.spark.graphx.GraphOps#&lt;init&gt;" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="&lt;init&gt;(graph:org.apache.spark.graphx.Graph[VD,ED])(implicitevidence$1:scala.reflect.ClassTag[VD],implicitevidence$2:scala.reflect.ClassTag[ED]):org.apache.spark.graphx.GraphOps[VD,ED]"></a>
      <a id="&lt;init&gt;:GraphOps[VD,ED]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">GraphOps</span><span class="params">(<span name="graph">graph: <a href="Graph.html" class="extype" name="org.apache.spark.graphx.Graph">Graph</a>[<span class="extype" name="org.apache.spark.graphx.GraphOps.VD">VD</span>, <span class="extype" name="org.apache.spark.graphx.GraphOps.ED">ED</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span class="extype" name="scala.reflect.ClassTag">ClassTag</span>[<span class="extype" name="org.apache.spark.graphx.GraphOps.VD">VD</span>]</span>, <span name="arg1">arg1: <span class="extype" name="scala.reflect.ClassTag">ClassTag</span>[<span class="extype" name="org.apache.spark.graphx.GraphOps.ED">ED</span>]</span>)</span>
      </span>
      </h4>
      <p class="shortcomment cmt"></p>
    </li></ol>
            </div>

        

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="org.apache.spark.graphx.GraphOps#collectEdges" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="collectEdges(edgeDirection:org.apache.spark.graphx.EdgeDirection):org.apache.spark.graphx.VertexRDD[Array[org.apache.spark.graphx.Edge[ED]]]"></a>
      <a id="collectEdges(EdgeDirection):VertexRDD[Array[Edge[ED]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collectEdges</span><span class="params">(<span name="edgeDirection">edgeDirection: <a href="EdgeDirection.html" class="extype" name="org.apache.spark.graphx.EdgeDirection">EdgeDirection</a></span>)</span><span class="result">: <a href="VertexRDD.html" class="extype" name="org.apache.spark.graphx.VertexRDD">VertexRDD</a>[<span class="extype" name="scala.Array">Array</span>[<a href="Edge.html" class="extype" name="org.apache.spark.graphx.Edge">Edge</a>[<span class="extype" name="org.apache.spark.graphx.GraphOps.ED">ED</span>]]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an RDD that contains for each vertex v its local edges,
i.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an RDD that contains for each vertex v its local edges,
i.e., the edges that are incident on v, in the user-specified direction.
Warning: note that singleton vertices, those with no edges in the given
direction will not be part of the return value.
</p></div><dl class="paramcmts block"><dt class="param">edgeDirection</dt><dd class="cmt"><p>the direction along which to collect
the local edges of vertices
</p></dd><dt>returns</dt><dd class="cmt"><p>the local edges for each vertex
</p></dd></dl><dl class="attributes block"> <dt>Note</dt><dd><span class="cmt"><p>This function could be highly inefficient on power-law
graphs where high degree vertices may force a large amount of
information to be collected to a single location.
</p></span></dd></dl></div>
    </li><li name="org.apache.spark.graphx.GraphOps#collectNeighborIds" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="collectNeighborIds(edgeDirection:org.apache.spark.graphx.EdgeDirection):org.apache.spark.graphx.VertexRDD[Array[org.apache.spark.graphx.VertexId]]"></a>
      <a id="collectNeighborIds(EdgeDirection):VertexRDD[Array[VertexId]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collectNeighborIds</span><span class="params">(<span name="edgeDirection">edgeDirection: <a href="EdgeDirection.html" class="extype" name="org.apache.spark.graphx.EdgeDirection">EdgeDirection</a></span>)</span><span class="result">: <a href="VertexRDD.html" class="extype" name="org.apache.spark.graphx.VertexRDD">VertexRDD</a>[<span class="extype" name="scala.Array">Array</span>[<a href="package.html#VertexId=Long" class="extmbr" name="org.apache.spark.graphx.VertexId">VertexId</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Collect the neighbor vertex ids for each vertex.</p><div class="fullcomment"><div class="comment cmt"><p>Collect the neighbor vertex ids for each vertex.
</p></div><dl class="paramcmts block"><dt class="param">edgeDirection</dt><dd class="cmt"><p>the direction along which to collect
neighboring vertices
</p></dd><dt>returns</dt><dd class="cmt"><p>the set of neighboring ids for each vertex
</p></dd></dl></div>
    </li><li name="org.apache.spark.graphx.GraphOps#collectNeighbors" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="collectNeighbors(edgeDirection:org.apache.spark.graphx.EdgeDirection):org.apache.spark.graphx.VertexRDD[Array[(org.apache.spark.graphx.VertexId,VD)]]"></a>
      <a id="collectNeighbors(EdgeDirection):VertexRDD[Array[(VertexId,VD)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collectNeighbors</span><span class="params">(<span name="edgeDirection">edgeDirection: <a href="EdgeDirection.html" class="extype" name="org.apache.spark.graphx.EdgeDirection">EdgeDirection</a></span>)</span><span class="result">: <a href="VertexRDD.html" class="extype" name="org.apache.spark.graphx.VertexRDD">VertexRDD</a>[<span class="extype" name="scala.Array">Array</span>[(<a href="package.html#VertexId=Long" class="extmbr" name="org.apache.spark.graphx.VertexId">VertexId</a>, <span class="extype" name="org.apache.spark.graphx.GraphOps.VD">VD</span>)]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Collect the neighbor vertex attributes for each vertex.</p><div class="fullcomment"><div class="comment cmt"><p>Collect the neighbor vertex attributes for each vertex.
</p></div><dl class="paramcmts block"><dt class="param">edgeDirection</dt><dd class="cmt"><p>the direction along which to collect
neighboring vertices
</p></dd><dt>returns</dt><dd class="cmt"><p>the vertex set of neighboring vertex attributes for each vertex
</p></dd></dl><dl class="attributes block"> <dt>Note</dt><dd><span class="cmt"><p>This function could be highly inefficient on power-law
graphs where high degree vertices may force a large amount of
information to be collected to a single location.
</p></span></dd></dl></div>
    </li><li name="org.apache.spark.graphx.GraphOps#connectedComponents" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="connectedComponents():org.apache.spark.graphx.Graph[org.apache.spark.graphx.VertexId,ED]"></a>
      <a id="connectedComponents():Graph[VertexId,ED]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">connectedComponents</span><span class="params">()</span><span class="result">: <a href="Graph.html" class="extype" name="org.apache.spark.graphx.Graph">Graph</a>[<a href="package.html#VertexId=Long" class="extmbr" name="org.apache.spark.graphx.VertexId">VertexId</a>, <span class="extype" name="org.apache.spark.graphx.GraphOps.ED">ED</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Compute the connected component membership of each vertex and return a graph with the vertex
value containing the lowest vertex id in the connected component containing that vertex.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the connected component membership of each vertex and return a graph with the vertex
value containing the lowest vertex id in the connected component containing that vertex.
</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="lib/ConnectedComponents$.html#run[VD,ED](graph:org.apache.spark.graphx.Graph[VD,ED])(implicitevidence$1:scala.reflect.ClassTag[VD],implicitevidence$2:scala.reflect.ClassTag[ED]):org.apache.spark.graphx.Graph[org.apache.spark.graphx.VertexId,ED]" class="extmbr" name="org.apache.spark.graphx.lib.ConnectedComponents#run">org.apache.spark.graphx.lib.ConnectedComponents$#run</a>
</p></span></dd></dl></div>
    </li><li name="org.apache.spark.graphx.GraphOps#convertToCanonicalEdges" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="convertToCanonicalEdges(mergeFunc:(ED,ED)=&gt;ED):org.apache.spark.graphx.Graph[VD,ED]"></a>
      <a id="convertToCanonicalEdges((ED,ED)⇒ED):Graph[VD,ED]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">convertToCanonicalEdges</span><span class="params">(<span name="mergeFunc">mergeFunc: (<span class="extype" name="org.apache.spark.graphx.GraphOps.ED">ED</span>, <span class="extype" name="org.apache.spark.graphx.GraphOps.ED">ED</span>) ⇒ <span class="extype" name="org.apache.spark.graphx.GraphOps.ED">ED</span> = <span class="symbol">(e1, e2) =&gt; e1</span></span>)</span><span class="result">: <a href="Graph.html" class="extype" name="org.apache.spark.graphx.Graph">Graph</a>[<span class="extype" name="org.apache.spark.graphx.GraphOps.VD">VD</span>, <span class="extype" name="org.apache.spark.graphx.GraphOps.ED">ED</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Convert bi-directional edges into uni-directional ones.</p><div class="fullcomment"><div class="comment cmt"><p>Convert bi-directional edges into uni-directional ones.
Some graph algorithms (e.g., TriangleCount) assume that an input graph
has its edges in canonical direction.
This function rewrites the vertex ids of edges so that srcIds are bigger
than dstIds, and merges the duplicated edges.
</p></div><dl class="paramcmts block"><dt class="param">mergeFunc</dt><dd class="cmt"><p>the user defined reduce function which should
be commutative and associative and is used to combine the output
of the map phase
</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting graph with canonical edges
</p></dd></dl></div>
    </li><li name="org.apache.spark.graphx.GraphOps#degrees" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="degrees:org.apache.spark.graphx.VertexRDD[Int]"></a>
      <a id="degrees:VertexRDD[Int]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">degrees</span><span class="result">: <a href="VertexRDD.html" class="extype" name="org.apache.spark.graphx.VertexRDD">VertexRDD</a>[<span class="extype" name="scala.Int">Int</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The degree of each vertex in the graph.</p><div class="fullcomment"><div class="comment cmt"><p>The degree of each vertex in the graph.</p></div><dl class="attributes block"> <dt>Note</dt><dd><span class="cmt"><p>Vertices with no edges are not returned in the resulting RDD.
</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="org.apache.spark.graphx.GraphOps#filter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="filter[VD2,ED2](preprocess:org.apache.spark.graphx.Graph[VD,ED]=&gt;org.apache.spark.graphx.Graph[VD2,ED2],epred:org.apache.spark.graphx.EdgeTriplet[VD2,ED2]=&gt;Boolean,vpred:(org.apache.spark.graphx.VertexId,VD2)=&gt;Boolean)(implicitevidence$4:scala.reflect.ClassTag[VD2],implicitevidence$5:scala.reflect.ClassTag[ED2]):org.apache.spark.graphx.Graph[VD,ED]"></a>
      <a id="filter[VD2,ED2]((Graph[VD,ED])⇒Graph[VD2,ED2],(EdgeTriplet[VD2,ED2])⇒Boolean,(VertexId,VD2)⇒Boolean)(ClassTag[VD2],ClassTag[ED2]):Graph[VD,ED]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">filter</span><span class="tparams">[<span name="VD2">VD2</span>, <span name="ED2">ED2</span>]</span><span class="params">(<span name="preprocess">preprocess: (<a href="Graph.html" class="extype" name="org.apache.spark.graphx.Graph">Graph</a>[<span class="extype" name="org.apache.spark.graphx.GraphOps.VD">VD</span>, <span class="extype" name="org.apache.spark.graphx.GraphOps.ED">ED</span>]) ⇒ <a href="Graph.html" class="extype" name="org.apache.spark.graphx.Graph">Graph</a>[<span class="extype" name="org.apache.spark.graphx.GraphOps.filter.VD2">VD2</span>, <span class="extype" name="org.apache.spark.graphx.GraphOps.filter.ED2">ED2</span>]</span>, <span name="epred">epred: (<a href="EdgeTriplet.html" class="extype" name="org.apache.spark.graphx.EdgeTriplet">EdgeTriplet</a>[<span class="extype" name="org.apache.spark.graphx.GraphOps.filter.VD2">VD2</span>, <span class="extype" name="org.apache.spark.graphx.GraphOps.filter.ED2">ED2</span>]) ⇒ <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">(x: EdgeTriplet[VD2, ED2]) =&gt; true</span></span>, <span name="vpred">vpred: (<a href="package.html#VertexId=Long" class="extmbr" name="org.apache.spark.graphx.VertexId">VertexId</a>, <span class="extype" name="org.apache.spark.graphx.GraphOps.filter.VD2">VD2</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">(v:VertexId, d:VD2) =&gt; true</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span class="extype" name="scala.reflect.ClassTag">ClassTag</span>[<span class="extype" name="org.apache.spark.graphx.GraphOps.filter.VD2">VD2</span>]</span>, <span name="arg1">arg1: <span class="extype" name="scala.reflect.ClassTag">ClassTag</span>[<span class="extype" name="org.apache.spark.graphx.GraphOps.filter.ED2">ED2</span>]</span>)</span><span class="result">: <a href="Graph.html" class="extype" name="org.apache.spark.graphx.Graph">Graph</a>[<span class="extype" name="org.apache.spark.graphx.GraphOps.VD">VD</span>, <span class="extype" name="org.apache.spark.graphx.GraphOps.ED">ED</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Filter the graph by computing some values to filter on, and applying the predicates.</p><div class="fullcomment"><div class="comment cmt"><p>Filter the graph by computing some values to filter on, and applying the predicates.
</p></div><dl class="paramcmts block"><dt class="tparam">VD2</dt><dd class="cmt"><p>vertex type the vpred operates on</p></dd><dt class="tparam">ED2</dt><dd class="cmt"><p>edge type the epred operates on</p></dd><dt class="param">preprocess</dt><dd class="cmt"><p>a function to compute new vertex and edge data before filtering</p></dd><dt class="param">epred</dt><dd class="cmt"><p>edge pred to filter on after preprocess, see more details under
 <a href="Graph.html#subgraph(epred:org.apache.spark.graphx.EdgeTriplet[VD,ED]=&gt;Boolean,vpred:(org.apache.spark.graphx.VertexId,VD)=&gt;Boolean):org.apache.spark.graphx.Graph[VD,ED]" class="extmbr" name="org.apache.spark.graphx.Graph#subgraph">org.apache.spark.graphx.Graph#subgraph</a></p></dd><dt class="param">vpred</dt><dd class="cmt"><p>vertex pred to filter on after prerocess, see more details under
 <a href="Graph.html#subgraph(epred:org.apache.spark.graphx.EdgeTriplet[VD,ED]=&gt;Boolean,vpred:(org.apache.spark.graphx.VertexId,VD)=&gt;Boolean):org.apache.spark.graphx.Graph[VD,ED]" class="extmbr" name="org.apache.spark.graphx.Graph#subgraph">org.apache.spark.graphx.Graph#subgraph</a></p></dd><dt>returns</dt><dd class="cmt"><p>a subgraph of the orginal graph, with its data unchanged
</p></dd></dl><dl class="attributes block"> <div class="block">Example:
               <ol><li class="cmt"><p>This function can be used to filter the graph based on some property, without
changing the vertex and edge values in your program. For example, we could remove the vertices
in a graph with 0 outdegree</p><pre>graph.filter(
graph <span class="kw">=&gt;</span> {
  <span class="kw">val</span> degrees: VertexRDD[<span class="std">Int</span>] = graph.outDegrees
  graph.outerJoinVertices(degrees) {(vid, data, deg) <span class="kw">=&gt;</span> deg.getOrElse(<span class="num">0</span>)}
},
vpred = (vid: VertexId, deg:<span class="std">Int</span>) <span class="kw">=&gt;</span> deg &gt; <span class="num">0</span>
)</pre></li></ol>
            </div></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="org.apache.spark.graphx.GraphOps#inDegrees" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="inDegrees:org.apache.spark.graphx.VertexRDD[Int]"></a>
      <a id="inDegrees:VertexRDD[Int]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">inDegrees</span><span class="result">: <a href="VertexRDD.html" class="extype" name="org.apache.spark.graphx.VertexRDD">VertexRDD</a>[<span class="extype" name="scala.Int">Int</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The in-degree of each vertex in the graph.</p><div class="fullcomment"><div class="comment cmt"><p>The in-degree of each vertex in the graph.</p></div><dl class="attributes block"> <dt>Note</dt><dd><span class="cmt"><p>Vertices with no in-edges are not returned in the resulting RDD.
</p></span></dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="org.apache.spark.graphx.GraphOps#joinVertices" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="joinVertices[U](table:org.apache.spark.rdd.RDD[(org.apache.spark.graphx.VertexId,U)])(mapFunc:(org.apache.spark.graphx.VertexId,VD,U)=&gt;VD)(implicitevidence$3:scala.reflect.ClassTag[U]):org.apache.spark.graphx.Graph[VD,ED]"></a>
      <a id="joinVertices[U](RDD[(VertexId,U)])((VertexId,VD,U)⇒VD)(ClassTag[U]):Graph[VD,ED]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">joinVertices</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="table">table: <a href="../rdd/RDD.html" class="extype" name="org.apache.spark.rdd.RDD">RDD</a>[(<a href="package.html#VertexId=Long" class="extmbr" name="org.apache.spark.graphx.VertexId">VertexId</a>, <span class="extype" name="org.apache.spark.graphx.GraphOps.joinVertices.U">U</span>)]</span>)</span><span class="params">(<span name="mapFunc">mapFunc: (<a href="package.html#VertexId=Long" class="extmbr" name="org.apache.spark.graphx.VertexId">VertexId</a>, <span class="extype" name="org.apache.spark.graphx.GraphOps.VD">VD</span>, <span class="extype" name="org.apache.spark.graphx.GraphOps.joinVertices.U">U</span>) ⇒ <span class="extype" name="org.apache.spark.graphx.GraphOps.VD">VD</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span class="extype" name="scala.reflect.ClassTag">ClassTag</span>[<span class="extype" name="org.apache.spark.graphx.GraphOps.joinVertices.U">U</span>]</span>)</span><span class="result">: <a href="Graph.html" class="extype" name="org.apache.spark.graphx.Graph">Graph</a>[<span class="extype" name="org.apache.spark.graphx.GraphOps.VD">VD</span>, <span class="extype" name="org.apache.spark.graphx.GraphOps.ED">ED</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Join the vertices with an RDD and then apply a function from the
vertex and RDD entry to a new vertex value.</p><div class="fullcomment"><div class="comment cmt"><p>Join the vertices with an RDD and then apply a function from the
vertex and RDD entry to a new vertex value.  The input table
should contain at most one entry for each vertex.  If no entry is
provided the map function is skipped and the old value is used.
</p></div><dl class="paramcmts block"><dt class="tparam">U</dt><dd class="cmt"><p>the type of entry in the table of updates</p></dd><dt class="param">table</dt><dd class="cmt"><p>the table to join with the vertices in the graph.
The table should contain at most one entry for each vertex.</p></dd><dt class="param">mapFunc</dt><dd class="cmt"><p>the function used to compute the new vertex
values.  The map function is invoked only for vertices with a
corresponding entry in the table otherwise the old vertex value
is used.
</p></dd></dl><dl class="attributes block"> <div class="block">Example:
               <ol><li class="cmt"><p>This function is used to update the vertices with new
values based on external data.  For example we could add the out
degree to each vertex record</p><pre><span class="kw">val</span> rawGraph: Graph[<span class="std">Int</span>, <span class="std">Int</span>] = GraphLoader.edgeListFile(sc, <span class="lit">"webgraph"</span>)
  .mapVertices((_, _) <span class="kw">=&gt;</span> <span class="num">0</span>)
<span class="kw">val</span> outDeg = rawGraph.outDegrees
<span class="kw">val</span> graph = rawGraph.joinVertices[<span class="std">Int</span>](outDeg)
  ((_, _, outDeg) <span class="kw">=&gt;</span> outDeg)</pre></li></ol>
            </div></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="org.apache.spark.graphx.GraphOps#numEdges" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="numEdges:Long"></a>
      <a id="numEdges:Long"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">numEdges</span><span class="result">: <span class="extype" name="scala.Long">Long</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">The number of edges in the graph.</p>
    </li><li name="org.apache.spark.graphx.GraphOps#numVertices" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="numVertices:Long"></a>
      <a id="numVertices:Long"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">numVertices</span><span class="result">: <span class="extype" name="scala.Long">Long</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">The number of vertices in the graph.</p>
    </li><li name="org.apache.spark.graphx.GraphOps#outDegrees" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="outDegrees:org.apache.spark.graphx.VertexRDD[Int]"></a>
      <a id="outDegrees:VertexRDD[Int]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">outDegrees</span><span class="result">: <a href="VertexRDD.html" class="extype" name="org.apache.spark.graphx.VertexRDD">VertexRDD</a>[<span class="extype" name="scala.Int">Int</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The out-degree of each vertex in the graph.</p><div class="fullcomment"><div class="comment cmt"><p>The out-degree of each vertex in the graph.</p></div><dl class="attributes block"> <dt>Note</dt><dd><span class="cmt"><p>Vertices with no out-edges are not returned in the resulting RDD.
</p></span></dd></dl></div>
    </li><li name="org.apache.spark.graphx.GraphOps#pageRank" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pageRank(tol:Double,resetProb:Double):org.apache.spark.graphx.Graph[Double,Double]"></a>
      <a id="pageRank(Double,Double):Graph[Double,Double]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pageRank</span><span class="params">(<span name="tol">tol: <span class="extype" name="scala.Double">Double</span></span>, <span name="resetProb">resetProb: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">0.15</span></span>)</span><span class="result">: <a href="Graph.html" class="extype" name="org.apache.spark.graphx.Graph">Graph</a>[<span class="extype" name="scala.Double">Double</span>, <span class="extype" name="scala.Double">Double</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Run a dynamic version of PageRank returning a graph with vertex attributes containing the
PageRank and edge attributes containing the normalized edge weight.</p><div class="fullcomment"><div class="comment cmt"><p>Run a dynamic version of PageRank returning a graph with vertex attributes containing the
PageRank and edge attributes containing the normalized edge weight.
</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="lib/PageRank$.html#runUntilConvergence[VD,ED](graph:org.apache.spark.graphx.Graph[VD,ED],tol:Double,resetProb:Double)(implicitevidence$3:scala.reflect.ClassTag[VD],implicitevidence$4:scala.reflect.ClassTag[ED]):org.apache.spark.graphx.Graph[Double,Double]" class="extmbr" name="org.apache.spark.graphx.lib.PageRank#runUntilConvergence">org.apache.spark.graphx.lib.PageRank$#runUntilConvergence</a>
</p></span></dd></dl></div>
    </li><li name="org.apache.spark.graphx.GraphOps#pickRandomVertex" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="pickRandomVertex():org.apache.spark.graphx.VertexId"></a>
      <a id="pickRandomVertex():VertexId"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pickRandomVertex</span><span class="params">()</span><span class="result">: <a href="package.html#VertexId=Long" class="extmbr" name="org.apache.spark.graphx.VertexId">VertexId</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Picks a random vertex from the graph and returns its ID.</p>
    </li><li name="org.apache.spark.graphx.GraphOps#pregel" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pregel[A](initialMsg:A,maxIterations:Int,activeDirection:org.apache.spark.graphx.EdgeDirection)(vprog:(org.apache.spark.graphx.VertexId,VD,A)=&gt;VD,sendMsg:org.apache.spark.graphx.EdgeTriplet[VD,ED]=&gt;Iterator[(org.apache.spark.graphx.VertexId,A)],mergeMsg:(A,A)=&gt;A)(implicitevidence$6:scala.reflect.ClassTag[A]):org.apache.spark.graphx.Graph[VD,ED]"></a>
      <a id="pregel[A](A,Int,EdgeDirection)((VertexId,VD,A)⇒VD,(EdgeTriplet[VD,ED])⇒Iterator[(VertexId,A)],(A,A)⇒A)(ClassTag[A]):Graph[VD,ED]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pregel</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="initialMsg">initialMsg: <span class="extype" name="org.apache.spark.graphx.GraphOps.pregel.A">A</span></span>, <span name="maxIterations">maxIterations: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">Int.MaxValue</span></span>, <span name="activeDirection">activeDirection: <a href="EdgeDirection.html" class="extype" name="org.apache.spark.graphx.EdgeDirection">EdgeDirection</a> = <span class="symbol"><span class="name"><a href="EdgeDirection$.html">EdgeDirection.Either</a></span></span></span>)</span><span class="params">(<span name="vprog">vprog: (<a href="package.html#VertexId=Long" class="extmbr" name="org.apache.spark.graphx.VertexId">VertexId</a>, <span class="extype" name="org.apache.spark.graphx.GraphOps.VD">VD</span>, <span class="extype" name="org.apache.spark.graphx.GraphOps.pregel.A">A</span>) ⇒ <span class="extype" name="org.apache.spark.graphx.GraphOps.VD">VD</span></span>, <span name="sendMsg">sendMsg: (<a href="EdgeTriplet.html" class="extype" name="org.apache.spark.graphx.EdgeTriplet">EdgeTriplet</a>[<span class="extype" name="org.apache.spark.graphx.GraphOps.VD">VD</span>, <span class="extype" name="org.apache.spark.graphx.GraphOps.ED">ED</span>]) ⇒ <span class="extype" name="scala.Iterator">Iterator</span>[(<a href="package.html#VertexId=Long" class="extmbr" name="org.apache.spark.graphx.VertexId">VertexId</a>, <span class="extype" name="org.apache.spark.graphx.GraphOps.pregel.A">A</span>)]</span>, <span name="mergeMsg">mergeMsg: (<span class="extype" name="org.apache.spark.graphx.GraphOps.pregel.A">A</span>, <span class="extype" name="org.apache.spark.graphx.GraphOps.pregel.A">A</span>) ⇒ <span class="extype" name="org.apache.spark.graphx.GraphOps.pregel.A">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span class="extype" name="scala.reflect.ClassTag">ClassTag</span>[<span class="extype" name="org.apache.spark.graphx.GraphOps.pregel.A">A</span>]</span>)</span><span class="result">: <a href="Graph.html" class="extype" name="org.apache.spark.graphx.Graph">Graph</a>[<span class="extype" name="org.apache.spark.graphx.GraphOps.VD">VD</span>, <span class="extype" name="org.apache.spark.graphx.GraphOps.ED">ED</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Execute a Pregel-like iterative vertex-parallel abstraction.</p><div class="fullcomment"><div class="comment cmt"><p>Execute a Pregel-like iterative vertex-parallel abstraction.  The
user-defined vertex-program <code>vprog</code> is executed in parallel on
each vertex receiving any inbound messages and computing a new
value for the vertex.  The <code>sendMsg</code> function is then invoked on
all out-edges and is used to compute an optional message to the
destination vertex. The <code>mergeMsg</code> function is a commutative
associative function used to combine messages destined to the
same vertex.</p><p>On the first iteration all vertices receive the <code>initialMsg</code> and
on subsequent iterations if a vertex does not receive a message
then the vertex-program is not invoked.</p><p>This function iterates until there are no remaining messages, or
for <code>maxIterations</code> iterations.
</p></div><dl class="paramcmts block"><dt class="tparam">A</dt><dd class="cmt"><p>the Pregel message type
</p></dd><dt class="param">initialMsg</dt><dd class="cmt"><p>the message each vertex will receive at the on
the first iteration
</p></dd><dt class="param">maxIterations</dt><dd class="cmt"><p>the maximum number of iterations to run for
</p></dd><dt class="param">activeDirection</dt><dd class="cmt"><p>the direction of edges incident to a vertex that received a message in
the previous round on which to run <code>sendMsg</code>. For example, if this is <code>EdgeDirection.Out</code>, only
out-edges of vertices that received a message in the previous round will run.
</p></dd><dt class="param">vprog</dt><dd class="cmt"><p>the user-defined vertex program which runs on each
vertex and receives the inbound message and computes a new vertex
value.  On the first iteration the vertex program is invoked on
all vertices and is passed the default message.  On subsequent
iterations the vertex program is only invoked on those vertices
that receive messages.
</p></dd><dt class="param">sendMsg</dt><dd class="cmt"><p>a user supplied function that is applied to out
edges of vertices that received messages in the current
iteration
</p></dd><dt class="param">mergeMsg</dt><dd class="cmt"><p>a user supplied function that takes two incoming
messages of type A and merges them into a single message of type
A.  <i>This function must be commutative and associative and
ideally the size of A should not increase.</i>
</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting graph at the end of the computation</p></dd></dl></div>
    </li><li name="org.apache.spark.graphx.GraphOps#staticPageRank" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="staticPageRank(numIter:Int,resetProb:Double):org.apache.spark.graphx.Graph[Double,Double]"></a>
      <a id="staticPageRank(Int,Double):Graph[Double,Double]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">staticPageRank</span><span class="params">(<span name="numIter">numIter: <span class="extype" name="scala.Int">Int</span></span>, <span name="resetProb">resetProb: <span class="extype" name="scala.Double">Double</span> = <span class="symbol">0.15</span></span>)</span><span class="result">: <a href="Graph.html" class="extype" name="org.apache.spark.graphx.Graph">Graph</a>[<span class="extype" name="scala.Double">Double</span>, <span class="extype" name="scala.Double">Double</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Run PageRank for a fixed number of iterations returning a graph with vertex attributes
containing the PageRank and edge attributes the normalized edge weight.</p><div class="fullcomment"><div class="comment cmt"><p>Run PageRank for a fixed number of iterations returning a graph with vertex attributes
containing the PageRank and edge attributes the normalized edge weight.
</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="lib/PageRank$.html#run[VD,ED](graph:org.apache.spark.graphx.Graph[VD,ED],numIter:Int,resetProb:Double)(implicitevidence$1:scala.reflect.ClassTag[VD],implicitevidence$2:scala.reflect.ClassTag[ED]):org.apache.spark.graphx.Graph[Double,Double]" class="extmbr" name="org.apache.spark.graphx.lib.PageRank#run">org.apache.spark.graphx.lib.PageRank$#run</a>
</p></span></dd></dl></div>
    </li><li name="org.apache.spark.graphx.GraphOps#stronglyConnectedComponents" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="stronglyConnectedComponents(numIter:Int):org.apache.spark.graphx.Graph[org.apache.spark.graphx.VertexId,ED]"></a>
      <a id="stronglyConnectedComponents(Int):Graph[VertexId,ED]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">stronglyConnectedComponents</span><span class="params">(<span name="numIter">numIter: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Graph.html" class="extype" name="org.apache.spark.graphx.Graph">Graph</a>[<a href="package.html#VertexId=Long" class="extmbr" name="org.apache.spark.graphx.VertexId">VertexId</a>, <span class="extype" name="org.apache.spark.graphx.GraphOps.ED">ED</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Compute the strongly connected component (SCC) of each vertex and return a graph with the
vertex value containing the lowest vertex id in the SCC containing that vertex.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the strongly connected component (SCC) of each vertex and return a graph with the
vertex value containing the lowest vertex id in the SCC containing that vertex.
</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="lib/StronglyConnectedComponents$.html#run[VD,ED](graph:org.apache.spark.graphx.Graph[VD,ED],numIter:Int)(implicitevidence$1:scala.reflect.ClassTag[VD],implicitevidence$2:scala.reflect.ClassTag[ED]):org.apache.spark.graphx.Graph[org.apache.spark.graphx.VertexId,ED]" class="extmbr" name="org.apache.spark.graphx.lib.StronglyConnectedComponents#run">org.apache.spark.graphx.lib.StronglyConnectedComponents$#run</a>
</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="org.apache.spark.graphx.GraphOps#triangleCount" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="triangleCount():org.apache.spark.graphx.Graph[Int,ED]"></a>
      <a id="triangleCount():Graph[Int,ED]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">triangleCount</span><span class="params">()</span><span class="result">: <a href="Graph.html" class="extype" name="org.apache.spark.graphx.Graph">Graph</a>[<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="org.apache.spark.graphx.GraphOps.ED">ED</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Compute the number of triangles passing through each vertex.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the number of triangles passing through each vertex.
</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="lib/TriangleCount$.html#run[VD,ED](graph:org.apache.spark.graphx.Graph[VD,ED])(implicitevidence$1:scala.reflect.ClassTag[VD],implicitevidence$2:scala.reflect.ClassTag[ED]):org.apache.spark.graphx.Graph[Int,ED]" class="extmbr" name="org.apache.spark.graphx.lib.TriangleCount#run">org.apache.spark.graphx.lib.TriangleCount$#run</a>
</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.Serializable">
              <h3>Inherited from <span class="extype" name="scala.Serializable">Serializable</span></h3>
            </div><div class="parent" name="java.io.Serializable">
              <h3>Inherited from <span class="extype" name="java.io.Serializable">Serializable</span></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
      <script defer="defer" type="text/javascript" id="jquery-js" src="../../../../lib/jquery.js"></script><script defer="defer" type="text/javascript" id="jquery-ui-js" src="../../../../lib/jquery-ui.js"></script><script defer="defer" type="text/javascript" id="tools-tooltip-js" src="../../../../lib/tools.tooltip.js"></script><script defer="defer" type="text/javascript" id="template-js" src="../../../../lib/template.js"></script>
    </body>
      </html>