<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_71) on Thu Apr 02 14:27:49 PDT 2015 -->
<title>KafkaUtils (Spark 1.4.0 JavaDoc)</title>
<meta name="date" content="2015-04-02">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="KafkaUtils (Spark 1.4.0 JavaDoc)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/apache/spark/streaming/kafka/KafkaReceiver.html" title="class in org.apache.spark.streaming.kafka"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtilsPythonHelper.html" title="class in org.apache.spark.streaming.kafka"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/spark/streaming/kafka/KafkaUtils.html" target="_top">Frames</a></li>
<li><a href="KafkaUtils.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.apache.spark.streaming.kafka</div>
<h2 title="Class KafkaUtils" class="title">Class KafkaUtils</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>Object</li>
<li>
<ul class="inheritance">
<li>org.apache.spark.streaming.kafka.KafkaUtils</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">KafkaUtils</span>
extends Object</pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtils.html#KafkaUtils()">KafkaUtils</a></strong>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;,R&gt;&nbsp;<br><a href="../../../../../org/apache/spark/streaming/api/java/JavaInputDStream.html" title="class in org.apache.spark.streaming.api.java">JavaInputDStream</a>&lt;R&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtils.html#createDirectStream(org.apache.spark.streaming.api.java.JavaStreamingContext,%20java.lang.Class,%20java.lang.Class,%20java.lang.Class,%20java.lang.Class,%20java.lang.Class,%20java.util.Map,%20java.util.Map,%20org.apache.spark.api.java.function.Function)">createDirectStream</a></strong>(<a href="../../../../../org/apache/spark/streaming/api/java/JavaStreamingContext.html" title="class in org.apache.spark.streaming.api.java">JavaStreamingContext</a>&nbsp;jssc,
                  Class&lt;K&gt;&nbsp;keyClass,
                  Class&lt;V&gt;&nbsp;valueClass,
                  Class&lt;KD&gt;&nbsp;keyDecoderClass,
                  Class&lt;VD&gt;&nbsp;valueDecoderClass,
                  Class&lt;R&gt;&nbsp;recordClass,
                  java.util.Map&lt;String,String&gt;&nbsp;kafkaParams,
                  java.util.Map&lt;kafka.common.TopicAndPartition,Long&gt;&nbsp;fromOffsets,
                  <a href="../../../../../org/apache/spark/api/java/function/Function.html" title="interface in org.apache.spark.api.java.function">Function</a>&lt;kafka.message.MessageAndMetadata&lt;K,V&gt;,R&gt;&nbsp;messageHandler)</code>
<div class="block">:: Experimental ::
 Create an input stream that directly pulls messages from Kafka Brokers
 without using any receiver.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;&gt;&nbsp;<br><a href="../../../../../org/apache/spark/streaming/api/java/JavaPairInputDStream.html" title="class in org.apache.spark.streaming.api.java">JavaPairInputDStream</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtils.html#createDirectStream(org.apache.spark.streaming.api.java.JavaStreamingContext,%20java.lang.Class,%20java.lang.Class,%20java.lang.Class,%20java.lang.Class,%20java.util.Map,%20java.util.Set)">createDirectStream</a></strong>(<a href="../../../../../org/apache/spark/streaming/api/java/JavaStreamingContext.html" title="class in org.apache.spark.streaming.api.java">JavaStreamingContext</a>&nbsp;jssc,
                  Class&lt;K&gt;&nbsp;keyClass,
                  Class&lt;V&gt;&nbsp;valueClass,
                  Class&lt;KD&gt;&nbsp;keyDecoderClass,
                  Class&lt;VD&gt;&nbsp;valueDecoderClass,
                  java.util.Map&lt;String,String&gt;&nbsp;kafkaParams,
                  java.util.Set&lt;String&gt;&nbsp;topics)</code>
<div class="block">:: Experimental ::
 Create an input stream that directly pulls messages from Kafka Brokers
 without using any receiver.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;,R&gt;&nbsp;<br><a href="../../../../../org/apache/spark/streaming/dstream/InputDStream.html" title="class in org.apache.spark.streaming.dstream">InputDStream</a>&lt;R&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtils.html#createDirectStream(org.apache.spark.streaming.StreamingContext,%20scala.collection.immutable.Map,%20scala.collection.immutable.Map,%20scala.Function1,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag)">createDirectStream</a></strong>(<a href="../../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</a>&nbsp;ssc,
                  scala.collection.immutable.Map&lt;String,String&gt;&nbsp;kafkaParams,
                  scala.collection.immutable.Map&lt;kafka.common.TopicAndPartition,Object&gt;&nbsp;fromOffsets,
                  scala.Function1&lt;kafka.message.MessageAndMetadata&lt;K,V&gt;,R&gt;&nbsp;messageHandler,
                  scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$14,
                  scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$15,
                  scala.reflect.ClassTag&lt;KD&gt;&nbsp;evidence$16,
                  scala.reflect.ClassTag&lt;VD&gt;&nbsp;evidence$17,
                  scala.reflect.ClassTag&lt;R&gt;&nbsp;evidence$18)</code>
<div class="block">:: Experimental ::
 Create an input stream that directly pulls messages from Kafka Brokers
 without using any receiver.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;&gt;&nbsp;<br><a href="../../../../../org/apache/spark/streaming/dstream/InputDStream.html" title="class in org.apache.spark.streaming.dstream">InputDStream</a>&lt;scala.Tuple2&lt;K,V&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtils.html#createDirectStream(org.apache.spark.streaming.StreamingContext,%20scala.collection.immutable.Map,%20scala.collection.immutable.Set,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag)">createDirectStream</a></strong>(<a href="../../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</a>&nbsp;ssc,
                  scala.collection.immutable.Map&lt;String,String&gt;&nbsp;kafkaParams,
                  scala.collection.immutable.Set&lt;String&gt;&nbsp;topics,
                  scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$19,
                  scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$20,
                  scala.reflect.ClassTag&lt;KD&gt;&nbsp;evidence$21,
                  scala.reflect.ClassTag&lt;VD&gt;&nbsp;evidence$22)</code>
<div class="block">:: Experimental ::
 Create an input stream that directly pulls messages from Kafka Brokers
 without using any receiver.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;,R&gt;&nbsp;<br><a href="../../../../../org/apache/spark/api/java/JavaRDD.html" title="class in org.apache.spark.api.java">JavaRDD</a>&lt;R&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtils.html#createRDD(org.apache.spark.api.java.JavaSparkContext,%20java.lang.Class,%20java.lang.Class,%20java.lang.Class,%20java.lang.Class,%20java.lang.Class,%20java.util.Map,%20org.apache.spark.streaming.kafka.OffsetRange[],%20java.util.Map,%20org.apache.spark.api.java.function.Function)">createRDD</a></strong>(<a href="../../../../../org/apache/spark/api/java/JavaSparkContext.html" title="class in org.apache.spark.api.java">JavaSparkContext</a>&nbsp;jsc,
         Class&lt;K&gt;&nbsp;keyClass,
         Class&lt;V&gt;&nbsp;valueClass,
         Class&lt;KD&gt;&nbsp;keyDecoderClass,
         Class&lt;VD&gt;&nbsp;valueDecoderClass,
         Class&lt;R&gt;&nbsp;recordClass,
         java.util.Map&lt;String,String&gt;&nbsp;kafkaParams,
         <a href="../../../../../org/apache/spark/streaming/kafka/OffsetRange.html" title="class in org.apache.spark.streaming.kafka">OffsetRange</a>[]&nbsp;offsetRanges,
         java.util.Map&lt;kafka.common.TopicAndPartition,<a href="../../../../../org/apache/spark/streaming/kafka/Broker.html" title="class in org.apache.spark.streaming.kafka">Broker</a>&gt;&nbsp;leaders,
         <a href="../../../../../org/apache/spark/api/java/function/Function.html" title="interface in org.apache.spark.api.java.function">Function</a>&lt;kafka.message.MessageAndMetadata&lt;K,V&gt;,R&gt;&nbsp;messageHandler)</code>
<div class="block">:: Experimental ::
 Create a RDD from Kafka using offset ranges for each topic and partition.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;&gt;&nbsp;<br><a href="../../../../../org/apache/spark/api/java/JavaPairRDD.html" title="class in org.apache.spark.api.java">JavaPairRDD</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtils.html#createRDD(org.apache.spark.api.java.JavaSparkContext,%20java.lang.Class,%20java.lang.Class,%20java.lang.Class,%20java.lang.Class,%20java.util.Map,%20org.apache.spark.streaming.kafka.OffsetRange[])">createRDD</a></strong>(<a href="../../../../../org/apache/spark/api/java/JavaSparkContext.html" title="class in org.apache.spark.api.java">JavaSparkContext</a>&nbsp;jsc,
         Class&lt;K&gt;&nbsp;keyClass,
         Class&lt;V&gt;&nbsp;valueClass,
         Class&lt;KD&gt;&nbsp;keyDecoderClass,
         Class&lt;VD&gt;&nbsp;valueDecoderClass,
         java.util.Map&lt;String,String&gt;&nbsp;kafkaParams,
         <a href="../../../../../org/apache/spark/streaming/kafka/OffsetRange.html" title="class in org.apache.spark.streaming.kafka">OffsetRange</a>[]&nbsp;offsetRanges)</code>
<div class="block">Create a RDD from Kafka using offset ranges for each topic and partition.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;&gt;&nbsp;<br><a href="../../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;scala.Tuple2&lt;K,V&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtils.html#createRDD(org.apache.spark.SparkContext,%20scala.collection.immutable.Map,%20org.apache.spark.streaming.kafka.OffsetRange[],%20scala.reflect.ClassTag,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag)">createRDD</a></strong>(<a href="../../../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</a>&nbsp;sc,
         scala.collection.immutable.Map&lt;String,String&gt;&nbsp;kafkaParams,
         <a href="../../../../../org/apache/spark/streaming/kafka/OffsetRange.html" title="class in org.apache.spark.streaming.kafka">OffsetRange</a>[]&nbsp;offsetRanges,
         scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$5,
         scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$6,
         scala.reflect.ClassTag&lt;KD&gt;&nbsp;evidence$7,
         scala.reflect.ClassTag&lt;VD&gt;&nbsp;evidence$8)</code>
<div class="block">Create a RDD from Kafka using offset ranges for each topic and partition.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;,R&gt;&nbsp;<br><a href="../../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;R&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtils.html#createRDD(org.apache.spark.SparkContext,%20scala.collection.immutable.Map,%20org.apache.spark.streaming.kafka.OffsetRange[],%20scala.collection.immutable.Map,%20scala.Function1,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag)">createRDD</a></strong>(<a href="../../../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</a>&nbsp;sc,
         scala.collection.immutable.Map&lt;String,String&gt;&nbsp;kafkaParams,
         <a href="../../../../../org/apache/spark/streaming/kafka/OffsetRange.html" title="class in org.apache.spark.streaming.kafka">OffsetRange</a>[]&nbsp;offsetRanges,
         scala.collection.immutable.Map&lt;kafka.common.TopicAndPartition,<a href="../../../../../org/apache/spark/streaming/kafka/Broker.html" title="class in org.apache.spark.streaming.kafka">Broker</a>&gt;&nbsp;leaders,
         scala.Function1&lt;kafka.message.MessageAndMetadata&lt;K,V&gt;,R&gt;&nbsp;messageHandler,
         scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$9,
         scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$10,
         scala.reflect.ClassTag&lt;KD&gt;&nbsp;evidence$11,
         scala.reflect.ClassTag&lt;VD&gt;&nbsp;evidence$12,
         scala.reflect.ClassTag&lt;R&gt;&nbsp;evidence$13)</code>
<div class="block">:: Experimental ::
 Create a RDD from Kafka using offset ranges for each topic and partition.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;K,V,U extends kafka.serializer.Decoder&lt;?&gt;,T extends kafka.serializer.Decoder&lt;?&gt;&gt;&nbsp;<br><a href="../../../../../org/apache/spark/streaming/api/java/JavaPairReceiverInputDStream.html" title="class in org.apache.spark.streaming.api.java">JavaPairReceiverInputDStream</a>&lt;K,V&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtils.html#createStream(org.apache.spark.streaming.api.java.JavaStreamingContext,%20java.lang.Class,%20java.lang.Class,%20java.lang.Class,%20java.lang.Class,%20java.util.Map,%20java.util.Map,%20org.apache.spark.storage.StorageLevel)">createStream</a></strong>(<a href="../../../../../org/apache/spark/streaming/api/java/JavaStreamingContext.html" title="class in org.apache.spark.streaming.api.java">JavaStreamingContext</a>&nbsp;jssc,
            Class&lt;K&gt;&nbsp;keyTypeClass,
            Class&lt;V&gt;&nbsp;valueTypeClass,
            Class&lt;U&gt;&nbsp;keyDecoderClass,
            Class&lt;T&gt;&nbsp;valueDecoderClass,
            java.util.Map&lt;String,String&gt;&nbsp;kafkaParams,
            java.util.Map&lt;String,Integer&gt;&nbsp;topics,
            <a href="../../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</a>&nbsp;storageLevel)</code>
<div class="block">Create an input stream that pulls messages from Kafka Brokers.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../../../../org/apache/spark/streaming/api/java/JavaPairReceiverInputDStream.html" title="class in org.apache.spark.streaming.api.java">JavaPairReceiverInputDStream</a>&lt;String,String&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtils.html#createStream(org.apache.spark.streaming.api.java.JavaStreamingContext,%20java.lang.String,%20java.lang.String,%20java.util.Map)">createStream</a></strong>(<a href="../../../../../org/apache/spark/streaming/api/java/JavaStreamingContext.html" title="class in org.apache.spark.streaming.api.java">JavaStreamingContext</a>&nbsp;jssc,
            String&nbsp;zkQuorum,
            String&nbsp;groupId,
            java.util.Map&lt;String,Integer&gt;&nbsp;topics)</code>
<div class="block">Create an input stream that pulls messages from Kafka Brokers.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../../../org/apache/spark/streaming/api/java/JavaPairReceiverInputDStream.html" title="class in org.apache.spark.streaming.api.java">JavaPairReceiverInputDStream</a>&lt;String,String&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtils.html#createStream(org.apache.spark.streaming.api.java.JavaStreamingContext,%20java.lang.String,%20java.lang.String,%20java.util.Map,%20org.apache.spark.storage.StorageLevel)">createStream</a></strong>(<a href="../../../../../org/apache/spark/streaming/api/java/JavaStreamingContext.html" title="class in org.apache.spark.streaming.api.java">JavaStreamingContext</a>&nbsp;jssc,
            String&nbsp;zkQuorum,
            String&nbsp;groupId,
            java.util.Map&lt;String,Integer&gt;&nbsp;topics,
            <a href="../../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</a>&nbsp;storageLevel)</code>
<div class="block">Create an input stream that pulls messages from Kafka Brokers.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;K,V,U extends kafka.serializer.Decoder&lt;?&gt;,T extends kafka.serializer.Decoder&lt;?&gt;&gt;&nbsp;<br><a href="../../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</a>&lt;scala.Tuple2&lt;K,V&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtils.html#createStream(org.apache.spark.streaming.StreamingContext,%20scala.collection.immutable.Map,%20scala.collection.immutable.Map,%20org.apache.spark.storage.StorageLevel,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag,%20scala.reflect.ClassTag)">createStream</a></strong>(<a href="../../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</a>&nbsp;ssc,
            scala.collection.immutable.Map&lt;String,String&gt;&nbsp;kafkaParams,
            scala.collection.immutable.Map&lt;String,Object&gt;&nbsp;topics,
            <a href="../../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</a>&nbsp;storageLevel,
            scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$1,
            scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$2,
            scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$3,
            scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$4)</code>
<div class="block">Create an input stream that pulls messages from Kafka Brokers.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</a>&lt;scala.Tuple2&lt;String,String&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtils.html#createStream(org.apache.spark.streaming.StreamingContext,%20java.lang.String,%20java.lang.String,%20scala.collection.immutable.Map,%20org.apache.spark.storage.StorageLevel)">createStream</a></strong>(<a href="../../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</a>&nbsp;ssc,
            String&nbsp;zkQuorum,
            String&nbsp;groupId,
            scala.collection.immutable.Map&lt;String,Object&gt;&nbsp;topics,
            <a href="../../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</a>&nbsp;storageLevel)</code>
<div class="block">Create an input stream that pulls messages from Kafka Brokers.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="KafkaUtils()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>KafkaUtils</h4>
<pre>public&nbsp;KafkaUtils()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="createStream(org.apache.spark.streaming.StreamingContext, java.lang.String, java.lang.String, scala.collection.immutable.Map, org.apache.spark.storage.StorageLevel)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createStream</h4>
<pre>public static&nbsp;<a href="../../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</a>&lt;scala.Tuple2&lt;String,String&gt;&gt;&nbsp;createStream(<a href="../../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</a>&nbsp;ssc,
                                                             String&nbsp;zkQuorum,
                                                             String&nbsp;groupId,
                                                             scala.collection.immutable.Map&lt;String,Object&gt;&nbsp;topics,
                                                             <a href="../../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</a>&nbsp;storageLevel)</pre>
<div class="block">Create an input stream that pulls messages from Kafka Brokers.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>ssc</code> - StreamingContext object</dd><dd><code>zkQuorum</code> - Zookeeper quorum (hostname:port,hostname:port,..)</dd><dd><code>groupId</code> - The group id for this consumer</dd><dd><code>topics</code> - Map of (topic_name -> numPartitions) to consume. Each partition is consumed
                  in its own thread</dd><dd><code>storageLevel</code> - Storage level to use for storing the received objects
                      (default: StorageLevel.MEMORY_AND_DISK_SER_2)</dd></dl>
</li>
</ul>
<a name="createStream(org.apache.spark.streaming.StreamingContext, scala.collection.immutable.Map, scala.collection.immutable.Map, org.apache.spark.storage.StorageLevel, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createStream</h4>
<pre>public static&nbsp;&lt;K,V,U extends kafka.serializer.Decoder&lt;?&gt;,T extends kafka.serializer.Decoder&lt;?&gt;&gt;&nbsp;<a href="../../../../../org/apache/spark/streaming/dstream/ReceiverInputDStream.html" title="class in org.apache.spark.streaming.dstream">ReceiverInputDStream</a>&lt;scala.Tuple2&lt;K,V&gt;&gt;&nbsp;createStream(<a href="../../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</a>&nbsp;ssc,
                                                                                                                                     scala.collection.immutable.Map&lt;String,String&gt;&nbsp;kafkaParams,
                                                                                                                                     scala.collection.immutable.Map&lt;String,Object&gt;&nbsp;topics,
                                                                                                                                     <a href="../../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</a>&nbsp;storageLevel,
                                                                                                                                     scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$1,
                                                                                                                                     scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$2,
                                                                                                                                     scala.reflect.ClassTag&lt;U&gt;&nbsp;evidence$3,
                                                                                                                                     scala.reflect.ClassTag&lt;T&gt;&nbsp;evidence$4)</pre>
<div class="block">Create an input stream that pulls messages from Kafka Brokers.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>ssc</code> - StreamingContext object</dd><dd><code>kafkaParams</code> - Map of kafka configuration parameters,
                    see http://kafka.apache.org/08/configuration.html</dd><dd><code>topics</code> - Map of (topic_name -> numPartitions) to consume. Each partition is consumed
                    in its own thread.</dd><dd><code>storageLevel</code> - Storage level to use for storing the received objects</dd></dl>
</li>
</ul>
<a name="createStream(org.apache.spark.streaming.api.java.JavaStreamingContext, java.lang.String, java.lang.String, java.util.Map)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createStream</h4>
<pre>public static&nbsp;<a href="../../../../../org/apache/spark/streaming/api/java/JavaPairReceiverInputDStream.html" title="class in org.apache.spark.streaming.api.java">JavaPairReceiverInputDStream</a>&lt;String,String&gt;&nbsp;createStream(<a href="../../../../../org/apache/spark/streaming/api/java/JavaStreamingContext.html" title="class in org.apache.spark.streaming.api.java">JavaStreamingContext</a>&nbsp;jssc,
                                                       String&nbsp;zkQuorum,
                                                       String&nbsp;groupId,
                                                       java.util.Map&lt;String,Integer&gt;&nbsp;topics)</pre>
<div class="block">Create an input stream that pulls messages from Kafka Brokers.
 Storage level of the data will be the default StorageLevel.MEMORY_AND_DISK_SER_2.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jssc</code> - JavaStreamingContext object</dd><dd><code>zkQuorum</code> - Zookeeper quorum (hostname:port,hostname:port,..)</dd><dd><code>groupId</code> - The group id for this consumer</dd><dd><code>topics</code> - Map of (topic_name -> numPartitions) to consume. Each partition is consumed
                  in its own thread</dd></dl>
</li>
</ul>
<a name="createStream(org.apache.spark.streaming.api.java.JavaStreamingContext, java.lang.String, java.lang.String, java.util.Map, org.apache.spark.storage.StorageLevel)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createStream</h4>
<pre>public static&nbsp;<a href="../../../../../org/apache/spark/streaming/api/java/JavaPairReceiverInputDStream.html" title="class in org.apache.spark.streaming.api.java">JavaPairReceiverInputDStream</a>&lt;String,String&gt;&nbsp;createStream(<a href="../../../../../org/apache/spark/streaming/api/java/JavaStreamingContext.html" title="class in org.apache.spark.streaming.api.java">JavaStreamingContext</a>&nbsp;jssc,
                                                       String&nbsp;zkQuorum,
                                                       String&nbsp;groupId,
                                                       java.util.Map&lt;String,Integer&gt;&nbsp;topics,
                                                       <a href="../../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</a>&nbsp;storageLevel)</pre>
<div class="block">Create an input stream that pulls messages from Kafka Brokers.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jssc</code> - JavaStreamingContext object</dd><dd><code>zkQuorum</code> - Zookeeper quorum (hostname:port,hostname:port,..).</dd><dd><code>groupId</code> - The group id for this consumer.</dd><dd><code>topics</code> - Map of (topic_name -> numPartitions) to consume. Each partition is consumed
                  in its own thread.</dd><dd><code>storageLevel</code> - RDD storage level.</dd></dl>
</li>
</ul>
<a name="createStream(org.apache.spark.streaming.api.java.JavaStreamingContext, java.lang.Class, java.lang.Class, java.lang.Class, java.lang.Class, java.util.Map, java.util.Map, org.apache.spark.storage.StorageLevel)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createStream</h4>
<pre>public static&nbsp;&lt;K,V,U extends kafka.serializer.Decoder&lt;?&gt;,T extends kafka.serializer.Decoder&lt;?&gt;&gt;&nbsp;<a href="../../../../../org/apache/spark/streaming/api/java/JavaPairReceiverInputDStream.html" title="class in org.apache.spark.streaming.api.java">JavaPairReceiverInputDStream</a>&lt;K,V&gt;&nbsp;createStream(<a href="../../../../../org/apache/spark/streaming/api/java/JavaStreamingContext.html" title="class in org.apache.spark.streaming.api.java">JavaStreamingContext</a>&nbsp;jssc,
                                                                                                                               Class&lt;K&gt;&nbsp;keyTypeClass,
                                                                                                                               Class&lt;V&gt;&nbsp;valueTypeClass,
                                                                                                                               Class&lt;U&gt;&nbsp;keyDecoderClass,
                                                                                                                               Class&lt;T&gt;&nbsp;valueDecoderClass,
                                                                                                                               java.util.Map&lt;String,String&gt;&nbsp;kafkaParams,
                                                                                                                               java.util.Map&lt;String,Integer&gt;&nbsp;topics,
                                                                                                                               <a href="../../../../../org/apache/spark/storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</a>&nbsp;storageLevel)</pre>
<div class="block">Create an input stream that pulls messages from Kafka Brokers.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jssc</code> - JavaStreamingContext object</dd><dd><code>keyTypeClass</code> - Key type of DStream</dd><dd><code>valueTypeClass</code> - value type of Dstream</dd><dd><code>keyDecoderClass</code> - Type of kafka key decoder</dd><dd><code>valueDecoderClass</code> - Type of kafka value decoder</dd><dd><code>kafkaParams</code> - Map of kafka configuration parameters,
                    see http://kafka.apache.org/08/configuration.html</dd><dd><code>topics</code> - Map of (topic_name -> numPartitions) to consume. Each partition is consumed
                in its own thread</dd><dd><code>storageLevel</code> - RDD storage level.</dd></dl>
</li>
</ul>
<a name="createRDD(org.apache.spark.SparkContext, scala.collection.immutable.Map, org.apache.spark.streaming.kafka.OffsetRange[], scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRDD</h4>
<pre>public static&nbsp;&lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;&gt;&nbsp;<a href="../../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;scala.Tuple2&lt;K,V&gt;&gt;&nbsp;createRDD(<a href="../../../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</a>&nbsp;sc,
                                                                                                                   scala.collection.immutable.Map&lt;String,String&gt;&nbsp;kafkaParams,
                                                                                                                   <a href="../../../../../org/apache/spark/streaming/kafka/OffsetRange.html" title="class in org.apache.spark.streaming.kafka">OffsetRange</a>[]&nbsp;offsetRanges,
                                                                                                                   scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$5,
                                                                                                                   scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$6,
                                                                                                                   scala.reflect.ClassTag&lt;KD&gt;&nbsp;evidence$7,
                                                                                                                   scala.reflect.ClassTag&lt;VD&gt;&nbsp;evidence$8)</pre>
<div class="block">Create a RDD from Kafka using offset ranges for each topic and partition.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sc</code> - SparkContext object</dd><dd><code>kafkaParams</code> - Kafka <a href="http://kafka.apache.org/documentation.html#configuration">
    configuration parameters</a>. Requires "metadata.broker.list" or "bootstrap.servers"
    to be set with Kafka broker(s) (NOT zookeeper servers) specified in
    host1:port1,host2:port2 form.</dd><dd><code>offsetRanges</code> - Each OffsetRange in the batch corresponds to a
   range of offsets for a given Kafka topic/partition</dd></dl>
</li>
</ul>
<a name="createRDD(org.apache.spark.SparkContext, scala.collection.immutable.Map, org.apache.spark.streaming.kafka.OffsetRange[], scala.collection.immutable.Map, scala.Function1, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRDD</h4>
<pre>public static&nbsp;&lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;,R&gt;&nbsp;<a href="../../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;R&gt;&nbsp;createRDD(<a href="../../../../../org/apache/spark/SparkContext.html" title="class in org.apache.spark">SparkContext</a>&nbsp;sc,
                                                                                                     scala.collection.immutable.Map&lt;String,String&gt;&nbsp;kafkaParams,
                                                                                                     <a href="../../../../../org/apache/spark/streaming/kafka/OffsetRange.html" title="class in org.apache.spark.streaming.kafka">OffsetRange</a>[]&nbsp;offsetRanges,
                                                                                                     scala.collection.immutable.Map&lt;kafka.common.TopicAndPartition,<a href="../../../../../org/apache/spark/streaming/kafka/Broker.html" title="class in org.apache.spark.streaming.kafka">Broker</a>&gt;&nbsp;leaders,
                                                                                                     scala.Function1&lt;kafka.message.MessageAndMetadata&lt;K,V&gt;,R&gt;&nbsp;messageHandler,
                                                                                                     scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$9,
                                                                                                     scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$10,
                                                                                                     scala.reflect.ClassTag&lt;KD&gt;&nbsp;evidence$11,
                                                                                                     scala.reflect.ClassTag&lt;VD&gt;&nbsp;evidence$12,
                                                                                                     scala.reflect.ClassTag&lt;R&gt;&nbsp;evidence$13)</pre>
<div class="block">:: Experimental ::
 Create a RDD from Kafka using offset ranges for each topic and partition. This allows you
 specify the Kafka leader to connect to (to optimize fetching) and access the message as well
 as the metadata.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sc</code> - SparkContext object</dd><dd><code>kafkaParams</code> - Kafka <a href="http://kafka.apache.org/documentation.html#configuration">
    configuration parameters</a>. Requires "metadata.broker.list" or "bootstrap.servers"
    to be set with Kafka broker(s) (NOT zookeeper servers) specified in
    host1:port1,host2:port2 form.</dd><dd><code>offsetRanges</code> - Each OffsetRange in the batch corresponds to a
   range of offsets for a given Kafka topic/partition</dd><dd><code>leaders</code> - Kafka brokers for each TopicAndPartition in offsetRanges.  May be an empty map,
   in which case leaders will be looked up on the driver.</dd><dd><code>messageHandler</code> - Function for translating each message and metadata into the desired type</dd></dl>
</li>
</ul>
<a name="createRDD(org.apache.spark.api.java.JavaSparkContext, java.lang.Class, java.lang.Class, java.lang.Class, java.lang.Class, java.util.Map, org.apache.spark.streaming.kafka.OffsetRange[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRDD</h4>
<pre>public static&nbsp;&lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;&gt;&nbsp;<a href="../../../../../org/apache/spark/api/java/JavaPairRDD.html" title="class in org.apache.spark.api.java">JavaPairRDD</a>&lt;K,V&gt;&nbsp;createRDD(<a href="../../../../../org/apache/spark/api/java/JavaSparkContext.html" title="class in org.apache.spark.api.java">JavaSparkContext</a>&nbsp;jsc,
                                                                                                             Class&lt;K&gt;&nbsp;keyClass,
                                                                                                             Class&lt;V&gt;&nbsp;valueClass,
                                                                                                             Class&lt;KD&gt;&nbsp;keyDecoderClass,
                                                                                                             Class&lt;VD&gt;&nbsp;valueDecoderClass,
                                                                                                             java.util.Map&lt;String,String&gt;&nbsp;kafkaParams,
                                                                                                             <a href="../../../../../org/apache/spark/streaming/kafka/OffsetRange.html" title="class in org.apache.spark.streaming.kafka">OffsetRange</a>[]&nbsp;offsetRanges)</pre>
<div class="block">Create a RDD from Kafka using offset ranges for each topic and partition.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jsc</code> - JavaSparkContext object</dd><dd><code>kafkaParams</code> - Kafka <a href="http://kafka.apache.org/documentation.html#configuration">
    configuration parameters</a>. Requires "metadata.broker.list" or "bootstrap.servers"
    to be set with Kafka broker(s) (NOT zookeeper servers) specified in
    host1:port1,host2:port2 form.</dd><dd><code>offsetRanges</code> - Each OffsetRange in the batch corresponds to a
   range of offsets for a given Kafka topic/partition</dd></dl>
</li>
</ul>
<a name="createRDD(org.apache.spark.api.java.JavaSparkContext, java.lang.Class, java.lang.Class, java.lang.Class, java.lang.Class, java.lang.Class, java.util.Map, org.apache.spark.streaming.kafka.OffsetRange[], java.util.Map, org.apache.spark.api.java.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createRDD</h4>
<pre>public static&nbsp;&lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;,R&gt;&nbsp;<a href="../../../../../org/apache/spark/api/java/JavaRDD.html" title="class in org.apache.spark.api.java">JavaRDD</a>&lt;R&gt;&nbsp;createRDD(<a href="../../../../../org/apache/spark/api/java/JavaSparkContext.html" title="class in org.apache.spark.api.java">JavaSparkContext</a>&nbsp;jsc,
                                                                                                         Class&lt;K&gt;&nbsp;keyClass,
                                                                                                         Class&lt;V&gt;&nbsp;valueClass,
                                                                                                         Class&lt;KD&gt;&nbsp;keyDecoderClass,
                                                                                                         Class&lt;VD&gt;&nbsp;valueDecoderClass,
                                                                                                         Class&lt;R&gt;&nbsp;recordClass,
                                                                                                         java.util.Map&lt;String,String&gt;&nbsp;kafkaParams,
                                                                                                         <a href="../../../../../org/apache/spark/streaming/kafka/OffsetRange.html" title="class in org.apache.spark.streaming.kafka">OffsetRange</a>[]&nbsp;offsetRanges,
                                                                                                         java.util.Map&lt;kafka.common.TopicAndPartition,<a href="../../../../../org/apache/spark/streaming/kafka/Broker.html" title="class in org.apache.spark.streaming.kafka">Broker</a>&gt;&nbsp;leaders,
                                                                                                         <a href="../../../../../org/apache/spark/api/java/function/Function.html" title="interface in org.apache.spark.api.java.function">Function</a>&lt;kafka.message.MessageAndMetadata&lt;K,V&gt;,R&gt;&nbsp;messageHandler)</pre>
<div class="block">:: Experimental ::
 Create a RDD from Kafka using offset ranges for each topic and partition. This allows you
 specify the Kafka leader to connect to (to optimize fetching) and access the message as well
 as the metadata.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jsc</code> - JavaSparkContext object</dd><dd><code>kafkaParams</code> - Kafka <a href="http://kafka.apache.org/documentation.html#configuration">
    configuration parameters</a>. Requires "metadata.broker.list" or "bootstrap.servers"
    to be set with Kafka broker(s) (NOT zookeeper servers) specified in
    host1:port1,host2:port2 form.</dd><dd><code>offsetRanges</code> - Each OffsetRange in the batch corresponds to a
   range of offsets for a given Kafka topic/partition</dd><dd><code>leaders</code> - Kafka brokers for each TopicAndPartition in offsetRanges.  May be an empty map,
   in which case leaders will be looked up on the driver.</dd><dd><code>messageHandler</code> - Function for translating each message and metadata into the desired type</dd></dl>
</li>
</ul>
<a name="createDirectStream(org.apache.spark.streaming.StreamingContext, scala.collection.immutable.Map, scala.collection.immutable.Map, scala.Function1, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createDirectStream</h4>
<pre>public static&nbsp;&lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;,R&gt;&nbsp;<a href="../../../../../org/apache/spark/streaming/dstream/InputDStream.html" title="class in org.apache.spark.streaming.dstream">InputDStream</a>&lt;R&gt;&nbsp;createDirectStream(<a href="../../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</a>&nbsp;ssc,
                                                                                                                       scala.collection.immutable.Map&lt;String,String&gt;&nbsp;kafkaParams,
                                                                                                                       scala.collection.immutable.Map&lt;kafka.common.TopicAndPartition,Object&gt;&nbsp;fromOffsets,
                                                                                                                       scala.Function1&lt;kafka.message.MessageAndMetadata&lt;K,V&gt;,R&gt;&nbsp;messageHandler,
                                                                                                                       scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$14,
                                                                                                                       scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$15,
                                                                                                                       scala.reflect.ClassTag&lt;KD&gt;&nbsp;evidence$16,
                                                                                                                       scala.reflect.ClassTag&lt;VD&gt;&nbsp;evidence$17,
                                                                                                                       scala.reflect.ClassTag&lt;R&gt;&nbsp;evidence$18)</pre>
<div class="block">:: Experimental ::
 Create an input stream that directly pulls messages from Kafka Brokers
 without using any receiver. This stream can guarantee that each message
 from Kafka is included in transformations exactly once (see points below).
 <p>
 Points to note:
  - No receivers: This stream does not use any receiver. It directly queries Kafka
  - Offsets: This does not use Zookeeper to store offsets. The consumed offsets are tracked
    by the stream itself. For interoperability with Kafka monitoring tools that depend on 
    Zookeeper, you have to update Kafka/Zookeeper yourself from the streaming application.
    You can access the offsets used in each batch from the generated RDDs (see
    <a href="../../../../../org/apache/spark/streaming/kafka/HasOffsetRanges.html" title="interface in org.apache.spark.streaming.kafka"><code>HasOffsetRanges</code></a>).
  - Failure Recovery: To recover from driver failures, you have to enable checkpointing
    in the <code>StreamingContext</code>. The information on consumed offset can be
    recovered from the checkpoint. See the programming guide for details (constraints, etc.).
  - End-to-end semantics: This stream ensures that every records is effectively received and
    transformed exactly once, but gives no guarantees on whether the transformed data are
    outputted exactly once. For end-to-end exactly-once semantics, you have to either ensure
    that the output operation is idempotent, or use transactions to output records atomically.
    See the programming guide for more details.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>ssc</code> - StreamingContext object</dd><dd><code>kafkaParams</code> - Kafka <a href="http://kafka.apache.org/documentation.html#configuration">
    configuration parameters</a>. Requires "metadata.broker.list" or "bootstrap.servers"
    to be set with Kafka broker(s) (NOT zookeeper servers) specified in
    host1:port1,host2:port2 form.</dd><dd><code>fromOffsets</code> - Per-topic/partition Kafka offsets defining the (inclusive)
    starting point of the stream</dd><dd><code>messageHandler</code> - Function for translating each message and metadata into the desired type</dd></dl>
</li>
</ul>
<a name="createDirectStream(org.apache.spark.streaming.StreamingContext, scala.collection.immutable.Map, scala.collection.immutable.Set, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag, scala.reflect.ClassTag)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createDirectStream</h4>
<pre>public static&nbsp;&lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;&gt;&nbsp;<a href="../../../../../org/apache/spark/streaming/dstream/InputDStream.html" title="class in org.apache.spark.streaming.dstream">InputDStream</a>&lt;scala.Tuple2&lt;K,V&gt;&gt;&nbsp;createDirectStream(<a href="../../../../../org/apache/spark/streaming/StreamingContext.html" title="class in org.apache.spark.streaming">StreamingContext</a>&nbsp;ssc,
                                                                                                                                     scala.collection.immutable.Map&lt;String,String&gt;&nbsp;kafkaParams,
                                                                                                                                     scala.collection.immutable.Set&lt;String&gt;&nbsp;topics,
                                                                                                                                     scala.reflect.ClassTag&lt;K&gt;&nbsp;evidence$19,
                                                                                                                                     scala.reflect.ClassTag&lt;V&gt;&nbsp;evidence$20,
                                                                                                                                     scala.reflect.ClassTag&lt;KD&gt;&nbsp;evidence$21,
                                                                                                                                     scala.reflect.ClassTag&lt;VD&gt;&nbsp;evidence$22)</pre>
<div class="block">:: Experimental ::
 Create an input stream that directly pulls messages from Kafka Brokers
 without using any receiver. This stream can guarantee that each message
 from Kafka is included in transformations exactly once (see points below).
 <p>
 Points to note:
  - No receivers: This stream does not use any receiver. It directly queries Kafka
  - Offsets: This does not use Zookeeper to store offsets. The consumed offsets are tracked
    by the stream itself. For interoperability with Kafka monitoring tools that depend on 
    Zookeeper, you have to update Kafka/Zookeeper yourself from the streaming application.
    You can access the offsets used in each batch from the generated RDDs (see
    <a href="../../../../../org/apache/spark/streaming/kafka/HasOffsetRanges.html" title="interface in org.apache.spark.streaming.kafka"><code>HasOffsetRanges</code></a>).
  - Failure Recovery: To recover from driver failures, you have to enable checkpointing
    in the <code>StreamingContext</code>. The information on consumed offset can be
    recovered from the checkpoint. See the programming guide for details (constraints, etc.).
  - End-to-end semantics: This stream ensures that every records is effectively received and
    transformed exactly once, but gives no guarantees on whether the transformed data are
    outputted exactly once. For end-to-end exactly-once semantics, you have to either ensure
    that the output operation is idempotent, or use transactions to output records atomically.
    See the programming guide for more details.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>ssc</code> - StreamingContext object</dd><dd><code>kafkaParams</code> - Kafka <a href="http://kafka.apache.org/documentation.html#configuration">
   configuration parameters</a>. Requires "metadata.broker.list" or "bootstrap.servers"
   to be set with Kafka broker(s) (NOT zookeeper servers), specified in
   host1:port1,host2:port2 form.
   If not starting from a checkpoint, "auto.offset.reset" may be set to "largest" or "smallest"
   to determine where the stream starts (defaults to "largest")</dd><dd><code>topics</code> - Names of the topics to consume</dd></dl>
</li>
</ul>
<a name="createDirectStream(org.apache.spark.streaming.api.java.JavaStreamingContext, java.lang.Class, java.lang.Class, java.lang.Class, java.lang.Class, java.lang.Class, java.util.Map, java.util.Map, org.apache.spark.api.java.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createDirectStream</h4>
<pre>public static&nbsp;&lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;,R&gt;&nbsp;<a href="../../../../../org/apache/spark/streaming/api/java/JavaInputDStream.html" title="class in org.apache.spark.streaming.api.java">JavaInputDStream</a>&lt;R&gt;&nbsp;createDirectStream(<a href="../../../../../org/apache/spark/streaming/api/java/JavaStreamingContext.html" title="class in org.apache.spark.streaming.api.java">JavaStreamingContext</a>&nbsp;jssc,
                                                                                                                           Class&lt;K&gt;&nbsp;keyClass,
                                                                                                                           Class&lt;V&gt;&nbsp;valueClass,
                                                                                                                           Class&lt;KD&gt;&nbsp;keyDecoderClass,
                                                                                                                           Class&lt;VD&gt;&nbsp;valueDecoderClass,
                                                                                                                           Class&lt;R&gt;&nbsp;recordClass,
                                                                                                                           java.util.Map&lt;String,String&gt;&nbsp;kafkaParams,
                                                                                                                           java.util.Map&lt;kafka.common.TopicAndPartition,Long&gt;&nbsp;fromOffsets,
                                                                                                                           <a href="../../../../../org/apache/spark/api/java/function/Function.html" title="interface in org.apache.spark.api.java.function">Function</a>&lt;kafka.message.MessageAndMetadata&lt;K,V&gt;,R&gt;&nbsp;messageHandler)</pre>
<div class="block">:: Experimental ::
 Create an input stream that directly pulls messages from Kafka Brokers
 without using any receiver. This stream can guarantee that each message
 from Kafka is included in transformations exactly once (see points below).
 <p>
 Points to note:
  - No receivers: This stream does not use any receiver. It directly queries Kafka
  - Offsets: This does not use Zookeeper to store offsets. The consumed offsets are tracked
    by the stream itself. For interoperability with Kafka monitoring tools that depend on 
    Zookeeper, you have to update Kafka/Zookeeper yourself from the streaming application.
    You can access the offsets used in each batch from the generated RDDs (see
    <a href="../../../../../org/apache/spark/streaming/kafka/HasOffsetRanges.html" title="interface in org.apache.spark.streaming.kafka"><code>HasOffsetRanges</code></a>).
  - Failure Recovery: To recover from driver failures, you have to enable checkpointing
    in the <code>StreamingContext</code>. The information on consumed offset can be
    recovered from the checkpoint. See the programming guide for details (constraints, etc.).
  - End-to-end semantics: This stream ensures that every records is effectively received and
    transformed exactly once, but gives no guarantees on whether the transformed data are
    outputted exactly once. For end-to-end exactly-once semantics, you have to either ensure
    that the output operation is idempotent, or use transactions to output records atomically.
    See the programming guide for more details.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jssc</code> - JavaStreamingContext object</dd><dd><code>keyClass</code> - Class of the keys in the Kafka records</dd><dd><code>valueClass</code> - Class of the values in the Kafka records</dd><dd><code>keyDecoderClass</code> - Class of the key decoder</dd><dd><code>valueDecoderClass</code> - Class of the value decoder</dd><dd><code>recordClass</code> - Class of the records in DStream</dd><dd><code>kafkaParams</code> - Kafka <a href="http://kafka.apache.org/documentation.html#configuration">
   configuration parameters</a>. Requires "metadata.broker.list" or "bootstrap.servers"
   to be set with Kafka broker(s) (NOT zookeeper servers), specified in
   host1:port1,host2:port2 form.</dd><dd><code>fromOffsets</code> - Per-topic/partition Kafka offsets defining the (inclusive)
    starting point of the stream</dd><dd><code>messageHandler</code> - Function for translating each message and metadata into the desired type</dd></dl>
</li>
</ul>
<a name="createDirectStream(org.apache.spark.streaming.api.java.JavaStreamingContext, java.lang.Class, java.lang.Class, java.lang.Class, java.lang.Class, java.util.Map, java.util.Set)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>createDirectStream</h4>
<pre>public static&nbsp;&lt;K,V,KD extends kafka.serializer.Decoder&lt;K&gt;,VD extends kafka.serializer.Decoder&lt;V&gt;&gt;&nbsp;<a href="../../../../../org/apache/spark/streaming/api/java/JavaPairInputDStream.html" title="class in org.apache.spark.streaming.api.java">JavaPairInputDStream</a>&lt;K,V&gt;&nbsp;createDirectStream(<a href="../../../../../org/apache/spark/streaming/api/java/JavaStreamingContext.html" title="class in org.apache.spark.streaming.api.java">JavaStreamingContext</a>&nbsp;jssc,
                                                                                                                               Class&lt;K&gt;&nbsp;keyClass,
                                                                                                                               Class&lt;V&gt;&nbsp;valueClass,
                                                                                                                               Class&lt;KD&gt;&nbsp;keyDecoderClass,
                                                                                                                               Class&lt;VD&gt;&nbsp;valueDecoderClass,
                                                                                                                               java.util.Map&lt;String,String&gt;&nbsp;kafkaParams,
                                                                                                                               java.util.Set&lt;String&gt;&nbsp;topics)</pre>
<div class="block">:: Experimental ::
 Create an input stream that directly pulls messages from Kafka Brokers
 without using any receiver. This stream can guarantee that each message
 from Kafka is included in transformations exactly once (see points below).
 <p>
 Points to note:
  - No receivers: This stream does not use any receiver. It directly queries Kafka
  - Offsets: This does not use Zookeeper to store offsets. The consumed offsets are tracked
    by the stream itself. For interoperability with Kafka monitoring tools that depend on 
    Zookeeper, you have to update Kafka/Zookeeper yourself from the streaming application.
    You can access the offsets used in each batch from the generated RDDs (see
    <a href="../../../../../org/apache/spark/streaming/kafka/HasOffsetRanges.html" title="interface in org.apache.spark.streaming.kafka"><code>HasOffsetRanges</code></a>).
  - Failure Recovery: To recover from driver failures, you have to enable checkpointing
    in the <code>StreamingContext</code>. The information on consumed offset can be
    recovered from the checkpoint. See the programming guide for details (constraints, etc.).
  - End-to-end semantics: This stream ensures that every records is effectively received and
    transformed exactly once, but gives no guarantees on whether the transformed data are
    outputted exactly once. For end-to-end exactly-once semantics, you have to either ensure
    that the output operation is idempotent, or use transactions to output records atomically.
    See the programming guide for more details.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jssc</code> - JavaStreamingContext object</dd><dd><code>keyClass</code> - Class of the keys in the Kafka records</dd><dd><code>valueClass</code> - Class of the values in the Kafka records</dd><dd><code>keyDecoderClass</code> - Class of the key decoder</dd><dd><code>valueDecoderClass</code> - Class type of the value decoder</dd><dd><code>kafkaParams</code> - Kafka <a href="http://kafka.apache.org/documentation.html#configuration">
   configuration parameters</a>. Requires "metadata.broker.list" or "bootstrap.servers"
   to be set with Kafka broker(s) (NOT zookeeper servers), specified in
   host1:port1,host2:port2 form.
   If not starting from a checkpoint, "auto.offset.reset" may be set to "largest" or "smallest"
   to determine where the stream starts (defaults to "largest")</dd><dd><code>topics</code> - Names of the topics to consume</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/apache/spark/streaming/kafka/KafkaReceiver.html" title="class in org.apache.spark.streaming.kafka"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../../../org/apache/spark/streaming/kafka/KafkaUtilsPythonHelper.html" title="class in org.apache.spark.streaming.kafka"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/spark/streaming/kafka/KafkaUtils.html" target="_top">Frames</a></li>
<li><a href="KafkaUtils.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
